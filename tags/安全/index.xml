<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>安全 on Linguista</title><link>https://linguista.cn/tags/%E5%AE%89%E5%85%A8/</link><description>Recent content in 安全 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Jan 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>开源浪费的隐藏成本</title><link>https://linguista.cn/curated/henrinotes_2025_p4/hidden-cost-open-source-waste/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/hidden-cost-open-source-waste/</guid><description>&lt;h1 id="开源浪费的隐藏成本"&gt;开源浪费的隐藏成本&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;开源软件已成为现代软件开发的核心，但管理开源组件的低效性带来了巨大隐藏成本。本文基于Sonatype 2024年软件供应链报告，深入分析了依赖管理中的生产力流失、安全风险和信任危机，并提出通过自动化和上下文感知工具来解决这些挑战，将开源浪费转化为创新动力。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;开源软件彻底改变了软件开发方式，促进了创新协作，使团队能够以前所未有的速度构建产品。然而，在这繁荣景象背后，一个常被忽视的挑战正在悄然侵蚀着开发效率：管理开源组件的低效性。根据Sonatype的《2024年软件供应链现状报告》，平均每个应用程序包含150个依赖项，其中90%是传递性依赖，而这些传递性依赖竟然占已知漏洞的96%。这一数据揭示了开源依赖管理的严峻现实。&lt;/p&gt;
&lt;p&gt;这种低效性带来了三重打击：生产力的流失、安全性的威胁和信任的侵蚀。开发者多达35%的时间被消耗在解决依赖问题和管理漏洞上，而不是用于构建新产品或偿还技术债务。与此同时，软件供应链攻击在2024年增加了156%，使得依赖管理不再是可有可无的选项，而是企业生存的必需品。当软件未能达到安全性和韧性的预期时，用户对公司的信任会受到严重损害，而一旦失去信任，几乎不可能挽回。&lt;/p&gt;
&lt;p&gt;造成这种局面的根本原因在于可视性的缺失、过时依赖的堆积以及软件演化的快速步伐。直接依赖相对容易追踪，但隐藏在软件堆栈深处的传递性依赖往往成为安全盲区。报告显示，80%的应用程序依赖项超过一年未升级，这增加了未检测到的安全漏洞风险。依赖项可能在几周内就过时，使得没有自动化工具支持的团队陷入无休止的追赶状态。&lt;/p&gt;
&lt;p&gt;解决这些问题的出路在于自动化。自动化依赖管理能够简化流程、减少人工努力，使团队能够专注于创新而非重复的软件成分分析任务。上下文感知工具可以基于可利用性、业务影响和应用程序暴露程度来评估和优先级排序风险，让团队能够有效分配资源。通过提高整个依赖树的可见性，包括传递性依赖在内，团队可以就更新、替换或删除做出明智决策，从而建立一个更可靠、更有韧性的软件供应链。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;传递性依赖&lt;/strong&gt;：指应用程序所直接依赖的包自身所依赖的其他包。虽然只占依赖项数量的10%左右，但传递性依赖却占已知漏洞的96%，这使它们成为安全风险的主要来源。传递性依赖隐藏在软件堆栈深处，往往直到为时已晚才被注意到，显著增加了组织的攻击面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源浪费&lt;/strong&gt;：指在管理开源组件过程中产生的低效性，包括开发者时间的浪费、重复的软件成分分析任务、过时依赖的积累等。这种浪费不仅消耗了宝贵的开发资源，还增加了安全风险和技术债务。减少开源浪费可以节省时间和资源，增强软件供应链中的信任。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文感知工具&lt;/strong&gt;：结合自动化与优先级排序的智能工具，能够基于可利用性、业务影响和应用程序暴露程度来评估风险。这类工具允许团队有效分配资源，确保关键问题能够迅速得到解决，而不太紧急的问题不会分散对更紧迫任务的注意力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件供应链攻击&lt;/strong&gt;：针对软件依赖和组件的恶意攻击，2024年这类攻击增加了156%。积极的依赖管理能够确保漏洞尽早得到缓解，将潜在风险转化为建立信任和韧性的机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化依赖管理&lt;/strong&gt;：通过自动化工具简化依赖管理流程，减少人工努力，使开发者能够专注于创造性、高价值的工作。自动化工具有助于将安全性和依赖管理早期集成到开发周期中，使开发更快、更愉快、更有回报。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://thenewstack.io/the-hidden-cost-of-open-source-waste/?ref=dailydev"&gt;The Hidden Cost of Open Source Waste&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>反击的过滤器</title><link>https://linguista.cn/paul_graham/essays_zh/ffb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/paul_graham/essays_zh/ffb/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/paul_graham/essays_en/ffb/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/ffb.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/ffb.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/ffb.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="反击的过滤器"&gt;反击的过滤器&lt;/h1&gt;
&lt;p&gt;2003年8月&lt;/p&gt;
&lt;p&gt;我们也许能够通过让贝叶斯垃圾邮件过滤器跟踪链接来看看另一端等待什么来提高其准确性。death2spam的理查德·乔西现在在边界情况下这样做，并报告说效果很好。&lt;/p&gt;
&lt;p&gt;为什么只在边界情况下这样做？为什么只做一次？&lt;/p&gt;
&lt;p&gt;正如我在《过滤器会杀死垃圾邮件吗？》中提到的，跟踪垃圾邮件中的所有url会有一个有趣的副作用。如果流行的邮件客户端为了过滤垃圾邮件而这样做，垃圾邮件发送者的服务器将受到严重打击。我越想这个，越觉得这是个好主意。这不仅仅是有趣；很难想象有比这更精确地针对垃圾邮件发送者的反击。&lt;/p&gt;
&lt;p&gt;所以我想向那些正在研究垃圾邮件过滤器的人建议一个附加功能：&amp;ldquo;惩罚&amp;quot;模式，如果打开，将对可疑垃圾邮件中的每个url进行n次蜘蛛抓取，其中n可以由用户设置。[1]&lt;/p&gt;
&lt;p&gt;正如许多人指出的，当前邮件系统的问题之一是它太被动了。它做你告诉它做的一切。到目前为止，所有修复问题的建议似乎都涉及新协议。这个不会。&lt;/p&gt;
&lt;p&gt;如果广泛使用，自动检索垃圾邮件过滤器将使邮件系统反弹。垃圾邮件的大量数量，迄今为止一直对垃圾邮件发送者有利，现在将对他不利，就像树枝反弹在他脸上一样。自动检索垃圾邮件过滤器将提高垃圾邮件发送者的成本，并降低他的销售：他的带宽使用将飙升，他的服务器将在负载下停止运转，这将使它们对那些会响应垃圾邮件的人不可用。&lt;/p&gt;
&lt;p&gt;每小时发送一百万封邮件，每小时在你的服务器上获得一百万次点击。我们想确保这只对可疑的垃圾邮件进行。通常，发送给数百万人的任何url都可能是垃圾邮件url，因此提交每封邮件中的每个http请求几乎总是可以正常工作。但有几种情况这不是真的：例如，像Yahoo Mail和Hotmail这样的免费邮件服务发送的邮件底部的url。&lt;/p&gt;
&lt;p&gt;为了保护这样的站点，并防止滥用，自动检索应该与垃圾邮件推广站点的黑名单结合。只有黑名单上的站点才会被抓取，站点只有在经过人工检查后才会被列入黑名单。垃圾邮件的生命周期必须至少有几个小时，所以应该很容易及时更新这样的列表来干扰推广新站点的垃圾邮件。[2]&lt;/p&gt;
&lt;p&gt;大量自动检索只对高带宽连接的用户实用，但有足够的用户会给垃圾邮件发送者造成严重麻烦。实际上，这个解决方案巧妙地反映了问题。垃圾邮件的问题在于，为了到达少数易受骗的人，垃圾邮件发送者向每个人发送邮件。不易受骗的收件人只是附带损害。但不易受骗的多数人不会停止接收垃圾邮件，直到他们能够停止（或威胁停止）易受骗的人响应它。自动检索垃圾邮件过滤器为他们提供了一种方法来做到这一点。&lt;/p&gt;
&lt;p&gt;这会杀死垃圾邮件吗？不完全是。最大的垃圾邮件发送者可能能够保护他们的服务器免受自动检索过滤器的影响。然而，对他们来说最简单、最便宜的方法是在邮件中包含有效的退订链接。这对于小鱼以及雇佣垃圾邮件发送者推广他们的&amp;quot;合法&amp;quot;站点来说将是必要的。因此，如果自动检索过滤器变得广泛，它们将成为自动退订过滤器。&lt;/p&gt;
&lt;p&gt;在这种情况下，垃圾邮件将像操作系统崩溃、病毒和弹出窗口一样，成为那些懒得使用正确软件的人所遭受的瘟疫之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="注释"&gt;注释&lt;/h2&gt;
&lt;p&gt;[1] 自动检索过滤器必须跟踪重定向，并在某些情况下（例如，只说&amp;quot;点击这里&amp;quot;的页面）跟踪多级链接。还要确保http请求与流行Web浏览器的请求无法区分，包括顺序和引用者。&lt;/p&gt;
&lt;p&gt;如果响应在x时间内没有返回，默认为相当高的垃圾邮件概率。&lt;/p&gt;
&lt;p&gt;与其使n恒定，不如使它成为提到该站点的垃圾邮件数量的函数，这可能是个好主意。这将增加对滥用和事故的进一步保护。&lt;/p&gt;
&lt;p&gt;[2] 本文的早期版本使用&amp;quot;白名单&amp;quot;而不是&amp;quot;黑名单&amp;quot;一词。虽然它们要像黑名单一样工作，我更喜欢称它们为白名单，因为这可能使它们不太容易受到法律攻击。然而，这似乎只是让读者感到困惑。&lt;/p&gt;
&lt;p&gt;应该可能有多个黑名单。单点故障既容易受到攻击也容易受到滥用。&lt;/p&gt;
&lt;p&gt;感谢布莱恩·伯顿、比尔·耶拉祖尼斯、丹·吉芬、埃里克·雷蒙德和理查德·乔西阅读本文的草稿。&lt;/p&gt;</description></item><item><title>垃圾邮件过滤计划</title><link>https://linguista.cn/paul_graham/essays_zh/spam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/paul_graham/essays_zh/spam/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/paul_graham/essays_en/spam/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/spam.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/spam.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/spam.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="垃圾邮件过滤计划"&gt;垃圾邮件过滤计划&lt;/h1&gt;
&lt;p&gt;2002年8月&lt;/p&gt;
&lt;p&gt;（本文描述了在我们构建的用于测试Arc的反垃圾邮件网络邮件阅读器中使用的垃圾邮件过滤技术。改进的算法在《更好的贝叶斯过滤》中有描述。）我认为可以阻止垃圾邮件，而基于内容的过滤器是实现这一目标的方法。垃圾邮件发送者的致命弱点是他们的消息。他们可以绕过你设置的任何其他障碍。至少到目前为止是这样。但他们必须传递他们的信息，无论是什么。如果我们能够编写识别他们消息的软件，就没有办法能够绕过它。&lt;/p&gt;
&lt;p&gt;对收件人来说，垃圾邮件很容易识别。如果你雇佣某人阅读你的邮件并丢弃垃圾邮件，他们会毫无困难地做到这一点。我们需要做多少工作，除了人工智能之外，来自动化这个过程？&lt;/p&gt;
&lt;p&gt;我认为我们将能够用相当简单的算法解决这个问题。事实上，我发现你可以使用不比单个词的垃圾邮件概率的贝叶斯组合更多的东西来相当好地过滤现在的垃圾邮件。使用一个稍微调整的（如下所述）贝叶斯过滤器，我们现在在每1000封垃圾邮件中遗漏少于5封，误报率为0。&lt;/p&gt;
&lt;p&gt;统计方法通常不是人们编写垃圾邮件过滤器时首先尝试的方法。大多数黑客的第一本能是尝试编写识别垃圾邮件单个特征的软件。你看着垃圾邮件，想，这些家伙竟然敢给我发送以&amp;quot;亲爱的朋友&amp;quot;开头的邮件，或者主题行全是大写并以八个感叹号结尾的邮件。我可以用大约一行代码过滤掉这些东西。&lt;/p&gt;
&lt;p&gt;于是你这样做了，开始时它有效。几个简单的规则会大量减少你收到的垃圾邮件。仅仅查找&amp;quot;点击&amp;quot;这个词就会捕获我垃圾邮件语料库中79.7%的邮件，误报率只有1.2%。&lt;/p&gt;
&lt;p&gt;在尝试统计方法之前，我花了大约六个月编写查找单个垃圾邮件特征的软件。我发现的是，识别最后百分之几的垃圾邮件变得非常困难，而且当我使过滤器更严格时，我得到了更多的误报。&lt;/p&gt;
&lt;p&gt;误报是被错误识别为垃圾邮件的无辜邮件。对于大多数用户来说，错过合法邮件比收到垃圾邮件糟糕一个数量级，因此产生误报的过滤器就像带有死亡风险的痤疮治疗。&lt;/p&gt;
&lt;p&gt;用户收到的垃圾邮件越多，他们注意到一封无辜邮件坐在垃圾邮件文件夹中的可能性就越小。奇怪的是，你的垃圾邮件过滤器越好，误报就变得越危险，因为当过滤器真的很好时，用户更可能忽略它们捕获的一切。&lt;/p&gt;
&lt;p&gt;我不知道为什么我这么长时间才尝试统计方法。我想这是因为我对试图自己识别垃圾邮件特征上了瘾，好像我在和垃圾邮件发送者玩某种竞争游戏。（非黑客通常不会意识到这一点，但大多数黑客非常有竞争心。）当我尝试统计分析时，我立即发现它比我聪明得多。它当然发现了像&amp;quot;virtumundo&amp;quot;和&amp;quot;teens&amp;quot;这样的术语是垃圾邮件的良好指标。但它还发现&amp;quot;per&amp;quot;和&amp;quot;FL&amp;quot;和&amp;quot;ff0000&amp;quot;是垃圾邮件的良好指标。事实上，&amp;ldquo;ff0000&amp;rdquo;（亮红色的html）结果证明和任何色情术语一样是垃圾邮件的良好指标。&lt;/p&gt;
&lt;p&gt;以下是我如何进行统计过滤的概述。我从一个垃圾邮件语料库和一个非垃圾邮件语料库开始。目前每个语料库中大约有4000条消息。我扫描每个语料库中每条消息的整个文本，包括标题、嵌入的html和javascript。我目前认为字母数字字符、破折号、撇号和美元符号是标记的一部分，其他一切都是标记分隔符。（这里可能还有改进的空间。）我忽略全是数字的标记，我也忽略html注释，甚至不将它们视为标记分隔符。&lt;/p&gt;
&lt;p&gt;我计算每个标记（目前忽略大小写）在每个语料库中出现的次数。在这个阶段，我最终得到两个大的哈希表，每个语料库一个，将标记映射到出现次数。&lt;/p&gt;
&lt;p&gt;接下来我创建第三个哈希表，这次将每个标记映射到包含它的电子邮件是垃圾邮件的概率，我计算如下[1]：(let ((g (* 2 (or (gethash word good) 0))) (b (or (gethash word bad) 0))) (unless (&amp;lt; (+ g b) 5) (max .01 (min .99 (float (/ (min 1 (/ b nbad)) (+ (min 1 (/ g ngood)) (min 1 (/ b nbad))))))))) 其中word是我们计算其概率的标记，good和bad是我在第一步创建的哈希表，ngood和nbad分别是非垃圾邮件和垃圾邮件的数量。&lt;/p&gt;</description></item></channel></rss>