<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>电子邮件 on Linguage</title>
    <link>https://linguage.github.io/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</link>
    <description>Recent content in 电子邮件 on Linguage</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://linguage.github.io/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>垃圾邮件过滤计划</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/spam/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/spam/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/spam/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;垃圾邮件过滤计划&#34;&gt;垃圾邮件过滤计划&lt;/h1&gt;&#xA;&lt;p&gt;2002年8月&lt;/p&gt;&#xA;&lt;p&gt;（本文描述了在我们构建的用于测试Arc的反垃圾邮件网络邮件阅读器中使用的垃圾邮件过滤技术。改进的算法在《更好的贝叶斯过滤》中有描述。）我认为可以阻止垃圾邮件，而基于内容的过滤器是实现这一目标的方法。垃圾邮件发送者的致命弱点是他们的消息。他们可以绕过你设置的任何其他障碍。至少到目前为止是这样。但他们必须传递他们的信息，无论是什么。如果我们能够编写识别他们消息的软件，就没有办法能够绕过它。&lt;/p&gt;&#xA;&lt;p&gt;对收件人来说，垃圾邮件很容易识别。如果你雇佣某人阅读你的邮件并丢弃垃圾邮件，他们会毫无困难地做到这一点。我们需要做多少工作，除了人工智能之外，来自动化这个过程？&lt;/p&gt;&#xA;&lt;p&gt;我认为我们将能够用相当简单的算法解决这个问题。事实上，我发现你可以使用不比单个词的垃圾邮件概率的贝叶斯组合更多的东西来相当好地过滤现在的垃圾邮件。使用一个稍微调整的（如下所述）贝叶斯过滤器，我们现在在每1000封垃圾邮件中遗漏少于5封，误报率为0。&lt;/p&gt;&#xA;&lt;p&gt;统计方法通常不是人们编写垃圾邮件过滤器时首先尝试的方法。大多数黑客的第一本能是尝试编写识别垃圾邮件单个特征的软件。你看着垃圾邮件，想，这些家伙竟然敢给我发送以&amp;quot;亲爱的朋友&amp;quot;开头的邮件，或者主题行全是大写并以八个感叹号结尾的邮件。我可以用大约一行代码过滤掉这些东西。&lt;/p&gt;&#xA;&lt;p&gt;于是你这样做了，开始时它有效。几个简单的规则会大量减少你收到的垃圾邮件。仅仅查找&amp;quot;点击&amp;quot;这个词就会捕获我垃圾邮件语料库中79.7%的邮件，误报率只有1.2%。&lt;/p&gt;&#xA;&lt;p&gt;在尝试统计方法之前，我花了大约六个月编写查找单个垃圾邮件特征的软件。我发现的是，识别最后百分之几的垃圾邮件变得非常困难，而且当我使过滤器更严格时，我得到了更多的误报。&lt;/p&gt;&#xA;&lt;p&gt;误报是被错误识别为垃圾邮件的无辜邮件。对于大多数用户来说，错过合法邮件比收到垃圾邮件糟糕一个数量级，因此产生误报的过滤器就像带有死亡风险的痤疮治疗。&lt;/p&gt;&#xA;&lt;p&gt;用户收到的垃圾邮件越多，他们注意到一封无辜邮件坐在垃圾邮件文件夹中的可能性就越小。奇怪的是，你的垃圾邮件过滤器越好，误报就变得越危险，因为当过滤器真的很好时，用户更可能忽略它们捕获的一切。&lt;/p&gt;&#xA;&lt;p&gt;我不知道为什么我这么长时间才尝试统计方法。我想这是因为我对试图自己识别垃圾邮件特征上了瘾，好像我在和垃圾邮件发送者玩某种竞争游戏。（非黑客通常不会意识到这一点，但大多数黑客非常有竞争心。）当我尝试统计分析时，我立即发现它比我聪明得多。它当然发现了像&amp;quot;virtumundo&amp;quot;和&amp;quot;teens&amp;quot;这样的术语是垃圾邮件的良好指标。但它还发现&amp;quot;per&amp;quot;和&amp;quot;FL&amp;quot;和&amp;quot;ff0000&amp;quot;是垃圾邮件的良好指标。事实上，&amp;ldquo;ff0000&amp;rdquo;（亮红色的html）结果证明和任何色情术语一样是垃圾邮件的良好指标。&lt;/p&gt;&#xA;&lt;p&gt;以下是我如何进行统计过滤的概述。我从一个垃圾邮件语料库和一个非垃圾邮件语料库开始。目前每个语料库中大约有4000条消息。我扫描每个语料库中每条消息的整个文本，包括标题、嵌入的html和javascript。我目前认为字母数字字符、破折号、撇号和美元符号是标记的一部分，其他一切都是标记分隔符。（这里可能还有改进的空间。）我忽略全是数字的标记，我也忽略html注释，甚至不将它们视为标记分隔符。&lt;/p&gt;&#xA;&lt;p&gt;我计算每个标记（目前忽略大小写）在每个语料库中出现的次数。在这个阶段，我最终得到两个大的哈希表，每个语料库一个，将标记映射到出现次数。&lt;/p&gt;&#xA;&lt;p&gt;接下来我创建第三个哈希表，这次将每个标记映射到包含它的电子邮件是垃圾邮件的概率，我计算如下[1]：(let ((g (* 2 (or (gethash word good) 0))) (b (or (gethash word bad) 0))) (unless (&amp;lt; (+ g b) 5) (max .01 (min .99 (float (/ (min 1 (/ b nbad)) (+ (min 1 (/ g ngood)) (min 1 (/ b nbad))))))))) 其中word是我们计算其概率的标记，good和bad是我在第一步创建的哈希表，ngood和nbad分别是非垃圾邮件和垃圾邮件的数量。&lt;/p&gt;&#xA;&lt;p&gt;我将此解释为代码以显示几个重要细节。我想稍微偏向概率以避免误报，通过反复试验，我发现一个好的方法是将good中的所有数字加倍。这有助于区分偶尔确实出现在合法邮件中的词和几乎从不出现的词。我只考虑总共出现超过五次的词（实际上，由于加倍，在非垃圾邮件中出现三次就足够了）。然后是关于给在一个语料库中出现但不在另一个语料库中出现的词分配什么概率的问题。同样通过反复试验，我选择了.01和.99。这里可能还有调整的空间，但随着语料库的增长，这种调整无论如何都会自动发生。&lt;/p&gt;&#xA;&lt;p&gt;特别细心的人会注意到，虽然为了计算出现次数的目的我将每个语料库视为一个长文本流，但在计算垃圾邮件概率时，我使用每个语料库中的邮件数量，而不是它们的组合长度作为除数。这增加了另一个轻微的偏向以防止误报。&lt;/p&gt;&#xA;&lt;p&gt;当新邮件到达时，它被扫描成标记，最有趣的十五个标记，其中有趣度是通过它们的垃圾邮件概率与中性的.5相差多远来衡量的，被用来计算邮件是垃圾邮件的概率。如果probs是十五个单独概率的列表，你这样计算组合概率：(let ((prod (apply #&amp;rsquo;* probs))) (/ prod (+ prod (apply #&amp;rsquo;* (mapcar #&amp;rsquo;(lambda (x) (- 1 x)) probs))))) 实践中出现的一个问题是给你从未见过的词分配什么概率，即没有出现在词概率哈希表中的词。我再次通过反复试验发现，.4是一个好数字。如果你以前从未见过一个词，它可能是相当无辜的；垃圾邮件词往往太熟悉了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
