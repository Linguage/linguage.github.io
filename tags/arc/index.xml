<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arc on Linguista</title>
    <link>http://localhost:1355/tags/arc/</link>
    <description>Recent content in Arc on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1355/tags/arc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Why Arc Isn&#39;t Especially Object-Oriented</title>
      <link>http://localhost:1355/paul_graham/essays_en/noop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1355/paul_graham/essays_en/noop/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;http://localhost:1355/paul_graham/essays_zh/noop/&#34;&gt;中文版本&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;why-arc-isnt-especially-object-oriented&#34;&gt;Why Arc Isn&amp;rsquo;t Especially Object-Oriented&lt;/h1&gt;&#xA;&lt;p&gt;There is a kind of mania for object-oriented programming at the moment, but some of the smartest programmers I know are some of the least excited about it.&lt;/p&gt;&#xA;&lt;p&gt;My own feeling is that object-oriented programming is a useful technique in some cases, but it isn&amp;rsquo;t something that has to pervade every program you write. You should be able to define new types, but you shouldn&amp;rsquo;t have to express every program as the definition of new types.&lt;/p&gt;</description>
    </item>
    <item>
      <title>为什么 Arc 不是特别面向对象的</title>
      <link>http://localhost:1355/paul_graham/essays_zh/noop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1355/paul_graham/essays_zh/noop/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;http://localhost:1355/paul_graham/essays_en/noop/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;为什么-arc-不是特别面向对象的&#34;&gt;为什么 Arc 不是特别面向对象的&lt;/h1&gt;&#xA;&lt;p&gt;目前有一种对面向对象编程的狂热，但我认识的一些最聪明的程序员是对此最不兴奋的人。&lt;/p&gt;&#xA;&lt;p&gt;我自己的感觉是，面向对象编程在某些情况下是一种有用的技术，但它不是必须渗透到你写的每个程序中的东西。你应该能够定义新类型，但不必将每个程序都表达为新类型的定义。&lt;/p&gt;&#xA;&lt;p&gt;我认为人们喜欢面向对象编程有五个原因，其中三个半是坏的：&lt;/p&gt;&#xA;&lt;p&gt;如果你有一个静态类型的语言，没有词法闭包或宏，面向对象编程是令人兴奋的。在某种程度上，它提供了一种绕过这些限制的方法。（见 Greenspun 第十规则。）&lt;/p&gt;&#xA;&lt;p&gt;面向对象编程在大公司很受欢迎，因为它适合他们编写软件的方式。在大公司，软件往往由大量（且经常变动的）平庸程序员团队编写。面向对象编程对这些程序员施加了一种纪律，防止任何一个人造成太大的损害。代价是产生的代码充满了协议和重复。这对大公司来说不是太高的价格，因为他们的软件无论如何都可能是臃肿和充满重复的。&lt;/p&gt;&#xA;&lt;p&gt;面向对象编程产生了很多看起来像工作的东西。在折叠纸的时代，有一种程序员只会在一页上放五到十行代码，前面是二十行精心格式化的注释。面向对象编程对这些来说就像可卡因：它让你将所有这些脚手架直接整合到源代码中。Lisp 黑客可能通过将符号推到列表上来处理的东西，变成了整个类的文件和方法。所以如果你想说服自己或其他人你正在做很多工作，这是一个好工具。&lt;/p&gt;&#xA;&lt;p&gt;如果语言本身是一个面向对象的程序，它可以被用户扩展。嗯，也许。或者也许你可以通过提供面向对象编程的子概念单点来做得更好。例如，重载本质上并不与类绑定。我们拭目以待。&lt;/p&gt;&#xA;&lt;p&gt;面向对象的抽象很好地映射到某些特定类型程序的领域，比如模拟和 CAD 系统。&lt;/p&gt;&#xA;&lt;p&gt;我个人从来不需要面向对象的抽象。Common Lisp 有一个极其强大的对象系统，我从未使用过一次。我做过很多事情（例如，制作充满闭包的哈希表），这些在较弱的语言中需要面向对象技术，但我从未不得不使用 CLOS。&lt;/p&gt;&#xA;&lt;p&gt;也许我只是很愚蠢，或者只在应用程序的有限子集上工作过。基于自己的编程经验设计语言是有危险的。但放入你从未需要的东西因为它被认为是个好主意似乎更危险。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
