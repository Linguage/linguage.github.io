<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>流行度 on Linguista</title>
    <link>https://linguage.github.io/tags/%E6%B5%81%E8%A1%8C%E5%BA%A6/</link>
    <description>Recent content in 流行度 on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://linguage.github.io/tags/%E6%B5%81%E8%A1%8C%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>如何变得流行</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/popular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/popular/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/popular/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/popular.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/popular.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/popular.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;如何变得流行&#34;&gt;如何变得流行&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（本文是作为一种新语言的商业计划书而写的。因此它缺少（因为想当然）一个好的编程语言最重要的特征：非常强大的抽象能力。）&lt;/p&gt;&#xA;&lt;p&gt;我有一个朋友曾经告诉一位著名的操作系统专家，他想设计一种真正好的编程语言。专家告诉他，这将是浪费时间，编程语言不会因为其优点而变得流行或不流行，所以无论他的语言有多好，都没人会使用。至少，这是他设计的语言所发生的情况。&lt;/p&gt;&#xA;&lt;p&gt;到底是什么让一种语言变得流行？流行的语言是否配得上它们的流行度？试图定义一个好的编程语言是否值得？你会怎么做？&lt;/p&gt;&#xA;&lt;p&gt;我认为这些问题的答案可以通过观察黑客并了解他们想要什么来找到。编程语言是为黑客而设计的，而编程语言作为编程语言（而不是，比如说，作为指称语义练习或编译器设计练习）是好的，当且仅当黑客喜欢它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-流行的机制&#34;&gt;1 流行的机制&lt;/h2&gt;&#xA;&lt;p&gt;当然，大多数人在选择编程语言时并不仅仅基于它们的优点。大多数程序员被告知要使用什么语言。然而我认为这些外部因素对编程语言流行度的影响并不像人们有时认为的那么大。我认为更大的问题是黑客对好的编程语言的想法与大多数语言设计者的想法不同。&lt;/p&gt;&#xA;&lt;p&gt;在这两者之间，黑客的意见才是重要的。编程语言不是定理。它们是工具，为人们设计的，必须像鞋子必须为人类的脚设计一样，适合人类的优点和缺点。如果鞋子穿上时夹脚，那它就是一双坏鞋，无论它作为雕塑品多么优雅。&lt;/p&gt;&#xA;&lt;p&gt;可能是大多数程序员无法区分好语言和坏语言。但这与其他工具没有什么不同。这并不意味着尝试设计好语言是浪费时间。专家黑客在看到好语言时能够识别出来，他们会使用它。诚然，专家黑客是极少数，但这个极少数群体编写了所有好的软件，他们的影响力使得其他程序员倾向于使用他们使用的任何语言。通常，这不仅仅是影响，而是命令：专家黑客通常就是那些作为老板或导师告诉其他程序员使用什么语言的人。&lt;/p&gt;&#xA;&lt;p&gt;专家黑客的意见并不是决定编程语言相对流行度的唯一力量——遗留软件（Cobol）和炒作（Ada、Java）也起作用——但我认为它是长期内最强大的力量。考虑到初始的关键质量和足够的时间，编程语言可能会变得与其应得的流行度相当。而流行度进一步将好语言与坏语言分开，因为来自真实用户的反馈总是导致改进。看看任何流行语言在其生命周期中发生了多大变化。Perl和Fortran是极端的例子，但即使是Lisp也发生了很大变化。例如，Lisp 1.5没有宏；这些是后来发展的，在麻省理工学院的黑客花了几年时间使用Lisp编写真实程序之后。[1]&lt;/p&gt;&#xA;&lt;p&gt;所以无论一种语言是否必须好才能流行，我认为一种语言必须流行才能好。它必须保持流行才能保持好。编程语言的工艺水平不会停滞不前。然而我们今天拥有的Lisp几乎与麻省理工学院在1980年代中期的Lisp相同，因为那是Lisp最后一次拥有足够大和要求高的用户群的时候。&lt;/p&gt;&#xA;&lt;p&gt;当然，黑客在使用语言之前必须了解它。他们如何听到？从其他黑客那里。但必须有一些初始的黑客群体使用该语言，其他人才能听到。我想知道这个群体必须多大；多少用户构成关键质量？我随口一说，二十个。如果一种语言有二十个独立的用户，意味着二十个用户自己决定使用它，我会认为它是真实的。&lt;/p&gt;&#xA;&lt;p&gt;达到那里并不容易。如果从零到二十比从二十到一千更难，我不会感到惊讶。获得那初始二十个用户的最好方法可能是使用特洛伊木马：给人们一个他们想要的应用程序，而这个应用程序恰好是用新语言编写的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-外部因素&#34;&gt;2 外部因素&lt;/h2&gt;&#xA;&lt;p&gt;让我们首先承认一个确实影响编程语言流行度的外部因素。要变得流行，编程语言必须是流行系统的脚本语言。Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来Perl也是。Tcl是Tk的脚本语言。Java和Javascript旨在成为Web浏览器的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;Lisp不是一个大规模流行的语言，因为它不是大规模流行系统的脚本语言。它保留的流行度可以追溯到1960年代和1970年代，当时它是麻省理工学院的脚本语言。当时的许多伟大程序员都在某个时期与麻省理工学院有关联。在1970年代初期，在C之前，麻省理工学院的Lisp方言MacLisp是严肃黑客想要使用的唯一编程语言之一。&lt;/p&gt;&#xA;&lt;p&gt;今天，Lisp是两个适度流行系统的脚本语言，Emacs和Autocad，因此我怀疑今天大部分Lisp编程都是在Emacs Lisp或AutoLisp中完成的。&lt;/p&gt;&#xA;&lt;p&gt;编程语言不是孤立存在的。Hack是一个及物动词——黑客通常在hack某物——在实践中，语言是相对于它们用来hack的任何东西来评判的。所以如果你想设计一种流行的语言，你要么必须提供比语言更多的东西，要么你必须设计你的语言来取代某个现有系统的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;Common Lisp不受欢迎的部分原因是因为它是一个孤儿。它确实伴随着一个要hack的系统：Lisp Machine。但Lisp Machines（以及并行计算机）在1980年代被通用处理器日益增长的力量压垮了。如果Common Lisp是Unix的好脚本语言，它可能会保持流行。唉，它是一个非常糟糕的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;描述这种情况的一种方法是说语言不是根据其自身的优点来评判的。另一种观点是，编程语言除非也是某物的脚本语言，否则就不是真正的编程语言。如果这让人感到意外，这似乎不公平。我认为这并不比期望编程语言有实现更不公平。这只是编程语言的一部分。&lt;/p&gt;&#xA;&lt;p&gt;当然，编程语言需要好的实现，而且这必须是免费的。公司会为软件付费，但个人黑客不会，而你需要吸引的是黑客。&lt;/p&gt;&#xA;&lt;p&gt;语言也需要有一本关于它的书。这本书应该是薄的、写得好的，充满了好的例子。K&amp;amp;R是这里的理想。目前我几乎会说一种语言必须有一本O&amp;rsquo;Reilly出版的书。这正成为对黑客重要性的测试。&lt;/p&gt;&#xA;&lt;p&gt;也应该有在线文档。事实上，书可以作为在线文档开始。但我不认为物理书已经过时了。它们的格式方便，出版商施加的事实审查是一种有用的、虽然不完美的过滤器。书店是学习新语言的最重要地方之一。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-简洁&#34;&gt;3 简洁&lt;/h2&gt;&#xA;&lt;p&gt;假设你能提供任何语言需要的三个东西——一个免费的实现、一本书、以及要hack的东西——你如何制造一种黑客会喜欢的语言？&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢的一件事是简洁。黑客是懒惰的，与数学家和现代主义建筑师是懒惰的方式相同：他们讨厌任何多余的东西。说一个即将编写程序的黑客基于他必须键入的字符总数来选择使用什么语言，至少是潜意识的，这离真相不远。如果这不是黑客思考的精确方式，语言设计者最好表现得好像是这样。&lt;/p&gt;&#xA;&lt;p&gt;试图用冗长的表达来宠用户，这些表达旨在类似英语，是错误的。Cobol因此缺陷而臭名昭著。黑客会认为被要求写&lt;/p&gt;&#xA;&lt;p&gt;add x to y giving z&lt;/p&gt;&#xA;&lt;p&gt;而不是&lt;/p&gt;&#xA;&lt;p&gt;z = x+y&lt;/p&gt;</description>
    </item>
    <item>
      <title>如果Lisp这么好</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/iflisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/iflisp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/iflisp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/iflisp.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/iflisp.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/iflisp.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;如果lisp这么好&#34;&gt;如果Lisp这么好&lt;/h1&gt;&#xA;&lt;p&gt;2003年5月&lt;/p&gt;&#xA;&lt;p&gt;如果Lisp这么好，为什么没有更多人使用它？我最近在一次演讲中被听众中的一个学生问到了这个问题。而且不是第一次了。&lt;/p&gt;&#xA;&lt;p&gt;在语言方面，就像在许多事情中一样，流行度和质量之间没有太大关联。为什么约翰·格里沙姆（《诉讼之王》销售排名第44）比简·奥斯汀（《傲慢与偏见》销售排名第6191）卖得更好？即使是格里沙姆会声称这是因为他是更好的作家吗？&lt;/p&gt;&#xA;&lt;p&gt;这是《傲慢与偏见》的第一句话：&amp;ldquo;凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;举世公认的真理？&amp;rdquo; 对于一个爱情故事的第一句话来说，这些词太长了。&lt;/p&gt;&#xA;&lt;p&gt;就像简·奥斯汀的作品一样，Lisp看起来很难。它的语法，或者说缺乏语法，使它看起来完全不同于大多数人习惯的语言。在学习Lisp之前，我也害怕它。我最近发现了一本1983年的笔记本，我在上面写道：&amp;ldquo;我想我应该学习Lisp，但它看起来太陌生了。&amp;ldquo;幸运的是，我当时19岁，对学习新东西没有太多抵触。我非常无知，学习几乎任何东西都意味着学习新事物。&lt;/p&gt;&#xA;&lt;p&gt;被Lisp吓到的人们编造了其他不使用它的理由。当C是默认语言时，标准的借口是Lisp太慢。现在Lisp方言是可用语言中较快的之一，这个借口已经消失了。现在的标准借口是公开循环的：其他语言更流行。&lt;/p&gt;&#xA;&lt;p&gt;（小心这种推理。它会让你得到Windows。）&lt;/p&gt;&#xA;&lt;p&gt;流行度总是自我延续的，但在编程语言中尤其如此。为流行语言编写的库更多，这使它们更流行。程序经常必须与现有程序一起工作，如果它们用相同的语言编写，这会更容易，所以语言像病毒一样从程序传播到程序。管理者更喜欢流行的语言，因为它们给他们更多对开发者的控制力，开发者可以更容易被替换。&lt;/p&gt;&#xA;&lt;p&gt;确实，如果编程语言都或多或少等价，那么使用除最流行语言之外的任何语言都没有什么理由。但它们并不都等价，差远了。这就是为什么不那么流行的语言，像简·奥斯汀的小说，继续存在的原因。当其他人在阅读最新的约翰·格里沙姆小说时，总会有一小部分人在阅读简·奥斯汀。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;日语翻译 | 罗马尼亚语翻译 | 西班牙语翻译&lt;/em&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
