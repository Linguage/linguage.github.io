<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>依赖管理 on Linguista</title><link>https://linguista.cn/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><description>Recent content in 依赖管理 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>长期软件开发的思考与建议</title><link>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</guid><description>&lt;h1 id="长期软件开发的思考与建议"&gt;长期软件开发的思考与建议&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者为荷兰选举委员会开发开源投票统计软件 Abacus 的实践经验，系统性地总结了长期软件开发的核心理念与方法。作者指出，与现今通过 CI/CD 持续迭代的软件服务不同，核电站、选举系统、心脏起搏器等领域的软件需要在未来数十年内保持稳定运行。文章从 Mastodon 社区收集了大量反馈，提炼出关于依赖管理、复杂性控制、测试策略、文档规范、团队建设等15个方面的实用建议，为需要长期维护的软件项目提供了全面的指导框架。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者受荷兰选举委员会邀请反思其开源投票统计软件为切入点，指出了长期软件开发与现代敏捷开发模式的本质差异。现今大多数软件作为服务提供，可以通过持续部署和持续集成来修复问题，但某些关键领域如核电站控制系统、选举软件、医疗设备等，要求软件在几十年内保持稳定运行，任何变更都需要提前规划和公告。&lt;/p&gt;
&lt;p&gt;作者在 Mastodon 社区征求意见后，收集了大量来自实践者的反馈，将这些经验整理成系统性的建议。文章的核心论点是：长期软件开发需要与传统开发模式完全不同的思维方式和技术选择。作者特别强调了依赖管理的重要性，将软件依赖分为四个层次——基础编程语言、紧密耦合的框架、数据库和可替换的辅助库，并指出越底层的依赖选择越关键。&lt;/p&gt;
&lt;p&gt;在复杂性管理方面，作者提出&amp;quot;复杂性是软件开发的最终敌人&amp;quot;这一核心观点，通过图表展示了代码复杂性与代码量之间的关系，强调必须在早期主动进行重构和简化。文章还详细讨论了测试的价值、文档的重要性、团队管理的策略以及开源的优势，并推荐了《编程实践》《人月神话》《软件设计哲学》等经典著作，最后引用了莱曼的软件进化法则来支持其观点。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;依赖层次结构&lt;/strong&gt;：软件依赖可分为四个层级——基础编程语言（最底层，最难更换）、紧密耦合的框架（深度集成，更换成本高）、数据库（数据存储核心，迁移复杂）和可替换的辅助库（最上层，相对容易替换）。长期软件开发必须格外关注底层依赖的选择，因为技术质量、使用者基数、维护状况、资金来源等因素都会影响依赖的长期稳定性。依赖可能随时间出现版本漂移、被废弃、甚至遭到劫持，因此建立定期健康检查机制至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;：复杂性会随着代码量的增加而自然增长，如果缺乏主动管理，系统最终会变得无法维护。作者强调必须在开发早期就持续进行重构和简化，而不是推迟到&amp;quot;以后&amp;quot;。简单的代码虽然可能不够&amp;quot;聪明&amp;quot;或不够高效，但更容易理解、调试和维护。在长期项目中，为了避免过早优化是万恶之源，应该优先选择编写无趣但简单的代码，而不是追求高性能但复杂的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lindy 效应与技术选择&lt;/strong&gt;：Lindy 效应指出，技术的预期寿命与其当前年龄成正比——一项技术已经存在的时间越长，它可能继续存在的时间也越长。这意味着在长期软件开发中，应该优先选择经过时间考验的技术，而不是被 LinkedIn 或社交媒体炒作的新技术。新技术的风险在于其长期价值尚未得到验证，可能在关键时刻失去支持或出现无法预见的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试的战略价值&lt;/strong&gt;：测试不仅是质量保证手段，更是长期维护的安全网。当依赖频繁变化时，完善的测试套件可以确保系统仍能正常工作；当项目暂停后重新启动时，测试可以帮助新开发者快速理解系统行为；当需要重构或移除依赖时，测试提供了变更的信心。测试的价值在长期项目中会呈指数级增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档与知识传承&lt;/strong&gt;：长期软件开发必须重视特定文档的需求，包括架构设计文档、API 文档、运维手册等。代码注释应该解释&amp;quot;为什么&amp;quot;而不是&amp;quot;做什么&amp;quot;，提交信息应该记录变更的原因。团队还需要建立内部 wiki 或知识库，记录决策过程、架构演进和故障经验。这些文档在原始开发者离开后，成为知识传承的关键载体。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://berthub.eu/articles/posts/on-long-term-software-development/"&gt;On Long Term Software Development&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Bert Hubert&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>开源浪费的隐藏成本</title><link>https://linguista.cn/curated/henrinotes_2025_p4/hidden-cost-open-source-waste/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/hidden-cost-open-source-waste/</guid><description>&lt;h1 id="开源浪费的隐藏成本"&gt;开源浪费的隐藏成本&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;开源软件已成为现代软件开发的核心，但管理开源组件的低效性带来了巨大隐藏成本。本文基于Sonatype 2024年软件供应链报告，深入分析了依赖管理中的生产力流失、安全风险和信任危机，并提出通过自动化和上下文感知工具来解决这些挑战，将开源浪费转化为创新动力。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;开源软件彻底改变了软件开发方式，促进了创新协作，使团队能够以前所未有的速度构建产品。然而，在这繁荣景象背后，一个常被忽视的挑战正在悄然侵蚀着开发效率：管理开源组件的低效性。根据Sonatype的《2024年软件供应链现状报告》，平均每个应用程序包含150个依赖项，其中90%是传递性依赖，而这些传递性依赖竟然占已知漏洞的96%。这一数据揭示了开源依赖管理的严峻现实。&lt;/p&gt;
&lt;p&gt;这种低效性带来了三重打击：生产力的流失、安全性的威胁和信任的侵蚀。开发者多达35%的时间被消耗在解决依赖问题和管理漏洞上，而不是用于构建新产品或偿还技术债务。与此同时，软件供应链攻击在2024年增加了156%，使得依赖管理不再是可有可无的选项，而是企业生存的必需品。当软件未能达到安全性和韧性的预期时，用户对公司的信任会受到严重损害，而一旦失去信任，几乎不可能挽回。&lt;/p&gt;
&lt;p&gt;造成这种局面的根本原因在于可视性的缺失、过时依赖的堆积以及软件演化的快速步伐。直接依赖相对容易追踪，但隐藏在软件堆栈深处的传递性依赖往往成为安全盲区。报告显示，80%的应用程序依赖项超过一年未升级，这增加了未检测到的安全漏洞风险。依赖项可能在几周内就过时，使得没有自动化工具支持的团队陷入无休止的追赶状态。&lt;/p&gt;
&lt;p&gt;解决这些问题的出路在于自动化。自动化依赖管理能够简化流程、减少人工努力，使团队能够专注于创新而非重复的软件成分分析任务。上下文感知工具可以基于可利用性、业务影响和应用程序暴露程度来评估和优先级排序风险，让团队能够有效分配资源。通过提高整个依赖树的可见性，包括传递性依赖在内，团队可以就更新、替换或删除做出明智决策，从而建立一个更可靠、更有韧性的软件供应链。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;传递性依赖&lt;/strong&gt;：指应用程序所直接依赖的包自身所依赖的其他包。虽然只占依赖项数量的10%左右，但传递性依赖却占已知漏洞的96%，这使它们成为安全风险的主要来源。传递性依赖隐藏在软件堆栈深处，往往直到为时已晚才被注意到，显著增加了组织的攻击面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源浪费&lt;/strong&gt;：指在管理开源组件过程中产生的低效性，包括开发者时间的浪费、重复的软件成分分析任务、过时依赖的积累等。这种浪费不仅消耗了宝贵的开发资源，还增加了安全风险和技术债务。减少开源浪费可以节省时间和资源，增强软件供应链中的信任。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文感知工具&lt;/strong&gt;：结合自动化与优先级排序的智能工具，能够基于可利用性、业务影响和应用程序暴露程度来评估风险。这类工具允许团队有效分配资源，确保关键问题能够迅速得到解决，而不太紧急的问题不会分散对更紧迫任务的注意力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件供应链攻击&lt;/strong&gt;：针对软件依赖和组件的恶意攻击，2024年这类攻击增加了156%。积极的依赖管理能够确保漏洞尽早得到缓解，将潜在风险转化为建立信任和韧性的机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化依赖管理&lt;/strong&gt;：通过自动化工具简化依赖管理流程，减少人工努力，使开发者能够专注于创造性、高价值的工作。自动化工具有助于将安全性和依赖管理早期集成到开发周期中，使开发更快、更愉快、更有回报。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://thenewstack.io/the-hidden-cost-of-open-source-waste/?ref=dailydev"&gt;The Hidden Cost of Open Source Waste&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>