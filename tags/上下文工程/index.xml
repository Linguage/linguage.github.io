<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>上下文工程 on Linguista</title><link>https://linguista.cn/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 上下文工程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Oct 2025 08:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Context Engineering &amp; Coding Agents</title><link>https://linguista.cn/info/htmlcards/cursor_openai_devday_speech/</link><pubDate>Thu, 09 Oct 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/info/htmlcards/cursor_openai_devday_speech/</guid><description>本文深入探讨了上下文工程如何重塑人机协作边界，从1960年代打孔卡到2024年自主编程智能体的完整演化路径。文中详细解析了Cursor如何实现每日4亿+代码请求的处理能力，以及如何通过30分钟实时反馈循环来持续强化模型性能，展示了智能体时代编程范式转变的宏大图景。</description></item><item><title>超越提示词的艺术：AI 编程的未来是“上下文工程”</title><link>https://linguista.cn/info/htmlcards/context_engineering_cursor/</link><pubDate>Thu, 09 Oct 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/info/htmlcards/context_engineering_cursor/</guid><description>随着 AI 编程工具如 Cursor 的崛起，软件开发范式正在经历从“提示词工程”到“上下文工程”的根本性转变。文章深入探讨了如何通过构建“字面精确”与“语义相关”的双层检索框架，将代码库转化为 AI 的“记忆宫殿”，使智能体能够从被动补全进化为具备自主分析与决策能力的协作伙伴。开发者不再仅仅是代码的书写者，更晋升为定义上下文环境的认知架构师。</description></item><item><title>Cursor 团队上下文工程与编程智能体演变</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/cursor-context-engineering-coding-agents/</link><pubDate>Thu, 09 Oct 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/cursor-context-engineering-coding-agents/</guid><description>&lt;h1 id="cursor-团队上下文工程与编程智能体演变"&gt;Cursor 团队上下文工程与编程智能体演变&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文记录了 Cursor 团队成员 Lee 与 CEO Michael 关于上下文工程与 AI 编程智能体发展的深度对话。内容涵盖编程工具从打孔卡到 AI 智能体的历史演进，Cursor 产品从 Tab 代码补全到自主编程智能体的技术迭代，以及上下文检索优化、多智能体并行管理、人机协作安全机制等核心实践。文章提出上下文工程是提示工程的升级，强调最小化高质量 token 输入与语义检索的重要性，并展望了软件工程彻底自动化的未来愿景。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本文首先梳理了编程工具的发展历程，从 1960 年代打孔卡、早期终端，到 1970 年代 Apple II，1980 年代 GUI，再到 1990、2000 年代的 Front Page、Dreamweaver、Visual Studio 和 Sublime Text 等 IDE。这一演进史显示，每次技术迭代都通过提升 UI/UX 推动更高层次目标的实现。而 AI 技术正在加速重演这一过程，使编程前所未有的易用和强大。&lt;/p&gt;
&lt;p&gt;接着，文章详细介绍了 Cursor 产品演化。Tab 功能起初仅预测下一个单词或一行代码，现在能预测鼠标光标动作。每日 4 亿次请求产生的数据，通过实时在线强化学习优化模型，用户接受或拒绝的建议在 30 分钟内即可反馈更新。团队从通用模型转向专门为&amp;quot;下一步行动预测&amp;quot;训练的自定义模型，在速度与质量间找到平衡点。&lt;/p&gt;
&lt;p&gt;在智能体架构方面，Cursor 从简单补全进化到自主编程智能体，支持工具调用、自主上下文获取。用户可通过 Composer 功能实现多文件编辑与会话式管理。2024 年推出的完全自主编码智能体不再依赖人工提供全部上下文，而是模型自我检索构建上下文。&lt;/p&gt;
&lt;p&gt;上下文工程实践部分强调，随着上下文窗口变大，模型信息回忆质量反而下降，因此目标是使用尽可能少且高质量的 token。团队通过自动索引、创建 embedding 实现语义检索，从通用 embedding 模型迁移到自定向训练模型，通过 AB 测试验证性能提升。语义搜索不仅提升用户追问率，还带来更高的 token 使用量。&lt;/p&gt;
&lt;p&gt;多智能体协作方面，Cursor 探索了从 CLI 到专业智能体如 Bugbot 的发展。智能体长周期任务能力增强，支持规划、前置研究、任务列表管理与工作流打包分享。人机协作保持人类在环机制，关键操作需用户授权，支持自定义 hooks 与团队协作防护。&lt;/p&gt;</description></item><item><title>「翻译」Anthropic:为人工智能代理进行有效的上下文工程</title><link>https://linguista.cn/rosetta/technology/anthropic_context_engineering/</link><pubDate>Wed, 01 Oct 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/anthropic_context_engineering/</guid><description>&lt;p&gt;在提示工程（prompt engineering）成为应用人工智能领域关注焦点几年后，一个新术语开始崭露头角：&lt;strong&gt;上下文工程（context engineering）&lt;/strong&gt;。使用语言模型进行构建，正逐渐从为提示寻找合适的词语和短语，转变为回答一个更宏观的问题：“什么样的上下文配置最有可能产生我们模型的期望行为？”&lt;/p&gt;</description></item><item><title>构建长运行智能体的理论与实践</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/dont-build-multi-agents/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/dont-build-multi-agents/</guid><description>&lt;h1 id="构建长运行智能体的理论与实践"&gt;构建长运行智能体的理论与实践&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;当前智能体开发尚处于早期阶段，主流的多智能体架构在实际生产环境中表现不佳。本文指出上下文工程是智能体开发的核心，远比提示工程更为重要。作者主张采用单线程线性智能体架构，确保所有决策和行动在同一上下文中连续进行，从而避免误解和冲突。对于超长任务，可通过专门的 LLM 模型压缩历史上下文来提升处理能力。现阶段多智能体协作技术尚未成熟，单智能体架构更为可靠。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇即指出智能体开发领域缺乏统一标准，类似于网页开发早期的混沌状态。当前主流的多智能体框架（如 OpenAI Swarm、Microsoft Autogen）在复杂任务中容易导致错误累积和决策冲突。作者通过 Flappy Bird 克隆开发实例，说明了子智能体之间缺乏完整上下文共享会导致风格不一致和功能不匹配等问题。&lt;/p&gt;
&lt;p&gt;核心论点围绕&amp;quot;上下文工程&amp;quot;展开，这是智能体开发的关键原则。文章强调两大原则：共享上下文和行动隐含决策。所有子智能体必须获得完整的任务背景和前序决策轨迹，而每个行动都包含隐含决策，若各智能体的决策冲突，最终结果必然不理想。解决方案是采用单线程线性智能体架构，所有决策和行动都在同一上下文中连续进行。&lt;/p&gt;
&lt;p&gt;文章通过三个真实案例支撑论点：Claude Code 的子智能体设计选择了串行而非并行模式；代码编辑模型从分离式架构转向单一模型一次性完成；多智能体并行协作在理论上可行但现实中技术尚未成熟。作者认为，随着单智能体与人类沟通能力的提升，未来多智能体协作的瓶颈会自然突破。&lt;/p&gt;
&lt;p&gt;最后，文章提出了上下文工程框架和相应的心智模型。智能体开发者需时刻关注上下文传递和决策一致性，在架构设计时权衡上下文窗口限制与系统复杂度。对于超长任务，可采用专门模型压缩历史上下文，提取关键决策和事件。未来智能体发展需要保持开放心态，持续迭代框架和方法。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;上下文工程&lt;/strong&gt;：这是智能体开发的核心工作，远超传统的提示工程。它要求系统能自动、动态地为智能体提供最关键的任务背景和决策信息，确保所有行动都基于完整的任务背景和前序决策轨迹。在长运行智能体中，上下文工程是确保系统可靠性的关键，需要针对具体领域进行模型微调来压缩历史上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单线程线性智能体&lt;/strong&gt;：这是作者推荐的最简单且有效的架构。所有决策和行动都在同一上下文中连续进行，极大减少误解和冲突。与多智能体并行架构相比，单线程智能体避免了子智能体之间的上下文隔离问题，确保决策一致性。这种架构虽然可能在效率上有所妥协，但在可靠性方面具有显著优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行动隐含决策&lt;/strong&gt;：每个行动都包含隐含的决策过程，若各智能体的决策冲突，最终结果必然不理想。这一概念揭示了多智能体架构失败的深层原因：即使各子智能体完成了各自的表面任务，如果背后的决策逻辑不一致，合成的结果仍然不可用。理解这一概念有助于开发者在设计智能体系统时更加注重决策过程的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前序决策轨迹&lt;/strong&gt;：这是共享上下文的重要组成部分，指的是所有子智能体必须获得的完整任务背景和历史决策记录。仅仅复制原始任务文本是不够的，因为实际生产系统往往是多轮对话，涉及工具调用和多层细节。前序决策轨迹确保每个后续行动都能充分理解之前的决策过程和原因，从而做出协调一致的决策。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文窗口溢出&lt;/strong&gt;：这是单线程架构面临的主要技术限制。当任务过于复杂时，历史行动和对话可能超出模型的上下文窗口容量。解决方案是引入专门的 LLM 模型，将历史行动和对话压缩为关键细节和决策。这一方法难度较高，但能显著提升智能体处理长上下文的能力，是实现真正可靠的长运行智能体的关键技术。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://cognition.ai/blog/dont-build-multi-agents"&gt;Don&amp;rsquo;t Build Multi-Agents&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Walden Yan&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-06-12&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Claude Code实战与高效工作流</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/claude-code-workflows-three-founders/</link><pubDate>Sun, 17 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/claude-code-workflows-three-founders/</guid><description>&lt;h1 id="claude-code实战与高效工作流"&gt;Claude Code实战与高效工作流&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文总结了三位AI原生创业者在日常开发中高效使用Claude Code的实战经验。内容涵盖Claude Code与Cursor的定位差异、项目核心上下文管理、GitHub自动化集成、Agentic系统与多步推理、上下文工程以及终极提示框架。Claude Code不仅是代码生成工具，更是具备多步推理、自动化协作和复杂项目执行能力的AI智能体。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本文首先阐述了Claude Code与Cursor的核心定位差异。Claude Code本质上是新一代高能AI智能体，擅长多步任务拆解与执行，特别适合启动新项目、制定详细规范和规划文档，并能自动拆解任务逐步执行。而Cursor则更专注于针对具体文件或代码行的精确操作。反思机制是Claude Code的核心优势之一，能够在执行过程中自我纠错和优化方案。&lt;/p&gt;
&lt;p&gt;文章重点介绍了项目上下文管理的关键实践。Claude.md文件作为项目的核心上下文文件，类似为Claude Code量身定制的README，涵盖项目结构、启动流程、文件分布等详细信息。建议为每个子文件夹创建独立的Claude.md文件，细化模块上下文。GitHub集成极为便捷，可自动创建Issue、生成待办清单、执行任务，并支持PR评论自动化审查。通过自定义命令，团队可以复用和共享复杂工作流。&lt;/p&gt;
&lt;p&gt;在Agentic系统方面，Claude Code能作为多步智能体执行复杂推理、自动化代码审查、项目分解与执行。Agent Swarm技术允许同时运行多个Claude实例，分别解决不同子任务，再由LLM或人工评审最佳方案并自动合并到主分支。MCP机制可将多种工具集成到Claude Code，扩展其能力边界。非工程类Agent应用也在逐步普及，如知识管理、自动化文件整理、3D建模等。&lt;/p&gt;
&lt;p&gt;上下文工程是Claude Code高效运行的黄金法则。关键上下文包括代码库结构、架构风格、常用库、UI Mock、风格指南、测试示例、分支命名规范等。建议在每次任务前让Claude Code花时间构建深度上下文，再进入执行环节。Explore-Plan-Execute三步法是终极提示框架：先探索项目结构与需求，再规划任务分解与实现路径，最后执行具体代码编写与测试。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Agentic Loop（智能体循环）&lt;/strong&gt;：持续提供实时反馈与标准，保持Claude Code在多步推理中的自我优化能力。通过反思机制，Claude Code能在执行过程中自动发现并修正自身错误，减少人工干预，提高自动化水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文工程&lt;/strong&gt;：将传统的Prompt工程升级为Context Engineering，强调为AI智能体提供丰富、精准的上下文信息。关键上下文包括代码库结构、架构风格、常用库、UI Mock、风格指南、优秀/糟糕输出示例、自动化测试、分支命名规范等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多智能体协作&lt;/strong&gt;：通过Agent Swarm技术，实现多个Claude实例并行协作，分别解决不同子任务，再由LLM或人工评审最佳方案并自动合并到主分支，大幅提升团队整体生产力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explore-Plan-Execute三步法&lt;/strong&gt;：每次任务都应先探索项目结构与需求，再规划任务分解与实现路径，最后执行具体代码编写与测试。这种系统化的方法可以避免直接进入执行导致的错误与低效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令与工作流复用&lt;/strong&gt;：通过自定义命令和Claude.md文件，将最佳实践沉淀为可共享的Prompt，推动团队知识与能力的持续积累。建议为每个子文件夹创建独立的上下文文件，便于Claude Code高效检索和操作。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=hOqgFNlbrYE"&gt;Master Claude Code: Proven Daily Workflows from 3 Technical Founders&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Patrick Ellis&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025年8月2日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>AI原生软件工程师</title><link>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</guid><description>&lt;h1 id="ai原生软件工程师"&gt;AI原生软件工程师&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文定义了AI原生软件工程师的概念，即将AI深度融入日常开发工作流程、视其为协作伙伴而非威胁的工程师。文章阐述了核心思维转变——从恐惧AI取代转向主动利用AI放大自身能力，提出信任但验证的协作原则，并给出了从工具准备到逐步建立AI熟练度的实践路径，强调工程师仍需对代码质量承担全部责任。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI原生思维&lt;/strong&gt;：将AI内化为思考问题和构建软件的核心方式，对每项任务主动思考AI如何协助完成，而非被动等待&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文工程&lt;/strong&gt;：通过精心构造提示词和上下文信息，引导AI生成高质量输出的技术手段，是高级工程师发挥专业优势的关键能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信任但验证&lt;/strong&gt;：将AI视为知识丰富但经验尚浅的结对编程伙伴，利用其速度和信息量的同时，工程师必须对每一行代码的质量和正确性负最终责任&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程师即管理者&lt;/strong&gt;：AI时代工程师角色从亲力亲为转向协调和监督AI智能体完成任务，通过规则文件和结构化代码塑造人机协作环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进式采用&lt;/strong&gt;：从小处着手逐步建立AI熟练度，先将任务交给AI模型观察表现，再结合编码助手和智能体工具形成完整的AI优先工作流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者：Addy Osmani&lt;/li&gt;
&lt;li&gt;日期：2025年7月2日&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href="https://addyo.substack.com/p/the-ai-native-software-engineer"&gt;The AI-Native Software Engineer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交互式报告：&lt;a href="https://linguage.github.io/articles/ai-native-software-engineer.html"&gt;AI原生软件工程师&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AI原生软件工程师&lt;/em&gt; 是指那些将AI深度融入日常工作流程，视其为伙伴以放大自身能力的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这需要一个根本性的&lt;strong&gt;思维转变&lt;/strong&gt;。AI原生工程师不会想“AI可能会取代我”，而是对每项任务都问自己：“&lt;em&gt;AI能帮助我更快、更好或以不同方式完成这项任务吗？&lt;/em&gt;”。&lt;/p&gt;
&lt;p&gt;这种思维模式是乐观和积极主动的——你将AI视为提高生产力和创造力的倍增器，而非威胁。采用正确的方法，&lt;strong&gt;AI可以将你作为工程师的产出提高2倍、5倍，甚至可能10倍&lt;/strong&gt;。经验丰富的开发者尤其会发现，他们的专业知识使他们能够以产生高水平结果的方式来提示AI；高级工程师可以通过适当的&lt;a href="https://x.com/karpathy/status/1937902205765607626"&gt;上下文工程&lt;/a&gt;，向AI提出正确的问题，从而获得与同行交付结果相当的答案。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!t2_Y!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ae2c5e0-27c6-4959-b37d-67f2c40b2e09_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;成为AI原生意味着拥抱&lt;strong&gt;持续学习和适应&lt;/strong&gt;——工程师从一开始就将基于AI的辅助和自动化融入软件构建中。这种思维模式会带来对可能性的兴奋而非恐惧。&lt;/p&gt;
&lt;p&gt;是的，可能会有不确定性和学习曲线——我们许多人都经历过兴奋、恐惧然后又回到兴奋的情绪过山车——但最终目标是落脚于兴奋和机遇。AI原生工程师将AI视为一种委派开发中重复或耗时部分（如样板代码、文档起草或测试生成）的方式，从而解放自己，专注于更高层次的问题解决和创新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——AI是协作者，而非替代品：&lt;/strong&gt; AI原生工程师将AI视为一个知识渊博但经验尚浅的结对编程伙伴，并且全天候可用。&lt;/p&gt;
&lt;p&gt;你仍然主导开发过程，但会不断利用AI获取想法、解决方案，甚至是警告。例如，你可能会使用AI助手来集思广益架构方案，然后凭借自己的专业知识来完善这些想法。这种协作可以显著加快开发速度，同时提高质量——&lt;em&gt;如果你能保持监督&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;重要的是，你不能将责任完全推给AI。把它想象成与一个阅读过所有StackOverflow帖子和API文档的初级开发者合作：他们拥有大量信息，可以快速生成代码，但&lt;strong&gt;你负责指导他们并验证其输出&lt;/strong&gt;。这种“&lt;a href="https://addyo.substack.com/p/the-trust-but-verify-pattern-for"&gt;信任但验证&lt;/a&gt;”的思维模式至关重要，我们稍后会再次讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!qzj1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4ff8ce3d-bcdc-45ed-933b-c0a1038c63ea_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;坦率地说：AI 生成的劣质内容是真实存在的，这不能成为&lt;a href="https://addyo.substack.com/p/vibe-coding-is-not-an-excuse-for"&gt;低质量工作&lt;/a&gt;的借口。使用这些工具的一个持续风险是草率批准的建议、微妙的幻觉和简单的懒惰相结合，这远远低于专业工程标准。这就是为什么“验证”是这个口号中不可协商的部分。作为工程师，你不仅仅是工具的使用者；你是最终的担保人。你仍然对你提交的每一行代码的质量、可读性、安全性和正确性负有全部直接责任。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!Qzt7!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F61fdf82a-2bcc-4a81-853e-779af54c24a2_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——现在每个工程师都是管理者：&lt;/strong&gt; 工程师的角色正在发生根本性变化。有了AI智能体，你更多地是协调工作，而不是亲力亲为地执行所有工作。&lt;/p&gt;
&lt;p&gt;你仍然对提交到主分支的每一项改动负责，但你更多地关注定义和“分配”要完成的工作。在不远的将来，我们可能会越来越多地说“&lt;a href="https://x.com/levie/status/1938647740554092586"&gt;现在每个工程师都是管理者&lt;/a&gt;”。合法的工作可以指派给Jules或Codex等后台智能体，或者你可以让Claude Code/Gemini CLI/OpenCode处理分析或代码迁移项目。工程师需要有意识地塑造代码库，使其更容易与AI协作，这可以通过使用规则文件（例如GEMINI.md）、良好的READMEs和结构良好的代码来实现。这使得工程师扮演了&lt;a href="https://www.infoworld.com/article/3994519/the-tough-task-of-making-ai-code-production-ready.html"&gt;监督者、导师和验证者&lt;/a&gt;的角色。AI优先的团队规模更小，能完成更多工作，并且能够&lt;a href="https://www.forrester.com/blogs/appgen-is-here-say-goodbye-to-software-development-as-you-know-it/"&gt;缩短SDLC的步骤&lt;/a&gt;，从而更快地交付更高质量的产品。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!wUui!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7cfea4-0f99-4c8d-81bd-d4c81070eee4_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级优势：&lt;/strong&gt; 通过将AI完全融入你的工作流程，你可以实现显著的生产力飞跃，可能更快地发布更多功能，而不会牺牲质量（当然，这需要考虑任务复杂性等细微差别）。&lt;/p&gt;
&lt;p&gt;日常任务（从代码格式化到编写单元测试）可以在几秒钟内完成。也许更重要的是，AI可以增强你的理解：就像有一个随叫随到的专家，可以解释代码或在你专业领域之外的领域提出解决方案。结果是，AI原生工程师可以承担更雄心勃勃的项目，或者以更小的团队处理相同的工作量。从本质上讲，&lt;strong&gt;AI扩展了你的能力&lt;/strong&gt;，让你在更高的抽象层次上工作。但前提是需要有效使用它——这就是正确的思维模式和实践发挥作用的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例——思维模式的实践：&lt;/strong&gt; 想象你正在调试一个棘手的问题或评估一个新的技术栈。传统方法可能涉及大量的Google搜索或阅读文档。而AI原生方法是与支持搜索基础或深度研究的AI助手互动：描述错误或询问技术栈的优缺点，让AI提供见解甚至代码示例。&lt;/p&gt;
&lt;p&gt;你仍然负责解释和实施，但AI会加速信息收集和可能的解决方案。一旦你习惯了，这种协作式问题解决就会成为第二天性。养成习惯，问自己：“&lt;em&gt;AI如何能帮助我完成这项任务？&lt;/em&gt;”直到这成为一种反射。随着时间的推移，你将培养出AI擅长什么以及如何有效提示它的直觉。&lt;/p&gt;
&lt;p&gt;总而言之，&lt;strong&gt;成为AI原生意味着将AI内化为你思考问题和构建软件的核心方式&lt;/strong&gt;。这是一种与机器协作的思维模式：利用它们的优势（速度、知识、模式识别）来补充你自己的优势（创造力、判断力、上下文）。有了这个基础，我们就可以进入将AI融入日常工作的实用步骤。&lt;/p&gt;
&lt;p&gt;如果你对AI原生工作流程完全陌生，一开始可能会感到望而生畏。关键是&lt;strong&gt;从小处着手，逐步建立&lt;/strong&gt;你的AI熟练度。在本节中，我们将提供具体指导，帮助你在日常工程任务中从零开始，高效地使用AI。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!OGxs!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3ef50d3c-e6f1-4b5e-a850-2177e561bbc1_1536x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以上是对我们最终可能在软件生命周期中实现AI的推测性展望。我仍然坚信需要人工参与（工程、设计、产品、用户体验等），以确保质量不会下降。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1：第一个改变是什么？你通常从AI开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI原生工作流程并非偶尔寻找AI可以提供帮助的任务；它通常是首先将任务交给AI模型，看看它的表现如何。&lt;a href="https://www.ignorance.ai/p/ai-at-pulley"&gt;一个团队指出&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;典型的工作流程是首先将任务交给AI模型（通过Cursor或CLI程序）……并理解很多任务仍然是“碰运气”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你是在研究一个领域还是一个竞争对手？从Gemini深度研究开始。发现自己陷入关于某个设计方面的无休止争论？当你的团队争论不休时，你可能已经用AI构建了三个原型来验证这个想法。Google员工已经&lt;a href="https://x.com/rmedranollamas/status/1938305816185966898"&gt;用它来制作幻灯片、调试生产事故等等&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当你听到“但LLM会产生幻觉，聊天机器人给出糟糕的答案”时，是时候更新你的工具链了。今天任何&lt;a href="https://fly.io/blog/youre-all-nuts/"&gt;认真使用AI编码的人都在使用智能体&lt;/a&gt;。幻觉可以通过适当的&lt;a href="https://blog.langchain.com/the-rise-of-context-engineering/"&gt;上下文工程&lt;/a&gt;和智能体反馈循环得到显著缓解和管理。思维转变是基础性的：我们所有人都应该立即成为AI优先的用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤2：准备好正确的AI工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要顺利集成AI，你需要在你的环境中至少设置一个编码助手。许多工程师从VS Code中的&lt;strong&gt;GitHub Copilot&lt;/strong&gt;开始，它具有代码自动完成和代码生成功能。如果你使用VS Code等IDE，可以考虑安装一个AI扩展（例如，&lt;strong&gt;Cursor&lt;/strong&gt;是一个专门的AI增强代码编辑器，而**&lt;a href="https://addyo.substack.com/p/why-i-use-cline-for-ai-engineering"&gt;Cline&lt;/a&gt;&lt;strong&gt;是一个用于AI智能体的VS Code插件——稍后会详细介绍这些）。这些工具非常适合初学者，因为它们在后台运行，为你正在编辑的任何文件实时提供代码建议。在编辑器之外，你还可以在单独的窗口中探索&lt;/strong&gt;ChatGPT、Gemini或Claude**，以获取问答式的帮助。从工具开始很重要，因为它降低了使用AI的摩擦。一旦安装，每当你想到“也许AI可以帮助我完成这项任务”时，AI就近在咫尺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤3：学习提示基础——具体并提供上下文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效使用AI是一项技能，这项技能的核心是**&lt;a href="https://addyo.substack.com/p/the-prompt-engineering-playbook-for"&gt;提示工程&lt;/a&gt;**。新用户常犯的一个错误是给AI一个过于模糊的指令，然后对结果感到失望。记住，AI不是读心术；它对你给出的提示做出反应。多一点上下文或清晰度会大有帮助。例如，如果你有一段代码，想要它的解释或单元测试，不要只说_“为这个写测试。”_ 相反，&lt;strong&gt;在你的提示中描述代码的预期行为和要求&lt;/strong&gt;。比较以下两个为React登录表单组件编写测试的提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;糟糕的提示：&lt;/strong&gt; “你能为我的React组件写测试吗？”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更好的提示：&lt;/strong&gt; “我有一个&lt;code&gt;LoginForm&lt;/code&gt; React组件，包含一个电子邮件字段、密码字段和提交按钮。它在成功提交时显示成功消息，在失败时显示错误消息，通过&lt;code&gt;onSubmit&lt;/code&gt;回调。&lt;strong&gt;请编写一个Jest测试文件&lt;/strong&gt;，该文件：(1) 渲染表单，(2) 填写有效和无效输入，(3) 提交表单，(4) 断言&lt;code&gt;onSubmit&lt;/code&gt;以正确数据被调用，以及 (5) 检查成功和错误状态是否正确渲染。”&lt;/p&gt;</description></item></channel></rss>