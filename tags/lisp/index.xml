<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lisp on Linguista</title><link>https://linguista.cn/tags/lisp/</link><description>Recent content in Lisp on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 22 Feb 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>为什么选择 Clojure</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/why-clojure-economy-of-expression/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/why-clojure-economy-of-expression/</guid><description>&lt;h1 id="为什么选择-clojure"&gt;为什么选择 Clojure&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文作者回顾了自己五十年来使用过的众多编程语言，最终认为 Lisp，尤其是 Clojure，是最简洁、最优雅、最易用的编程语言。作者认为 Clojure 的&amp;quot;表达经济性&amp;quot;远超其他语言，极简的语法让开发者能够用更少的代码、更少的精力，清晰直接地表达问题和解决方案。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇，作者介绍了自己丰富的编程语言经历。在长达五十年的编程生涯中，他曾使用过汇编、Java、Fortran、COBOL、PL/1、C、Pascal、C++、Lua、Smalltalk、Logo 等几十种语言，涵盖静态类型、动态类型、无类型、栈式、逻辑式等多种范式。最初作者并不喜欢 Lisp，认为其语法过于学术化。十年前，通过接触《SICP》并发现 Clojure，作者经历了数年的摸索和挫折，才逐渐体会到 Clojure 的简洁和优雅。&lt;/p&gt;
&lt;p&gt;作者将选择 Clojure 的核心理由概括为&amp;quot;表达经济性&amp;quot;。Clojure 的语法极简，几乎没有任何语法规则，开发者可以用更少的代码表达复杂问题，减少了&amp;quot;语法体操&amp;quot;。通过与 Java 代码的对比，作者展示了 Clojure 的简洁性优势。&lt;/p&gt;
&lt;p&gt;在文章的后半部分，作者回应了关于 Clojure 的常见质疑，包括括号太多、性能问题、与 JavaScript 的兼容性、动态类型问题、IDE 支持、重构能力、与 Java 的互操作性、开发者来源、新语言竞争等。作者认为 Clojure 的极简语法不仅适合小型项目，更适合构建大型系统，开发效率和可维护性远超 Java、C++。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;表达经济性（Economy of Expression）&lt;/strong&gt;：这是作者选择 Clojure 的核心理由。表达经济性意味着用最少的语法和代码表达最复杂的逻辑。Clojure 的极简语法让开发者能够用更少的代码、更少的精力，清晰直接地表达问题和解决方案。作者强调，Clojure 几乎没有语法或语法规则，这大大降低了思维负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极简语法&lt;/strong&gt;：Clojure 的语法极简，几乎可以用几条规则覆盖所有情况。&lt;code&gt;(&lt;/code&gt; 表示开始一个列表，&lt;code&gt;)&lt;/code&gt; 表示结束最近的未闭合列表，名称即函数名，&lt;code&gt;*&lt;/code&gt; 是乘法函数，&lt;code&gt;#&lt;/code&gt; 表示后面的列表是一个匿名函数，&lt;code&gt;%&lt;/code&gt; 表示匿名函数的第一个参数，&lt;code&gt;defn&lt;/code&gt; 用于定义新函数，&lt;code&gt;[]&lt;/code&gt; 表示向量。这些简单的规则已经涵盖了 Clojure 80% 的语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;：作者认为未来属于函数式编程，而 Lisp 天生函数式。Clojure 作为一种 Lisp 方言，继承了这一特性。函数式编程的不可变性、高阶函数等特性，使得代码更加简洁、可维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态类型与测试&lt;/strong&gt;：作者认为动态类型系统配合测试和 &lt;code&gt;clojure/spec&lt;/code&gt; 库，可以实现&amp;quot;设计契约&amp;quot;风格的开发，达到与静态类型系统相同甚至更高的代码质量。类型声明会增加语法复杂度，降低表达经济性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与 Java 生态的互操作性&lt;/strong&gt;：Clojure 运行在 Java 虚拟机上，可以直接调用 Java，Java 也能调用 Clojure，互操作性无障碍。这使得 Clojure 可以充分利用 Java 生态的丰富资源。&lt;/p&gt;</description></item><item><title>创新与数学的永恒价值编程语言的启示</title><link>https://linguista.cn/infos/tldrcards/henrinotes-2025_p2/innovation-math-programming-lisp-eternal-value/</link><pubDate>Tue, 11 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes-2025_p2/innovation-math-programming-lisp-eternal-value/</guid><description>&lt;h1 id="创新与数学的永恒价值编程语言的启示"&gt;创新与数学的永恒价值：编程语言的启示&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以DeepSeek的创新突破为引子，通过保罗·格雷厄姆的经典文章《书呆子的复仇》，深入探讨了编程语言创新的本质。文章指出，尽管编程语言看似不断演进，但其根基——数学，具有永恒的价值。Lisp语言从数学理论演算诞生，至今仍对现代编程语言产生深远影响，揭示了技术创新的深层逻辑。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇以深圳公司DeepSeek的创始人梁文锋的采访切入，指出中国企业在创新领域的突破正在改变全球竞争格局。这一现象引出了一个更深层次的问题：什么才是真正的创新？作者通过编程语言的发展历程来回答这个问题。&lt;/p&gt;
&lt;p&gt;在软件行业中，经理与开发者之间常因技术选择产生冲突。经理们倾向于选择&amp;quot;业界标准&amp;quot;如Java，却忽视了编程语言之间的本质差异。Java语言的诞生本身就是对C++弱点的回应，这证明编程语言并非等价。不同语言的&amp;quot;酷&amp;quot;感反映了其设计哲学和功能特性的差异。&lt;/p&gt;
&lt;p&gt;从历史维度看，现代编程语言如Java、Perl、Python、Ruby都在设计上越来越接近Lisp。Lisp语言自1958年诞生以来，其影响力历久弥新，这与其数学本质密不可分。Lisp最初并非作为编程语言设计，而是基于数学理论演算，其核心&lt;code&gt;eval&lt;/code&gt;函数最初仅用于理论研究。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Lisp语言的数学本质&lt;/strong&gt;：Lisp并非作为实用编程语言诞生，而是源于数学理论演算。这种数学基础使其具有超越时代的永恒性，其设计理念至今仍影响着现代编程语言的发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程语言的演进方向&lt;/strong&gt;：Lisp和Fortran代表了编程语言发展的两大方向。Lisp从数学理论走向实践，Fortran从硬件架构走向高级抽象。现代语言的发展仍在努力接近Lisp的水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创新与追随者的差异&lt;/strong&gt;：真正的创新并非简单地跟随&amp;quot;业界标准&amp;quot;，而是理解技术的本质。DeepSeek以创新者身份参与竞争，正是这种精神的体现。编程语言的历史表明，基于数学本质的创新具有持久价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;酷&amp;quot;感的本质&lt;/strong&gt;：不同编程语言的&amp;quot;酷&amp;quot;感反映了其灵活性和功能特性。Perl比Java&amp;quot;酷&amp;rdquo;，Python和Ruby更先进，这种感知背后是语言设计哲学的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术选择的本质&lt;/strong&gt;：经理们倾向选择&amp;quot;不会出错&amp;quot;的业界标准，但忽视了问题本身的特性。编程语言之间存在本质差异，选择合适的语言需要综合考虑问题的复杂性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mp.weixin.qq.com/s/R4pl0pJCI5MhKxIbaELF4w"&gt;书呆子的复仇：创新和数学一样永不过时&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;保罗·格雷厄姆&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-02-11&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Weird Languages</title><link>https://linguista.cn/person/paul_graham/essays_en/weird/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/weird/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/weird/"&gt;中文版&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/weird.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/weird.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/weird.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="weird-languages"&gt;Weird Languages&lt;/h1&gt;
&lt;p&gt;August 2021&lt;/p&gt;
&lt;p&gt;When people say that in their experience all programming languages are basically equivalent, they&amp;rsquo;re making a statement not about languages but about the kind of programming they&amp;rsquo;ve done.&lt;/p&gt;
&lt;p&gt;99.5% of programming consists of gluing together calls to library functions. All popular languages are equally good at this. So one can easily spend one&amp;rsquo;s whole career operating in the intersection of popular programming languages.&lt;/p&gt;</description></item><item><title>怪异语言</title><link>https://linguista.cn/person/paul_graham/essays_zh/weird/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/weird/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/weird/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/weird.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/weird.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/weird.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="怪异语言"&gt;怪异语言&lt;/h1&gt;
&lt;p&gt;2021年8月&lt;/p&gt;
&lt;p&gt;当人们说根据他们的经验所有编程语言基本上等价时，他们做出的不是关于语言的陈述，而是关于他们做过的编程类型的陈述。&lt;/p&gt;
&lt;p&gt;99.5%的编程包括将库函数调用粘合在一起。所有流行的语言在这方面都同样好。所以一个人可以很容易地花费整个职业生涯在流行编程语言的交集中操作。&lt;/p&gt;
&lt;p&gt;但另外0.5%的编程不成比例地有趣。如果你想了解它由什么组成，怪异语言的怪异性是一个很好的线索。&lt;/p&gt;
&lt;p&gt;怪异语言不是偶然怪异的。至少好的不是。好的怪异语言的怪异性通常暗示着存在某种不仅仅是通常的库函数调用的粘合的编程形式。&lt;/p&gt;
&lt;p&gt;一个具体的例子：Lisp宏。Lisp宏即使对许多Lisp程序员来说也显得怪异。它们不仅不在流行语言的交集中，而且它们的性质使得在语言中正确实现它们而不将其变成Lisp的方言会很困难。宏绝对证明超越了粘合编程的技术。例如，通过首先为该类型的问题编写一种语言，然后在其中编写你的特定应用程序来解决问题。这不是你用宏能做的全部；它只是程序操作技术空间中的一个区域，即使现在还远未被完全探索。&lt;/p&gt;
&lt;p&gt;所以如果你想扩展你对编程可能性的概念，一种方法是学习怪异语言。选择一种大多数程序员认为怪异但其中位数用户聪明的语言，然后专注于这种语言与流行语言交集之间的差异。你能用这种语言说什么，而在其他语言中说会极其不便？在学习如何说你以前不能说的话的过程中，你可能会学习如何想你以前不能想的事。&lt;/p&gt;
&lt;p&gt;感谢Trevor Blackwell、Patrick Collison、Daniel Gackle、Amjad Masad和Robert Morris阅读草稿。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://paulgraham.com/weird.ja.html"&gt;日语翻译&lt;/a&gt;&lt;/p&gt;</description></item><item><title>What I Worked On</title><link>https://linguista.cn/person/paul_graham/essays_en/worked/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/worked/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/worked/"&gt;中文版&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/worked.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/worked.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/worked.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="what-i-worked-on"&gt;What I Worked On&lt;/h1&gt;
&lt;p&gt;February 2021&lt;/p&gt;
&lt;p&gt;Before college the two main things I worked on, outside of school, were writing and programming. I didn&amp;rsquo;t write essays. I wrote what beginning writers were supposed to write then, and probably still are: short stories. My stories were awful. They had hardly any plot, just characters with strong feelings, which I imagined made them deep.&lt;/p&gt;</description></item><item><title>我所从事的工作</title><link>https://linguista.cn/person/paul_graham/essays_zh/worked/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/worked/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/worked/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/worked.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/worked.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/worked.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="我所从事的工作"&gt;我所从事的工作&lt;/h1&gt;
&lt;p&gt;2021年2月&lt;/p&gt;
&lt;p&gt;大学前，我在课外主要从事的两件事是写作和编程。我不写文章。我写的是当时初学写作的人应该写的东西，可能现在还是：短篇小说。我的故事很糟糕。几乎没有情节，只有感情强烈的角色，我以为这让他们显得深刻。&lt;/p&gt;
&lt;p&gt;我尝试编写的第一个程序是在我们学区用于当时称为&amp;quot;数据处理&amp;quot;的IBM 1401上。那时我在九年级，所以是13或14岁。学区的1401恰好在我们的初中的地下室，我的朋友Rich Draves和我获得了使用它的许可。那里就像一个小型的邦德反派巢穴，所有这些看起来外星般的机器——CPU、磁盘驱动器、打印机、卡片阅读器——坐在明亮的荧光灯下的抬高地板上。&lt;/p&gt;
&lt;p&gt;我们使用的语言是Fortran的早期版本。你必须在打孔卡上键入程序，然后将它们堆叠在卡片阅读器中并按下按钮将程序加载到内存中并运行。结果通常是在极其响亮的打印机上打印一些东西。&lt;/p&gt;
&lt;p&gt;我对1401感到困惑。我无法弄清楚如何使用它。回想起来，我能用它做的事情不多。程序的唯一输入形式是存储在打孔卡上的数据，而我没有任何存储在打孔卡上的数据。唯一的选择是做不依赖任何输入的事情，比如计算π的近似值，但我的数学知识不足以做任何有趣的这类事情。所以我不奇怪我不记得我编写的任何程序，因为它们不可能做太多事情。我最清晰的记忆是我了解到程序可能不会终止的那一刻，当我的一个程序没有终止时。在没有分时系统的机器上，这既是社会错误也是技术错误，正如数据中心经理的表情所表明的那样。&lt;/p&gt;
&lt;p&gt;有了微型计算机，一切都改变了。现在你可以有一台电脑就坐在你面前，在桌子上，它可以在运行时响应你的按键，而不仅仅是处理一堆打孔卡然后停止。[1]&lt;/p&gt;
&lt;p&gt;我的朋友中第一个拥有微型计算机的人是自己组装的。它是由Heathkit作为套件出售的。我生动地记得看着它坐在它前面，直接在电脑中键入程序时我感到多么印象深刻和羡慕。&lt;/p&gt;
&lt;p&gt;那时候计算机很昂贵，我纠缠了多年才说服我父亲在1980年左右买了一台TRS-80。当时黄金标准是Apple II，但TRS-80已经足够好了。这是我真正开始编程的时候。我编写了简单的游戏，一个预测我的模型火箭能飞多高的程序，以及我的父亲用来写至少一本书的文字处理器。内存中只有大约2页文本的空间，所以他一次写2页然后打印出来，但这比打字机好多了。&lt;/p&gt;
&lt;p&gt;虽然我喜欢编程，但我没打算在大学里学习它。在大学里我要学习哲学，这听起来强大得多。对于我天真的高中自我来说，这似乎是对终极真理的研究，相比之下其他领域研究的东西将只是领域知识。当我到达大学时，我发现其他领域占据了思想空间的很大部分，这些所谓的终极真理没有太多空间留下来。哲学似乎只剩下其他领域的人认为可以安全忽略的边缘情况。&lt;/p&gt;
&lt;p&gt;我18岁时无法把这些变成语言。我当时只知道我不断选修哲学课程，而它们总是很无聊。所以我决定转向AI。&lt;/p&gt;
&lt;p&gt;AI在1980年代中期很流行，但有两件事特别让我想要从事它：海因莱因的一部名为《月亮是一个严厉的女人》的小说，其中有一个名为Mike的智能计算机，以及一个展示Terry Winograd使用SHRDLU的PBS纪录片。我没有尝试重读《月亮是一个严厉的女人》，所以我不知道它老化得如何，但当我读它时，我完全被它的世界吸引住了。似乎只是时间问题，我们就会有Mike，当我看到Winograd使用SHRDLU时，似乎那时间将是几年。你所要做的就是教SHRDLU更多的词语。&lt;/p&gt;
&lt;p&gt;那时康奈尔大学没有任何AI课程，甚至研究生课程也没有，所以我开始尝试自学。这意味着学习Lisp，因为在那些日子Lisp被认为是AI的语言。当时常用的编程语言相当原始，程序员的想法也相应地如此。康奈尔的默认语言是一种类似Pascal的语言，称为PL/I，其他地方的情况也类似。学习Lisp如此迅速地扩展了我对程序的概念，以至于我花了几年时间才开始感觉到新的限制在哪里。这更像它；这是我对大学期望的。它没有像应该的那样在课堂上发生，但没关系。接下来的几年我很顺利。我知道我要做什么。&lt;/p&gt;
&lt;p&gt;对于我的本科论文，我逆向工程了SHRDLU。天啊，我多么喜欢在这个程序上工作。这是一段令人愉悦的代码，但更令人兴奋的是我的信念——现在很难想象，但在1985年并不独特——它已经在攀登智能的较低坡度。&lt;/p&gt;
&lt;p&gt;我进入了康奈尔的一个不要求你选择专业的项目。你可以选修任何你喜欢的课程，选择任何你喜欢放在学位上的东西。我当然选择了&amp;quot;人工智能&amp;quot;。当我拿到实际的物理文凭时，我惊恐地发现引号被包括在内，这使它们读作引号。当时这困扰着我，但现在看来可笑地准确，原因我即将发现。&lt;/p&gt;
&lt;p&gt;我申请了3所研究生院：MIT和耶鲁，当时以AI闻名，以及哈佛，我访问过因为Rich Draves去那里，也是Bill Woods的故乡，他发明了我在我的SHRDLU克隆中使用的解析器类型。只有哈佛接受了我，所以我就去了那里。&lt;/p&gt;
&lt;p&gt;我不记得那一刻是什么时候发生的，或者甚至是否有特定的时刻，但在研究生第一年期间，我意识到AI，当时实践的方式，是一个骗局。我的意思是那种AI，其中被告知&amp;quot;狗坐在椅子上&amp;quot;的程序将其转换为某种正式表示并将其添加到它知道的事情列表中。&lt;/p&gt;
&lt;p&gt;这些程序真正显示的是，自然语言的一个子集是一种形式语言。但是一个非常适当的子集。很明显，他们能做的事情和真正理解自然语言之间有一个不可逾越的鸿沟。事实上，这不仅仅是教SHRDLU更多词语的问题。整个AI方式，用代表概念的显式数据结构，是行不通的。它的 brokenness 确实，像经常发生的那样，产生了大量机会来写关于可以应用的各种创可贴的论文，但它永远不会给我们带来Mike。&lt;/p&gt;
&lt;p&gt;所以我环顾四周，看看我能从计划的残骸中挽救什么，那就是Lisp。我从经验中知道Lisp本身就很有趣，不仅仅是因为它与AI的联系，尽管那时这是人们关心它的主要原因。所以我决定专注于Lisp。事实上，我决定写一本关于Lisp黑客技术的书。想到我开始写那本书时对Lisp黑客技术了解得多么少，真是令人害怕。但是没有什么比写一本关于某件事的书更能帮助你学习它了。这本书，《On Lisp》，直到1993年才出版，但我在研究生院写了大部分。&lt;/p&gt;
&lt;p&gt;计算机科学是两个部分之间不安的联盟：理论和系统。理论家证明事情，系统家建造事情。我想建造事情。我对理论有很大的尊重——确实，一种偷偷摸摸的怀疑，认为它是两个部分中更令人钦佩的——但建造事情似乎令人兴奋得多。&lt;/p&gt;
&lt;p&gt;然而，系统工作的问题在于它不持久。你今天编写的任何程序，无论多好，最多几十年后就会过时。人们可能在脚注中提到你的软件，但没有人会实际使用它。而且，它会显得非常无力的工作。只有对领域历史有了解的人才会意识到，在它的时代，它曾经是好的。&lt;/p&gt;
&lt;p&gt;有一次，计算机实验室里有一些多余的施乐Dandelions。任何想要一个来玩的人都可以有一个。我短暂地被诱惑了，但按照现在的标准它们太慢了；有什么意义呢？也没有其他人想要一个，所以它们被运走了。这就是系统工作的下场。&lt;/p&gt;
&lt;p&gt;我不仅要建造事情，还要建造会持久的事情。&lt;/p&gt;
&lt;p&gt;在这种不满的状态下，我在1988年去CMU拜访Rich Draves，他在那里读研究生。有一天我去参观卡内基研究所，我小时候在那里花了很多时间。在那里看一幅画时，我意识到一些可能看起来显而易见的事情，但对我来说是一个巨大的惊喜。在那里，就在墙上，是一些你可以制造的东西，它会持久。绘画不会过时。一些最好的已经有几百年历史了。&lt;/p&gt;
&lt;p&gt;而且这是你可以谋生的事情。当然不像写软件那么容易，但我认为如果你真正勤奋且生活非常节俭，必须有可能赚足够的钱生存。作为艺术家，你可以真正独立。你不会有老板，甚至不需要获得研究经费。&lt;/p&gt;
&lt;p&gt;我一直喜欢看画。我能画画吗？我不知道。我从未想象过这是可能的。我在理智上知道人们制造艺术——它不是自发出现的——但制造它的人似乎是不同的物种。他们要么生活在很久以前，要么是在《生活》杂志的简介中做奇怪事情的神秘天才。实际上能够制造艺术，把这个动词放在这个名词前面，似乎几乎是奇迹性的。&lt;/p&gt;
&lt;p&gt;那年秋天我开始在哈佛选修艺术课程。研究生可以在任何系选修课程，我的导师Tom Cheatham非常随和。即使他知道我选修的奇怪课程，他也什么都没说。&lt;/p&gt;
&lt;p&gt;所以现在我在计算机科学博士项目中，却计划成为艺术家，却又真正热爱Lisp黑客技术和努力编写《On Lisp》。换句话说，像许多研究生一样，我精力充沛地从事多个不是我的论文的项目。&lt;/p&gt;
&lt;p&gt;我没有看到摆脱这种局面的方法。我不想退学，但我还能怎么出去呢？我记得当我的朋友Robert Morris因编写1988年互联网蠕虫而被康奈尔开除时，我羡慕他找到了如此壮观的方式来离开研究生院。&lt;/p&gt;
&lt;p&gt;然后在1990年4月的一天，墙上出现了一道裂缝。我遇到了Cheatham教授，他问我是否已经足够进展可以在那年六月毕业。我的论文一个字都没有写，但一定是我一生中最快的思考，我决定在剩下的5周左右的时间内尝试写一篇，尽可能重用《On Lisp》的部分，我能够毫无察觉地延迟回答&amp;quot;是的，我想是的。我几天内给你一些东西阅读。&amp;quot;&lt;/p&gt;
&lt;p&gt;我选择了continuations的应用作为主题。回想起来我应该写关于宏和嵌入式语言。那里有一个几乎未被探索的整个世界。但我只想离开研究生院，我快速写的论文足够了，勉强而已。&lt;/p&gt;
&lt;p&gt;与此同时，我在申请艺术学院。我申请了两所：美国的RISD，和佛罗伦萨的Accademia di Belli Arti，因为它是最古老的艺术学校，我想象它会很好。RISD接受了我，而我从未收到Accademia的回音，所以我去了普罗维登斯。&lt;/p&gt;</description></item><item><title>If Lisp is So Great</title><link>https://linguista.cn/person/paul_graham/essays_en/iflisp/</link><pubDate>Thu, 01 May 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/iflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/iflisp/"&gt;Chinese Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/iflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/iflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/iflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="if-lisp-is-so-great"&gt;If Lisp is So Great&lt;/h1&gt;
&lt;p&gt;May 2003&lt;/p&gt;
&lt;p&gt;If Lisp is so great, why don&amp;rsquo;t more people use it? I was asked this question by a student in the audience at a talk I gave recently. Not for the first time, either.&lt;/p&gt;
&lt;p&gt;In languages, as in so many things, there&amp;rsquo;s not much correlation between popularity and quality. Why does John Grisham (King of Torts sales rank, 44) outsell Jane Austen (Pride and Prejudice sales rank, 6191)? Would even Grisham claim that it&amp;rsquo;s because he&amp;rsquo;s a better writer?&lt;/p&gt;</description></item><item><title>如果Lisp这么好</title><link>https://linguista.cn/person/paul_graham/essays_zh/iflisp/</link><pubDate>Thu, 01 May 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/iflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/iflisp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/iflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/iflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/iflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="如果lisp这么好"&gt;如果Lisp这么好&lt;/h1&gt;
&lt;p&gt;2003年5月&lt;/p&gt;
&lt;p&gt;如果Lisp这么好，为什么没有更多人使用它？我最近在一次演讲中被听众中的一个学生问到了这个问题。而且不是第一次了。&lt;/p&gt;
&lt;p&gt;在语言方面，就像在许多事情中一样，流行度和质量之间没有太大关联。为什么约翰·格里沙姆（《诉讼之王》销售排名第44）比简·奥斯汀（《傲慢与偏见》销售排名第6191）卖得更好？即使是格里沙姆会声称这是因为他是更好的作家吗？&lt;/p&gt;
&lt;p&gt;这是《傲慢与偏见》的第一句话：&amp;ldquo;凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;举世公认的真理？&amp;rdquo; 对于一个爱情故事的第一句话来说，这些词太长了。&lt;/p&gt;
&lt;p&gt;就像简·奥斯汀的作品一样，Lisp看起来很难。它的语法，或者说缺乏语法，使它看起来完全不同于大多数人习惯的语言。在学习Lisp之前，我也害怕它。我最近发现了一本1983年的笔记本，我在上面写道：&amp;ldquo;我想我应该学习Lisp，但它看起来太陌生了。&amp;ldquo;幸运的是，我当时19岁，对学习新东西没有太多抵触。我非常无知，学习几乎任何东西都意味着学习新事物。&lt;/p&gt;
&lt;p&gt;被Lisp吓到的人们编造了其他不使用它的理由。当C是默认语言时，标准的借口是Lisp太慢。现在Lisp方言是可用语言中较快的之一，这个借口已经消失了。现在的标准借口是公开循环的：其他语言更流行。&lt;/p&gt;
&lt;p&gt;（小心这种推理。它会让你得到Windows。）&lt;/p&gt;
&lt;p&gt;流行度总是自我延续的，但在编程语言中尤其如此。为流行语言编写的库更多，这使它们更流行。程序经常必须与现有程序一起工作，如果它们用相同的语言编写，这会更容易，所以语言像病毒一样从程序传播到程序。管理者更喜欢流行的语言，因为它们给他们更多对开发者的控制力，开发者可以更容易被替换。&lt;/p&gt;
&lt;p&gt;确实，如果编程语言都或多或少等价，那么使用除最流行语言之外的任何语言都没有什么理由。但它们并不都等价，差远了。这就是为什么不那么流行的语言，像简·奥斯汀的小说，继续存在的原因。当其他人在阅读最新的约翰·格里沙姆小说时，总会有一小部分人在阅读简·奥斯汀。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;日语翻译 | 罗马尼亚语翻译 | 西班牙语翻译&lt;/em&gt;&lt;/p&gt;</description></item><item><title>The Hundred-Year Language</title><link>https://linguista.cn/person/paul_graham/essays_en/hundred/</link><pubDate>Tue, 01 Apr 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/hundred/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/hundred/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hundred.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hundred.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hundred.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="the-hundred-year-language"&gt;The Hundred-Year Language&lt;/h1&gt;
&lt;p&gt;April 2003&lt;/p&gt;
&lt;p&gt;(This essay is derived from a keynote talk at PyCon 2003.)&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s hard to predict what life will be like in a hundred years. There are only a few things we can say with certainty. We know that everyone will drive flying cars, that zoning laws will be relaxed to allow buildings hundreds of stories tall, that it will be dark most of the time, and that women will all be trained in the martial arts. Here I want to zoom in on one detail of this picture. What kind of programming language will they use to write the software controlling those flying cars?&lt;/p&gt;</description></item><item><title>百年编程语言</title><link>https://linguista.cn/person/paul_graham/essays_zh/hundred/</link><pubDate>Tue, 01 Apr 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/hundred/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/hundred/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hundred.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hundred.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hundred.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="百年编程语言"&gt;百年编程语言&lt;/h1&gt;
&lt;p&gt;2003年4月&lt;/p&gt;
&lt;p&gt;（本文源于在PyCon 2003的主题演讲。）&lt;/p&gt;
&lt;p&gt;很难预测一百年后的生活会是什么样子。我们只能确定几件事。我们知道每个人都会驾驶飞行汽车，区划法律将会放宽以允许建造数百层高的建筑，大部分时间都会是黑暗的，女性都会接受武术训练。在这里，我想聚焦于这个图景中的一个细节。他们会用什么样的编程语言来编写控制那些飞行汽车的软件？&lt;/p&gt;
&lt;p&gt;思考这个问题之所以有价值，并不是因为我们真的能用到这些语言，而是因为，如果我们幸运的话，我们会使用从现在到那个时间点的路径上的语言。&lt;/p&gt;
&lt;p&gt;我认为，像物种一样，语言会形成进化树，到处都有死胡同分支。我们已经看到这种情况正在发生。Cobol尽管曾经流行，但似乎没有任何知识后代。它是一个进化死胡同——尼安德特人式的语言。&lt;/p&gt;
&lt;p&gt;我预测Java也会有类似的命运。人们有时给我写信说，&amp;ldquo;你怎么能说Java不会成为一种成功的语言？它已经是成功的语言了。&amp;ldquo;我承认它是，如果你用关于它的书籍所占用的书架空间（特别是关于它的单本书籍），或者相信必须学习它才能找到工作的本科生数量来衡量成功的话。当我说Java不会成为成功的语言时，我的意思更具体：Java将是一个进化死胡同，就像Cobol一样。&lt;/p&gt;
&lt;p&gt;这只是一个猜测。我可能是错的。我在这里的重点不是批评Java，而是提出进化树的问题，让人们思考，语言X在树的哪个位置？问这个问题的原因不仅仅是为了让我们的鬼魂在一百年后说我告诉过你这样。这是因为靠近主要分支是寻找现在适合编程的语言的有用启发式方法。&lt;/p&gt;
&lt;p&gt;在任何给定的时间，你可能最幸福地处于进化树的主要分支上。即使仍然有很多尼安德特人，成为其中的一员也一定很糟糕。克罗马农人会不断过来殴打你并偷走你的食物。&lt;/p&gt;
&lt;p&gt;我想知道一百年后语言会是什么样子，这样我就知道现在应该赌树的哪个分支。&lt;/p&gt;
&lt;p&gt;语言的进化与物种的进化不同，因为分支可以融合。例如，Fortran分支似乎正在与Algol的后代融合。理论上这对物种也是可能的，但不太可能发生在比细胞更大的生物上。&lt;/p&gt;
&lt;p&gt;语言更有可能融合，部分是因为可能性空间较小，部分是因为突变不是随机的。语言设计师有意地融合其他语言的思想。&lt;/p&gt;
&lt;p&gt;对于语言设计师来说，思考编程语言的进化可能导致的方向特别有用，因为他们可以相应地引导。在这种情况下，&amp;ldquo;停留在主分支上&amp;quot;不仅仅是选择好语言的方法。它成为做出正确语言设计决策的启发式方法。&lt;/p&gt;
&lt;p&gt;任何编程语言都可以分为两部分：一组扮演公理角色的基本运算符，以及语言的其余部分，原则上可以用这些基本运算符来编写。&lt;/p&gt;
&lt;p&gt;我认为基本运算符是语言长期生存的最重要因素。其余的你可以改变。这就像买房子的规则，你首先应该考虑位置。其他的一切你都可以稍后修复，但你不能修复位置。&lt;/p&gt;
&lt;p&gt;我认为不仅公理要选择得好，而且数量要少。数学家一直对公理有这样的感觉——越少越好——我认为他们抓住了要点。&lt;/p&gt;
&lt;p&gt;至少，仔细审视语言的核心，看看是否有任何可以剔除的公理，这必须是一个有用的练习。我在我作为一个邋遢人的漫长职业生涯中发现，冗余会产生冗余，我看到这种情况不仅发生在软件中，也发生在床下和房间角落。&lt;/p&gt;
&lt;p&gt;我有一种预感，进化树的主要分支通过那些具有最小、最干净核心的语言。你能在语言本身中编写的语言部分越多越好。&lt;/p&gt;
&lt;p&gt;当然，即使问一百年后编程语言会是什么样子，我也做出了一个很大的假设。一百年后我们还会编写程序吗？我们不会只是告诉计算机我们想要它们做什么吗？&lt;/p&gt;
&lt;p&gt;到目前为止，那个部门没有太多进展。我猜测一百年后人们仍会使用我们能识别的程序来告诉计算机做什么。可能有些我们现在通过编写程序来解决的问题，一百年后你不必编写程序来解决，但我认为仍会有大量我们今天所做的那种编程。&lt;/p&gt;
&lt;p&gt;认为任何人都能预测任何技术在一百年后会是什么样子可能显得 presumptuous。但请记住，我们背后已经有将近五十年的历史。当我们考虑到语言在过去五十年中进化得多么缓慢时，展望一百年是一个可以把握的想法。&lt;/p&gt;
&lt;p&gt;语言进化缓慢是因为它们并不是真正的技术。语言是符号。程序是你希望计算机为你解决问题的形式化描述。所以编程语言的进化速度更像数学符号的进化速度，而不是交通或通信的进化速度。数学符号确实在进化，但没有你在技术中看到的巨大飞跃。&lt;/p&gt;
&lt;p&gt;无论一百年后计算机由什么制成，似乎可以安全地预测它们会比现在快得多。如果摩尔定律继续发挥作用，它们将快74 quintillion（73,786,976,294,838,206,464）倍。这很难想象。事实上，速度部门最可能的预测可能是摩尔定律将停止工作。任何应该每十八个月翻一番的东西似乎最终都会遇到某种基本限制。但我毫不怀疑计算机会快得多。即使它们最终只快一百倍，这也应该大大改变编程语言的基本规则。除此之外，还会有更多空间给现在被认为是慢的语言，即那些不能产生非常高效代码的语言。&lt;/p&gt;
&lt;p&gt;然而，有些应用仍然需要速度。我们想用计算机解决的有些问题是计算机创造的；例如，你必须处理视频图像的速度取决于另一台计算机生成它们的速度。还有另一类问题本身就具有无限吸收计算周期的能力：图像渲染、密码学、模拟。&lt;/p&gt;
&lt;p&gt;如果一些应用可以变得越来越低效，而其他应用继续要求硬件能够提供的所有速度，更快的计算机将意味着语言必须覆盖更广泛的效率范围。我们已经看到这种情况正在发生。按照过去几十年的标准，一些流行新语言的当前实现惊人地浪费。&lt;/p&gt;
&lt;p&gt;这不仅仅是编程语言发生的事情。这是一个普遍的历史趋势。随着技术的改进，每一代人都能做前一代人认为是浪费的事情。三十年前的人会对我们如此随意地打长途电话感到惊讶。一百年前的人会更惊讶有一天一个包裹会通过孟菲斯从波士顿旅行到纽约。&lt;/p&gt;
&lt;p&gt;我已经可以告诉你未来一百年更快的硬件将给我们的所有额外周期会发生什么。它们几乎都会被浪费掉。&lt;/p&gt;
&lt;p&gt;我学习编程时计算机能力很稀缺。我记得取出我Basic程序中的所有空格，使它们能适合4K TRS-80的内存。想到所有这些惊人低效的软件一遍又一遍地烧掉周期做同样的事情，我觉得有点恶心。但我认为我的直觉在这里是错的。我就像一个长大的穷人，即使是为了重要的事情也不能忍受花钱，比如去看医生。&lt;/p&gt;
&lt;p&gt;有些浪费确实是令人厌恶的。例如，SUVs即使运行在永远不会耗尽且不产生污染的燃料上，也可能是令人厌恶的。SUVs之所以令人厌恶，是因为它们是一个令人厌恶的问题的解决方案。（如何使小型货车看起来更阳刚。）但并非所有浪费都是坏的。现在我们有了支持它的基础设施，计算你的长途通话分钟数开始显得吝啬。如果你有资源，更优雅的思考方式是把所有电话通话视为一类事情，无论对方在哪里。&lt;/p&gt;
&lt;p&gt;有好浪费，也有坏浪费。我对好浪费感兴趣——那种通过花费更多，我们可以获得更简单设计的浪费。我们将如何利用新、更快的硬件给我们带来的浪费周期的机会？&lt;/p&gt;
&lt;p&gt;对速度的渴望在我们这些拥有可怜计算机的人心中根深蒂固，以至于需要 conscious 努力来克服它。在语言设计中，我们应该有意识地寻找可以用效率换取哪怕是最小的便利增加的情况。&lt;/p&gt;
&lt;p&gt;大多数数据结构的存在是因为速度。例如，今天的许多语言既有字符串也有列表。在语义上，字符串或多或少是列表的一个子集，其中元素是字符。那么为什么你需要单独的数据类型呢？你真的不需要。字符串的存在仅仅是为了效率。但是用使程序运行得更快的hack来使语言的语义变得混乱是很蹩脚的。在语言中拥有字符串似乎是一个过早优化的例子。&lt;/p&gt;
&lt;p&gt;如果我们将语言的核心视为一组公理，那么仅仅为了效率而增加不增加表达能力的额外公理肯定是令人厌恶的。效率很重要，但我认为这不是获得它的正确方法。&lt;/p&gt;
&lt;p&gt;我认为解决这个问题的正确方法是将程序的含义与实现细节分开。不要同时拥有列表和字符串，只拥有列表，同时有某种方式给编译器优化建议，使其能够在必要时将字符串布置为连续的字节。&lt;/p&gt;
&lt;p&gt;由于速度在程序的大部分中都不重要，你通常不需要费心处理这种微观管理。随着计算机变得越来越快，这一点会越来越真实。&lt;/p&gt;
&lt;p&gt;少说实现细节也应该使程序更灵活。规范在程序编写过程中会改变，这不仅是不可避免的，而且是可取的。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;essay&amp;quot;这个词来自法语动词&amp;quot;essayer&amp;rdquo;，意思是&amp;quot;尝试&amp;rdquo;。essay在原始意义上是你写来试图弄清楚某些东西的东西。这在软件中也会发生。我认为一些最好的程序是essay，从这个意义上说，作者们在开始时并不知道他们确切地想要写什么。&lt;/p&gt;
&lt;p&gt;Lisp黑客们已经知道灵活使用数据结构的价值。我们倾向于编写程序的第一版本，使其用列表做所有事情。这些初始版本可能如此惊人地低效，以至于需要conscious努力不去思考它们在做什么，就像，至少对我而言，吃牛排需要conscious努力不去思考它来自哪里。&lt;/p&gt;
&lt;p&gt;一百年后的程序员最寻找的，最重要的是一种语言，你可以用最少的努力组合成一个令人难以置信的低效版本1程序。至少，这是我们现在会描述的方式。他们会说他们想要一种易于编程的语言。&lt;/p&gt;
&lt;p&gt;低效的软件并不令人厌恶。令人厌恶的是让程序员做不必要工作的语言。浪费程序员时间是真正的低效，而不是浪费机器时间。随着计算机变得越来越快，这一点会变得越来越清晰。&lt;/p&gt;</description></item><item><title>Design and Research</title><link>https://linguista.cn/person/paul_graham/essays_en/desres/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/desres/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/desres/"&gt;Chinese Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/desres.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/desres.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/desres.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="design-and-research"&gt;Design and Research&lt;/h1&gt;
&lt;p&gt;January 2003&lt;/p&gt;
&lt;p&gt;(This article is derived from a keynote talk at the fall 2002 meeting of NEPLS.)&lt;/p&gt;
&lt;p&gt;Visitors to this country are often surprised to find that Americans like to begin a conversation by asking &amp;ldquo;what do you do?&amp;rdquo; I&amp;rsquo;ve never liked this question. I&amp;rsquo;ve rarely had a neat answer to it. But I think I have finally solved the problem. Now, when someone asks me what I do, I look them straight in the eye and say &amp;ldquo;I&amp;rsquo;m designing a new dialect of Lisp.&amp;rdquo; I recommend this answer to anyone who doesn&amp;rsquo;t like being asked what they do. The conversation will turn immediately to other topics.&lt;/p&gt;</description></item><item><title>设计与研究</title><link>https://linguista.cn/person/paul_graham/essays_zh/desres/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/desres/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/desres/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/desres.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/desres.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/desres.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="设计与研究"&gt;设计与研究&lt;/h1&gt;
&lt;p&gt;2003年1月&lt;/p&gt;
&lt;p&gt;（本文源自2002年秋季NEPLS会议的主题演讲。）&lt;/p&gt;
&lt;p&gt;访问这个国家的人常常惊讶地发现，美国人喜欢以询问&amp;quot;你是做什么的？&amp;ldquo;来开始对话。我从来不喜欢这个问题。我很少有一个简洁的答案。但我想我终于解决了这个问题。现在，当有人问我做什么时，我会直视他们的眼睛说&amp;quot;我正在设计一种新的Lisp方言。&amp;ldquo;我推荐这个答案给任何不喜欢被问及做什么的人。对话会立即转向其他话题。&lt;/p&gt;
&lt;p&gt;我不认为自己在研究编程语言。我只是在设计一种，就像有人可能设计一座建筑、一把椅子或一种新字体一样。我不是在试图发现什么新东西。我只是想创造一种编程起来很舒服的语言。在某些方面，这个假设让生活轻松很多。&lt;/p&gt;
&lt;p&gt;设计和研究之间的区别似乎是一个新与好的问题。设计不一定要新，但一定要好。研究不一定要好，但一定要新。我认为这两条路在顶端汇合：最好的设计通过使用新思想超越其前人，而最好的研究解决的不仅是新的问题，而且是真正值得解决的问题。所以最终我们的目标是相同的目的地，只是从不同的方向接近。&lt;/p&gt;
&lt;p&gt;今天我要谈论的是从背面看你的目标是什么样子的。当你把编程语言视为设计问题而非研究课题时，你会做什么不同的事情？&lt;/p&gt;
&lt;p&gt;最大的区别是你更关注用户。设计始于问，这是为谁而做的，他们从中需要什么？例如，一个好的建筑师不是先创建一个设计然后强加给用户，而是通过研究预期用户并找出他们需要什么来开始。&lt;/p&gt;
&lt;p&gt;注意我说的是&amp;quot;他们需要的&amp;rdquo;，而不是&amp;quot;他们想要的&amp;rdquo;。我并不是说作为一名设计师工作意味着像快餐厨师一样工作，做客户告诉你的任何事情。这在艺术领域的各个领域都有所不同，但我不认为有任何领域是由那些完全按照客户要求做事的人做出最好的作品的。&lt;/p&gt;
&lt;p&gt;在衡量好设计的标准是它对用户有多好用这一点上，顾客永远是对的。如果你写了一本让所有人都感到无聊的小说，或者一把坐着极不舒服的椅子，那么你的工作就很糟糕，就是这样。说小说或椅子是根据最先进的理论原理设计的，这并不是辩解。&lt;/p&gt;
&lt;p&gt;然而，做出对用户有用的东西并不意味着简单地做用户告诉你做的事情。用户不知道所有的选择是什么，而且常常对他们真正想要的东西感到困惑。&lt;/p&gt;
&lt;p&gt;这个悖论的答案，我认为是你必须为用户设计，但必须设计用户需要的东西，而不是仅仅设计他们说他们想要的东西。这很像做医生。你不能仅仅治疗病人的症状。当病人告诉你他们的症状时，你必须找出真正的问题所在，并治疗那个。&lt;/p&gt;
&lt;p&gt;这种对用户的关注是一种公理，大多数好的设计实践都可以从中推导出来，大多数设计问题都围绕着它。&lt;/p&gt;
&lt;p&gt;如果好的设计必须满足用户的需求，那么用户是谁？当我说设计必须为用户时，我并不是说好的设计旨在某种最低标准。你可以选择任何你想要的用户群体。例如，如果你在设计一个工具，你可以为从初学者到专家的任何人设计，而针对一个群体的好设计对另一个群体可能是坏的设计。关键是，你必须选择某个用户群体。我认为除非参考某个预期用户，否则你甚至无法谈论好或坏的设计。&lt;/p&gt;
&lt;p&gt;如果预期用户包括设计师自己，你最有可能获得好的设计。当你为不包括你自己的群体设计东西时，它往往是为那些你认为比你不够复杂的人设计的，而不是更复杂的。&lt;/p&gt;
&lt;p&gt;这是一个问题，因为无论多么仁慈，居高临下地看待用户似乎不可避免地会腐蚀设计师。我怀疑美国很少有住房项目是由期望住在那里的建筑师设计的。你可以在编程语言中看到同样的现象。C、Lisp和Smalltalk是为它们自己的设计师使用而创建的。Cobol、Ada和Java是为其他人使用而创建的。&lt;/p&gt;
&lt;p&gt;如果你认为你在为白痴设计东西，那么很可能你设计的东西不够好，即使是对白痴来说。即使你为最复杂的用户设计东西，你仍然在为人类设计。在研究方面情况不同。在数学中，你选择抽象不是因为它们容易理解，而是因为它们能让证明更短。我认为这对科学大体上也是如此。科学思想并不是为了符合人体工程学。&lt;/p&gt;
&lt;p&gt;在艺术领域，情况非常不同。设计完全是关于人的。人体是个奇怪的东西，但当你设计一把椅子时，那就是你设计的对象，没有办法回避。所有艺术都必须迎合人类的兴趣和局限性。例如，在绘画中，在其他条件相同的情况下，有人的画比没有人的画更有趣。文艺复兴时期的伟大画作都充满了人，这不仅仅是历史的偶然。如果不是这样，绘画作为媒介就不会拥有它所拥有的声望。&lt;/p&gt;
&lt;p&gt;不管喜欢与否，编程语言也是为人类服务的，我怀疑人脑就像人体一样凹凸不平且特异。有些思想人们很容易掌握，有些则不然。例如，我们处理细节的能力似乎非常有限。正是这个事实使得编程语言一开始就是个好主意；如果我们能处理细节，我们可以直接用机器语言编程。&lt;/p&gt;
&lt;p&gt;还要记住，语言主要不是完成程序的形式，而是程序必须在其中开发的东西。任何艺术领域的人都会告诉你，你可能需要不同的媒介来处理这两种情况。例如，大理石是完成思想的漂亮、耐用的媒介，但对于开发新思想来说，它却是一种无可救药的僵化媒介。&lt;/p&gt;
&lt;p&gt;程序就像证明一样，是一棵树的修剪版本，这棵树过去到处都有错误的分支。所以语言的测试不仅仅是完成的程序在它里面看起来有多干净，而是到达完成程序的路径有多干净。一个能给你优雅完成程序的设计选择可能不会给你一个优雅的设计过程。例如，我写过几个定义宏的宏，充满了嵌套的反引号，现在看起来像小宝石，但写它们花费了数小时最丑陋的试错，而且坦率地说，我仍然不完全确定它们是正确的。&lt;/p&gt;
&lt;p&gt;我们常常表现得好像语言的测试是完成的程序在它里面看起来有多好。当你看到同一个程序用两种语言编写，一个版本短得多时，这似乎很有说服力。当你从艺术的角度接近这个问题时，你不太可能依赖这种测试。你不想最终得到一个像大理石一样的编程语言。&lt;/p&gt;
&lt;p&gt;例如，在软件开发中拥有一个交互式顶层（在Lisp中称为读取-求值-打印循环）是一个巨大的胜利。当你有一个这样的东西时，它对语言的设计有实际影响。它对于一个必须在使用前声明变量的语言来说效果不佳，例如。当你只是在顶层输入表达式时，你希望能够将x设置为某个值，然后开始对x做事情。你不想必须先声明x的类型。你可以对任何一个前提提出异议，但如果一个语言必须有顶层才能方便，而强制类型声明与顶层不兼容，那么任何强制类型声明的语言都不可能方便编程。&lt;/p&gt;
&lt;p&gt;在实践中，要获得好的设计，你必须接近并保持接近你的用户。你必须不断在实际用户上校准你的想法，尤其是在开始时。简·奥斯汀的小说如此之好的原因之一是她把它们大声读给家人听。这就是为什么她从不沉溺于自我放纵的风景描述或矫饰的哲学思考。（哲学在那里，但它被编织进故事中，而不是像标签一样粘贴在上面。）如果你打开一本普通的&amp;quot;文学&amp;quot;小说，想象把它作为你写的东西大声读给朋友听，你会敏锐地感觉到那种东西对读者来说是多么令人难以忍受。&lt;/p&gt;
&lt;p&gt;在软件世界，这个想法被称为&amp;quot;较差就是更好&amp;quot;。实际上，&amp;ldquo;较差就是更好&amp;quot;的概念中混合了几个想法，这就是为什么人们仍在争论较差是否真的更好。但这个混合中的主要思想之一是，如果你在构建新东西，你应该尽快将原型放到用户面前。&lt;/p&gt;
&lt;p&gt;另一种方法可能叫做&amp;quot;万福玛丽亚策略&amp;rdquo;。你不是快速拿出原型并逐步改进它，而是试图在一次长传触地中创建完整、完成的产品。据我所知，这是灾难的根源。无数创业公司在互联网泡沫期间这样自我毁灭。我从未听说过有成功的案例。&lt;/p&gt;
&lt;p&gt;软件世界之外的人可能没有意识到的是，&amp;ldquo;较差就是更好&amp;quot;的思想在整个艺术领域都有体现。例如，在绘画中，这个思想在文艺复兴时期被发现。现在几乎每个绘画老师都会告诉你，获得准确绘画的正确方法不是慢慢地围绕物体的轮廓工作，因为错误会累积，最后你会发现线条不相遇。相反，你应该在大致正确的地方画几条快速的线，然后逐渐完善这个初始草图。&lt;/p&gt;
&lt;p&gt;在大多数领域，传统上原型是用不同材料制作的。要切割成金属的字体最初是用刷子在纸上设计的。要铸成青铜的雕像是用蜡建模的。要在挂毯上刺绣的图案是用墨水在纸上绘制的。要用石头建造的建筑是在较小规模的木材上测试的。&lt;/p&gt;
&lt;p&gt;当油画在十五世纪首次流行时令人兴奋的原因是，你实际上可以从原型制作完成的作品。如果你愿意，可以做一个初步的绘图，但你不必受它约束；你可以在完成绘画时解决所有细节，甚至做重大改变。&lt;/p&gt;
&lt;p&gt;在软件中你也可以这样做。原型不一定只是一个模型；你可以将其精制成成品。我认为你应该在可能的时候总是这样做。它能让你利用一路上获得的新见解。但也许更重要的是，它对士气有好处。&lt;/p&gt;
&lt;p&gt;士气在设计中至关重要。我很惊讶人们不多谈论它。我的第一个绘画老师告诉我：当你画某样东西感到无聊时，画出来的东西看起来会很无聊。例如，假设你必须画一栋建筑，你决定单独画每一块砖。如果你愿意，你可以这样做，但如果你中途感到无聊并开始机械地画砖而不是观察每一块，那么画出来的效果会比仅仅暗示砖块要差。&lt;/p&gt;
&lt;p&gt;通过逐步完善原型来建造东西对士气有好处，因为它能让你保持投入。在软件中，我的规则是：始终有可工作的代码。如果你正在写一小时内可以测试的东西，那么你有立即获得奖励的前景来激励你。在艺术领域也是如此，特别是在油画中。大多数画家从模糊的草图开始，然后逐步完善。如果你这样工作，那么原则上你永远不必在一天结束时留下看起来确实未完成的东西。确实，画家之间甚至有句谚语：&amp;ldquo;一幅画永远不会完成，你只是停止在上面工作。&amp;ldquo;这个想法对任何做过软件的人来说都很熟悉。&lt;/p&gt;
&lt;p&gt;士气是难以设计给不够复杂用户的另一个原因。很难对自己不喜欢的东西保持兴趣。要做出好东西，你必须想&amp;quot;哇，这真的很棒&amp;rdquo;，而不是&amp;quot;这是什么垃圾；那些傻瓜会喜欢它&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;设计意味着为人类制造东西。但不仅仅是用户是人。设计师也是人。&lt;/p&gt;
&lt;p&gt;注意这段时间我一直在谈论&amp;quot;设计师&amp;rdquo;。设计通常必须由单个人控制才能做好。然而，似乎几个人可以合作进行一个研究项目。这在我看来是研究和设计之间最有趣的区别之一。&lt;/p&gt;
&lt;p&gt;艺术领域有著名合作的例子，但它们大多数似乎是分子结合而不是核融合的情况。在歌剧中，通常由一个人写剧本，另一个人写音乐。在文艺复兴时期，来自北欧的工匠经常被雇佣来做意大利绘画背景中的风景。但这些不是真正的合作。它们更像是罗伯特·弗罗斯特&amp;quot;好篱笆造就好邻居&amp;quot;的例子。你可以把好的设计实例粘在一起，但在每个单独的项目中，一个人必须处于控制地位。&lt;/p&gt;
&lt;p&gt;我不是说好的设计要求一个人思考所有事情。没有什么比一个你信任其判断的人的建议更有价值了。但谈话结束后，关于做什么的决定必须由一个人来做。&lt;/p&gt;
&lt;p&gt;为什么研究可以由合作者完成而设计不能？这是一个有趣的问题。我不知道答案。也许，如果设计和研究汇合，最好的研究也是好的设计，而且实际上不能由合作者完成。许多最著名的科学家似乎都是独自工作的。但我了解得不够多，无法说这里是否有模式。这可能仅仅是因为许多著名科学家工作时合作不那么普遍。&lt;/p&gt;
&lt;p&gt;无论科学领域的情况如何，真正的合作在艺术领域似乎极为罕见。委员会设计是坏设计的同义词。为什么会这样？有什么方法可以克服这个限制吗？&lt;/p&gt;
&lt;p&gt;我倾向于认为没有——好的设计需要一个独裁者。一个原因是好的设计必须是一体的。设计不仅是为人类，而是为单个的人。如果一个设计代表的思想适合一个人的头脑，那么这个思想也会适合用户的头脑。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.aoky.net/articles/paul_graham/design_and_research_japanese.htm"&gt;日语翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linguista.cn/person/paul_graham/essays_zh/taste/"&gt;制造者的品味&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.kent.ac.uk/people/staff/srk21/research/papers/graham/design_and_research_romanian.pdf"&gt;罗马尼亚语翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.barrahome.org/blog/articulos/diseno_e_investigacion"&gt;西班牙语翻译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Revenge of the Nerds</title><link>https://linguista.cn/person/paul_graham/essays_en/icad/</link><pubDate>Wed, 01 May 2002 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/icad/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/icad/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/icad.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/icad.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/icad.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="revenge-of-the-nerds"&gt;Revenge of the Nerds&lt;/h1&gt;
&lt;p&gt;Want to start a startup? Get funded by Y Combinator.&lt;/p&gt;
&lt;p&gt;May 2002&lt;/p&gt;
&lt;p&gt;&amp;ldquo;We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp.&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guy Steele, co-author of the Java spec&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the software business there is an ongoing struggle between the pointy-headed academics, and another equally formidable force, the pointy-haired bosses. Everyone knows who the pointy-haired boss is, right? I think most people in the technology world not only recognize this cartoon character, but know the actual person in their company that he is modelled upon.&lt;/p&gt;</description></item><item><title>书呆子的复仇</title><link>https://linguista.cn/person/paul_graham/essays_zh/icad/</link><pubDate>Wed, 01 May 2002 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/icad/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/icad/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/icad.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/icad.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/icad.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="书呆子的复仇"&gt;书呆子的复仇&lt;/h1&gt;
&lt;p&gt;想要创业？获得Y Combinator的投资。&lt;/p&gt;
&lt;p&gt;2002年5月&lt;/p&gt;
&lt;p&gt;&amp;ldquo;我们当时在追逐C++程序员。我们成功地将他们中的许多人拖到了Lisp的路上。&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guy Steele，Java规范合著者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件行业中，一直存在着一场持续的斗争，一方是尖脑袋的学者，另一方是同样强大的力量——尖头发的老板。大家都知道尖头发的老板是谁，对吧？我认为技术界的大多数人不仅认识这个卡通人物，而且知道他们公司中这个人物的原型是谁。&lt;/p&gt;
&lt;p&gt;尖头发的老板奇迹般地结合了两个各自常见但很少同时出现的品质：(a)他对技术一无所知，(b)他对技术有非常强烈的看法。&lt;/p&gt;
&lt;p&gt;假设，例如，你需要编写一个软件。尖头发的老板对这个软件应该如何工作一无所知，也无法区分一种编程语言和另一种，但他知道你应该用什么语言来编写它。完全正确。他认为你应该用Java来编写。&lt;/p&gt;
&lt;p&gt;他为什么这么认为？让我们来看看尖头发的老板的大脑里面在想什么。他在想的大概是这样的。Java是一个标准。我知道它一定是标准，因为我总是在媒体上看到它。既然它是标准，我使用它就不会惹上麻烦。这也意味着总会有很多Java程序员，所以如果现在为我工作的程序员辞职了——为我工作的程序员总是神秘地辞职——我可以很容易地替换他们。&lt;/p&gt;
&lt;p&gt;嗯，这听起来并不那么不合理。但这一切都基于一个未言明的假设，而这个假设结果是错误的。尖头发的老板认为所有编程语言都差不多是等价的。如果这是真的，那他完全正确。如果所有语言都等价，当然，使用其他人都在使用的语言。&lt;/p&gt;
&lt;p&gt;但并非所有语言都是等价的，我想我甚至不需要深入它们之间的差异就能向你证明这一点。如果你在1992年问尖头发的老板软件应该用什么语言编写，他会像今天一样毫不犹豫地回答。软件应该用C++编写。但如果所有语言都等价，为什么尖头发的老板的意见会改变？事实上，Java的开发者为什么要费心创建一种新语言？&lt;/p&gt;
&lt;p&gt;据推测，如果你创建一种新语言，那是因为你认为它在某些方面比人们已有的语言更好。事实上，Gosling在第一份Java白皮书中明确表示，Java被设计用来解决C++的一些问题。所以事情就是这样：语言并不都是等价的。如果你顺着尖头发的老板的大脑思路追踪到Java，然后再回溯Java的历史到它的起源，你最终会得到一个与你开始时的假设相矛盾的想法。&lt;/p&gt;
&lt;p&gt;那么，谁是对的？James Gosling，还是尖头发的老板？毫不奇怪，Gosling是对的。某些语言对于某些问题来说比其他语言更好。你知道，这引发了一些有趣的问题。Java被设计为在特定问题上比C++更好。什么问题？什么时候Java更好，什么时候C++更好？是否存在某些情况下其他语言比两者都更好？&lt;/p&gt;
&lt;p&gt;一旦你开始考虑这个问题，你就打开了一个真正的潘多拉盒子。如果尖头发的老板不得不以全部复杂性来思考这个问题，他的大脑会爆炸。只要他认为所有语言都等价，他所要做的就是选择一个似乎最有势头的语言，既然这更多是时尚问题而不是技术问题，即使他也可能得到正确的答案。但如果语言各不相同，他突然必须同时解两个方程，试图在他一无所知的两件事之间找到最佳平衡：解决他需要解决的问题的二十种左右主要语言的相对适用性，以及为每种语言找到程序员、库等的可能性。如果门后是这样的东西，尖头发的老板不想打开它也就不足为奇了。&lt;/p&gt;
&lt;p&gt;认为所有编程语言都等价的缺点是这不是真的。但优点是它让你的生活简单得多。我认为这是这个想法如此广泛传播的主要原因。这是一个令人舒适的想法。&lt;/p&gt;
&lt;p&gt;我们知道Java一定相当不错，因为它是酷的、新的编程语言。或者真是如此吗？如果你从远处看编程语言的世界，看起来Java是最新的事物。（从足够远的地方看，你只能看到Sun支付的大型闪烁广告牌。）但如果你近距离观察这个世界，你会发现酷的程度是不同的。在黑客亚文化中，有一种叫做Perl的语言被认为比Java酷得多。例如，Slashdot就是用Perl生成的。我想你不会发现那些家伙使用Java Server Pages。但还有另一种更新的语言叫做Python，它的用户倾向于看不起Perl，还有更多的语言在等待。&lt;/p&gt;
&lt;p&gt;如果你按顺序看这些语言，Java、Perl、Python，你会注意到一个有趣的模式。至少，如果你是Lisp黑客，你会注意到这种模式。每一种都比前一种更像Lisp。Python甚至复制了许多Lisp黑客认为是错误的特性。你可以将简单的Lisp程序逐行翻译成Python。现在是2002年，编程语言几乎赶上了1958年。&lt;/p&gt;
&lt;h2 id="追上数学"&gt;追上数学&lt;/h2&gt;
&lt;p&gt;我的意思是，Lisp是John McCarthy在1958年首次发现的，而流行的编程语言现在才赶上他当时发展的想法。&lt;/p&gt;
&lt;p&gt;现在，这怎么可能是真的？计算机技术不是变化很快的东西吗？我的意思是，在1958年，计算机是冰箱大小的庞然大物，处理能力相当于手表。怎么可能有那么古老的技术仍然相关，更不用说比最新的发展更优越？&lt;/p&gt;
&lt;p&gt;我来告诉你原因。这是因为Lisp并不是真正被设计为一种编程语言，至少不是我们今天意义上的编程语言。我们所说的编程语言是我们用来告诉计算机做什么的东西。McCarthy最终确实打算发展这种意义上的编程语言，但我们实际得到的Lisp是基于他作为理论练习所做的另一件事——努力定义一个比图灵机更方便的替代方案。正如McCarthy后来所说，&lt;/p&gt;
&lt;p&gt;展示Lisp比图灵机更整洁的另一种方法是编写一个通用的Lisp函数，并证明它比通用图灵机的描述更简洁、更易理解。这就是Lisp函数eval&amp;hellip;&amp;hellip;它计算Lisp表达式的值&amp;hellip;&amp;hellip;编写eval需要发明一种表示Lisp函数作为Lisp数据的符号，这种符号是为了论文的目的而设计的，并没有想到它会用来实际表达Lisp程序。&lt;/p&gt;
&lt;p&gt;接下来发生的事情是，在1958年末的某个时候，Steve Russell，McCarthy的一个研究生，看着这个eval的定义，意识到如果将它翻译成机器语言，结果将是一个Lisp解释器。&lt;/p&gt;
&lt;p&gt;这在当时是一个很大的惊喜。以下是McCarthy后来在采访中对此的评论：&lt;/p&gt;
&lt;p&gt;Steve Russell说，看，为什么我不来编程这个eval&amp;hellip;&amp;hellip;，我对他说，呵，呵，你把理论和实践混淆了，这个eval是为了阅读，不是为了计算的。但他还是继续做了。也就是说，他把我论文中的eval编译成[IBM] 704机器码，修复了一些错误，然后将其宣传为Lisp解释器，它确实是。在那时，Lisp基本上就有了今天的形式。&lt;/p&gt;
&lt;p&gt;所以，我想在几周内，McCarthy发现他的理论练习转变为实际的编程语言——而且是一种比他预期更强大的语言。&lt;/p&gt;
&lt;p&gt;所以，这个1950年代的语言没有过时的简短解释是它不是技术而是数学，而数学不会过时。将Lisp比较的正确对象不是1950年代的硬件，而是，比如说，快速排序算法，它发现于1960年，至今仍然是最快的通用排序算法。&lt;/p&gt;
&lt;p&gt;1950年代还有另一种语言幸存下来，Fortran，它代表了语言设计的相反方法。Lisp是一段意想不到地转变为编程语言的理论。Fortran是故意被开发为一种编程语言的，但我们现在认为是一种非常低级的语言。&lt;/p&gt;
&lt;p&gt;1956年开发的Fortran I语言与现在的Fortran是完全不同的动物。Fortran I基本上是带有数学的汇编语言。在某些方面它比最近的汇编语言功能更弱；例如，没有子程序，只有分支。现在的Fortran可以说更接近Lisp而不是Fortran I。&lt;/p&gt;
&lt;p&gt;Lisp和Fortran是两个独立进化树的树干，一个根植于数学，一个根植于机器架构。这两棵树从那时起一直在收敛。Lisp开始时很强大，在接下来的二十年里变得快速。所谓的主流语言开始时很快，在接下来的四十年里逐渐变得更强大，直到现在它们中最先进的相当接近Lisp。接近，但仍然缺少一些东西。&lt;/p&gt;
&lt;h2 id="使lisp不同的东西"&gt;使Lisp不同的东西&lt;/h2&gt;
&lt;p&gt;当Lisp首次被开发时，它体现了九个新想法。其中一些我们现在认为是理所当然的，其他只在更先进的语言中看到，有两个仍然是Lisp独有的。这九个想法按主流采用的顺序排列，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件语句&lt;/strong&gt;。条件语句是if-then-else结构。我们现在认为这是理所当然的，但Fortran I没有它们。它只有基于底层机器指令的条件goto。&lt;/p&gt;</description></item><item><title>Lisp的不同之处</title><link>https://linguista.cn/person/paul_graham/essays_zh/diff/</link><pubDate>Sat, 01 Dec 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/diff/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/diff/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/diff.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/diff.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/diff.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的不同之处"&gt;Lisp的不同之处&lt;/h1&gt;
&lt;p&gt;2001年12月（修订于2002年5月）&lt;/p&gt;
&lt;p&gt;（本文是回应LL1邮件列表上一些问题而产生的。现在已收录在《书呆子的复仇》中。）&lt;/p&gt;
&lt;p&gt;当McCarthy在1950年代末设计Lisp时，它是对现有语言的彻底突破，其中最重要的是Fortran。&lt;/p&gt;
&lt;p&gt;Lisp体现了九个新思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件语句。&lt;/strong&gt; 条件语句是if-then-else结构。现在我们认为这是理所当然的。它们是McCarthy在开发Lisp过程中发明的。（当时的Fortran只有条件goto，紧密基于底层硬件的分支指令。）McCarthy是Algol委员会的成员，他将条件语句引入Algol，随后传播到大多数其他语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数类型。&lt;/strong&gt; 在Lisp中，函数是一等对象——它们是一种数据类型，就像整数、字符串等，并且有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归。&lt;/strong&gt; 递归当然在Lisp之前作为数学概念存在，但Lisp是第一个支持递归的编程语言。（可以说这在使函数成为一等对象中是隐含的。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量的新概念。&lt;/strong&gt; 在Lisp中，所有变量实际上都是指针。具有类型的是值，而不是变量，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;由表达式组成的程序。&lt;/strong&gt; Lisp程序是表达式的树，每个表达式都返回一个值。（在某些Lisp中，表达式可以返回多个值。）这与Fortran和大多数后续语言形成对比，后者区分表达式和语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Fortran中有这种区别是很自然的，因为（在输入格式为打孔卡的语言中不足为奇）该语言是面向行的。你不能嵌套语句。因此，虽然你需要表达式来进行数学运算，但让其他任何东西返回值都没有意义，因为不可能有任何东西在等待它。&lt;/p&gt;
&lt;p&gt;随着块结构语言的出现，这个限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们的后代。&lt;/p&gt;
&lt;p&gt;当一种语言完全由表达式构成时，你可以任意组合表达式。你可以说（使用Arc语法）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(if foo (= x 1) (= x 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(= x (if foo 1 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="7"&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;符号类型。&lt;/strong&gt; 符号与字符串的不同在于你可以通过比较指针来测试相等性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用符号树表示代码的记号。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;整个语言始终可用。&lt;/strong&gt; 读取时间、编译时间和运行时间之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp用作扩展语言的基础，如在Emacs等程序中；在运行时读取使程序能够使用s表达式进行通信，这个想法最近被重新发明为XML。&lt;/p&gt;
&lt;p&gt;当Lisp首次发明时，所有这些想法都与当时的普通编程实践相去甚远，后者主要由1950年代末可用的硬件决定。&lt;/p&gt;
&lt;p&gt;随着时间的推移，体现在一系列流行语言中的默认语言逐渐向Lisp演变。1-5现在已经广泛传播。6开始出现在主流中。Python具有7的一种形式，尽管似乎没有任何语法支持它。8（与9一起）是使Lisp宏成为可能的特性，到目前为止仍然是Lisp独有的，也许是因为（a）它需要那些括号，或者同样糟糕的东西，（b）如果你添加这最后的力量增量，你不能再声称发明了一种新语言，而只是设计了一种新的Lisp方言 ;-)&lt;/p&gt;
&lt;p&gt;虽然对当今的程序员有用，但通过描述Lisp与其他语言采用的随机权宜之计的差异来描述它是很奇怪的。这可能不是McCarthy对它的看法。Lisp不是设计来修复Fortran中的错误；它更像是试图将计算公理化的副产品。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;</description></item><item><title>What Made Lisp Different</title><link>https://linguista.cn/person/paul_graham/essays_en/diff/</link><pubDate>Sat, 01 Dec 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/diff/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/diff/"&gt;Chinese Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/diff.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/diff.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/diff.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="what-made-lisp-different"&gt;What Made Lisp Different&lt;/h1&gt;
&lt;p&gt;December 2001 (rev. May 2002)&lt;/p&gt;
&lt;p&gt;(This article came about in response to some questions on the LL1 mailing list. It is now incorporated in Revenge of the Nerds.)&lt;/p&gt;
&lt;p&gt;When McCarthy designed Lisp in the late 1950s, it was a radical departure from existing languages, the most important of which was Fortran.&lt;/p&gt;</description></item><item><title>Why Arc Isn't Especially Object-Oriented</title><link>https://linguista.cn/person/paul_graham/essays_en/noop/</link><pubDate>Mon, 01 Oct 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/noop/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/noop/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/noop.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/noop.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/noop.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="why-arc-isnt-especially-object-oriented"&gt;Why Arc Isn&amp;rsquo;t Especially Object-Oriented&lt;/h1&gt;
&lt;p&gt;There is a kind of mania for object-oriented programming at the moment, but some of the smartest programmers I know are some of the least excited about it.&lt;/p&gt;
&lt;p&gt;My own feeling is that object-oriented programming is a useful technique in some cases, but it isn&amp;rsquo;t something that has to pervade every program you write. You should be able to define new types, but you shouldn&amp;rsquo;t have to express every program as the definition of new types.&lt;/p&gt;</description></item><item><title>为什么 Arc 不是特别面向对象的</title><link>https://linguista.cn/person/paul_graham/essays_zh/noop/</link><pubDate>Mon, 01 Oct 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/noop/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/noop/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/noop.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/noop.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/noop.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="为什么-arc-不是特别面向对象的"&gt;为什么 Arc 不是特别面向对象的&lt;/h1&gt;
&lt;p&gt;目前有一种对面向对象编程的狂热，但我认识的一些最聪明的程序员是对此最不兴奋的人。&lt;/p&gt;
&lt;p&gt;我自己的感觉是，面向对象编程在某些情况下是一种有用的技术，但它不是必须渗透到你写的每个程序中的东西。你应该能够定义新类型，但不必将每个程序都表达为新类型的定义。&lt;/p&gt;
&lt;p&gt;我认为人们喜欢面向对象编程有五个原因，其中三个半是坏的：&lt;/p&gt;
&lt;p&gt;如果你有一个静态类型的语言，没有词法闭包或宏，面向对象编程是令人兴奋的。在某种程度上，它提供了一种绕过这些限制的方法。（见 Greenspun 第十规则。）&lt;/p&gt;
&lt;p&gt;面向对象编程在大公司很受欢迎，因为它适合他们编写软件的方式。在大公司，软件往往由大量（且经常变动的）平庸程序员团队编写。面向对象编程对这些程序员施加了一种纪律，防止任何一个人造成太大的损害。代价是产生的代码充满了协议和重复。这对大公司来说不是太高的价格，因为他们的软件无论如何都可能是臃肿和充满重复的。&lt;/p&gt;
&lt;p&gt;面向对象编程产生了很多看起来像工作的东西。在折叠纸的时代，有一种程序员只会在一页上放五到十行代码，前面是二十行精心格式化的注释。面向对象编程对这些来说就像可卡因：它让你将所有这些脚手架直接整合到源代码中。Lisp 黑客可能通过将符号推到列表上来处理的东西，变成了整个类的文件和方法。所以如果你想说服自己或其他人你正在做很多工作，这是一个好工具。&lt;/p&gt;
&lt;p&gt;如果语言本身是一个面向对象的程序，它可以被用户扩展。嗯，也许。或者也许你可以通过提供面向对象编程的子概念单点来做得更好。例如，重载本质上并不与类绑定。我们拭目以待。&lt;/p&gt;
&lt;p&gt;面向对象的抽象很好地映射到某些特定类型程序的领域，比如模拟和 CAD 系统。&lt;/p&gt;
&lt;p&gt;我个人从来不需要面向对象的抽象。Common Lisp 有一个极其强大的对象系统，我从未使用过一次。我做过很多事情（例如，制作充满闭包的哈希表），这些在较弱的语言中需要面向对象技术，但我从未不得不使用 CLOS。&lt;/p&gt;
&lt;p&gt;也许我只是很愚蠢，或者只在应用程序的有限子集上工作过。基于自己的编程经验设计语言是有危险的。但放入你从未需要的东西因为它被认为是个好主意似乎更危险。&lt;/p&gt;</description></item><item><title>Being Popular</title><link>https://linguista.cn/person/paul_graham/essays_en/popular/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/popular/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/popular/"&gt;Chinese Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/popular.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/popular.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/popular.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="being-popular"&gt;Being Popular&lt;/h1&gt;
&lt;p&gt;May 2001&lt;/p&gt;
&lt;p&gt;(This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language: very powerful abstractions.)&lt;/p&gt;
&lt;p&gt;A friend of mine once told an eminent operating systems expert that he wanted to design a really good programming language. The expert told him that it would be a waste of time, that programming languages don&amp;rsquo;t become popular or unpopular based on their merits, and so no matter how good his language was, no one would use it. At least, that was what had happened to the language he had designed.&lt;/p&gt;</description></item><item><title>Five Questions about Language Design</title><link>https://linguista.cn/person/paul_graham/essays_en/langdes/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/langdes/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/langdes/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/langdes.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/langdes.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/langdes.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="five-questions-about-language-design"&gt;Five Questions about Language Design&lt;/h1&gt;
&lt;p&gt;May 2001&lt;/p&gt;
&lt;p&gt;(These are some notes I made for a panel discussion on programming language design at MIT on May 10, 2001.)&lt;/p&gt;
&lt;h2 id="1-programming-languages-are-for-people"&gt;1. Programming Languages Are for People.&lt;/h2&gt;
&lt;p&gt;Programming languages are how people talk to computers. The computer would be just as happy speaking any language that was unambiguous. The reason we have high level languages is because people can&amp;rsquo;t deal with machine language. The point of programming languages is to prevent our poor frail human brains from being overwhelmed by a mass of detail.&lt;/p&gt;</description></item><item><title>Lisp的根源</title><link>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/rootsoflisp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/rootsoflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/rootsoflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/rootsoflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的根源"&gt;Lisp的根源&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（我写这篇文章是为了帮助自己准确理解McCarthy的发现。你不需要知道这些东西来用Lisp编程，但对于想要理解Lisp本质的人来说——无论是从起源还是语义核心的角度——这应该是有帮助的。Lisp拥有这样一个核心是其区别于其他语言的特征之一，也是为什么与其他语言不同，Lisp有方言的原因。）&lt;/p&gt;
&lt;p&gt;1960年，John McCarthy发表了一篇非凡的论文，他在编程领域做了类似于欧几里得对几何学所做的事情。他展示了，给定一些简单的操作符和函数表示法，如何构建一个完整的编程语言。他称这种语言为Lisp，即&amp;quot;列表处理&amp;quot;，因为他的一个关键想法是使用一种称为列表的简单数据结构来同时表示代码和数据。&lt;/p&gt;
&lt;p&gt;值得理解McCarthy的发现，不仅作为计算机史上的里程碑，而且作为我们时代编程发展方向的模型。在我看来，迄今为止有两个真正干净、一致的编程模型：C模型和Lisp模型。这两个模型似乎像是高地，之间是沼泽般的低地。随着计算机变得越来越强大，正在开发的新语言一直在稳步向Lisp模型移动。过去20年来，新编程语言的一个流行配方是采用C计算模型，然后零散地添加从Lisp模型中提取的部分，如运行时类型和垃圾收集。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将尝试用最简单的术语解释McCarthy的发现。重点不仅仅是了解某人40年前想出的一个有趣的理论结果，而是展示语言的发展方向。Lisp的不寻常之处——事实上，Lisp的定义性特征——是它可以用自身来编写。要理解McCarthy的意思，我们将追溯他的步骤，将他的数学表示法转换为运行的Common Lisp代码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注意：这似乎是一篇较长文章的介绍或摘要。全文可能作为PostScript文件提供，在原始来源中链接为&amp;quot;Complete Article (Postscript)&amp;quot;。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What Made Lisp Different&lt;/li&gt;
&lt;li&gt;The Code&lt;/li&gt;
&lt;li&gt;中文翻译&lt;/li&gt;
&lt;li&gt;日语翻译&lt;/li&gt;
&lt;li&gt;葡萄牙语翻译&lt;/li&gt;
&lt;li&gt;韩语翻译&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>The Roots of Lisp</title><link>https://linguista.cn/person/paul_graham/essays_en/rootsoflisp/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/rootsoflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/rootsoflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/rootsoflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/rootsoflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="the-roots-of-lisp"&gt;The Roots of Lisp&lt;/h1&gt;
&lt;p&gt;May 2001&lt;/p&gt;
&lt;p&gt;(I wrote this article to help myself understand exactly what McCarthy discovered. You don&amp;rsquo;t need to know this stuff to program in Lisp, but it should be helpful to anyone who wants to understand the essence of Lisp — both in the sense of its origins and its semantic core. The fact that it has such a core is one of Lisp&amp;rsquo;s distinguishing features, and the reason why, unlike other languages, Lisp has dialects.)&lt;/p&gt;</description></item><item><title>关于语言设计的五个问题</title><link>https://linguista.cn/person/paul_graham/essays_zh/langdes/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/langdes/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/langdes/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/langdes.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/langdes.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/langdes.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="关于语言设计的五个问题"&gt;关于语言设计的五个问题&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;
&lt;h2 id="1-编程语言是为人设计的"&gt;1. 编程语言是为人设计的。&lt;/h2&gt;
&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;
&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;
&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;
&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;
&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;
&lt;h2 id="2-为自己和你的朋友设计"&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;
&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;
&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;
&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;
&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;
&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;
&lt;h2 id="3-给程序员尽可能多的控制权"&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;
&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;
&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;
&lt;h2 id="4-追求简洁"&gt;4. 追求简洁。&lt;/h2&gt;
&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;
&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;
&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;
&lt;h2 id="5-承认黑客的本质"&gt;5. 承认黑客的本质。&lt;/h2&gt;
&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;
&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;
&lt;h2 id="开放性问题"&gt;开放性问题&lt;/h2&gt;
&lt;h3 id="1-如何组织大型库"&gt;1. 如何组织大型库？&lt;/h3&gt;
&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;
&lt;h3 id="2-人们真的害怕前缀语法吗"&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;
&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;
&lt;h3 id="3-基于服务器的软件需要什么"&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;
&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;
&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;
&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;
&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;
&lt;h3 id="4-还有什么新的抽象有待发现"&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;
&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;</description></item><item><title>如何变得流行</title><link>https://linguista.cn/person/paul_graham/essays_zh/popular/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/popular/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/popular/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/popular.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/popular.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/popular.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="如何变得流行"&gt;如何变得流行&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（本文是作为一种新语言的商业计划书而写的。因此它缺少（因为想当然）一个好的编程语言最重要的特征：非常强大的抽象能力。）&lt;/p&gt;
&lt;p&gt;我有一个朋友曾经告诉一位著名的操作系统专家，他想设计一种真正好的编程语言。专家告诉他，这将是浪费时间，编程语言不会因为其优点而变得流行或不流行，所以无论他的语言有多好，都没人会使用。至少，这是他设计的语言所发生的情况。&lt;/p&gt;
&lt;p&gt;到底是什么让一种语言变得流行？流行的语言是否配得上它们的流行度？试图定义一个好的编程语言是否值得？你会怎么做？&lt;/p&gt;
&lt;p&gt;我认为这些问题的答案可以通过观察黑客并了解他们想要什么来找到。编程语言是为黑客而设计的，而编程语言作为编程语言（而不是，比如说，作为指称语义练习或编译器设计练习）是好的，当且仅当黑客喜欢它。&lt;/p&gt;
&lt;h2 id="1-流行的机制"&gt;1 流行的机制&lt;/h2&gt;
&lt;p&gt;当然，大多数人在选择编程语言时并不仅仅基于它们的优点。大多数程序员被告知要使用什么语言。然而我认为这些外部因素对编程语言流行度的影响并不像人们有时认为的那么大。我认为更大的问题是黑客对好的编程语言的想法与大多数语言设计者的想法不同。&lt;/p&gt;
&lt;p&gt;在这两者之间，黑客的意见才是重要的。编程语言不是定理。它们是工具，为人们设计的，必须像鞋子必须为人类的脚设计一样，适合人类的优点和缺点。如果鞋子穿上时夹脚，那它就是一双坏鞋，无论它作为雕塑品多么优雅。&lt;/p&gt;
&lt;p&gt;可能是大多数程序员无法区分好语言和坏语言。但这与其他工具没有什么不同。这并不意味着尝试设计好语言是浪费时间。专家黑客在看到好语言时能够识别出来，他们会使用它。诚然，专家黑客是极少数，但这个极少数群体编写了所有好的软件，他们的影响力使得其他程序员倾向于使用他们使用的任何语言。通常，这不仅仅是影响，而是命令：专家黑客通常就是那些作为老板或导师告诉其他程序员使用什么语言的人。&lt;/p&gt;
&lt;p&gt;专家黑客的意见并不是决定编程语言相对流行度的唯一力量——遗留软件（Cobol）和炒作（Ada、Java）也起作用——但我认为它是长期内最强大的力量。考虑到初始的关键质量和足够的时间，编程语言可能会变得与其应得的流行度相当。而流行度进一步将好语言与坏语言分开，因为来自真实用户的反馈总是导致改进。看看任何流行语言在其生命周期中发生了多大变化。Perl和Fortran是极端的例子，但即使是Lisp也发生了很大变化。例如，Lisp 1.5没有宏；这些是后来发展的，在麻省理工学院的黑客花了几年时间使用Lisp编写真实程序之后。[1]&lt;/p&gt;
&lt;p&gt;所以无论一种语言是否必须好才能流行，我认为一种语言必须流行才能好。它必须保持流行才能保持好。编程语言的工艺水平不会停滞不前。然而我们今天拥有的Lisp几乎与麻省理工学院在1980年代中期的Lisp相同，因为那是Lisp最后一次拥有足够大和要求高的用户群的时候。&lt;/p&gt;
&lt;p&gt;当然，黑客在使用语言之前必须了解它。他们如何听到？从其他黑客那里。但必须有一些初始的黑客群体使用该语言，其他人才能听到。我想知道这个群体必须多大；多少用户构成关键质量？我随口一说，二十个。如果一种语言有二十个独立的用户，意味着二十个用户自己决定使用它，我会认为它是真实的。&lt;/p&gt;
&lt;p&gt;达到那里并不容易。如果从零到二十比从二十到一千更难，我不会感到惊讶。获得那初始二十个用户的最好方法可能是使用特洛伊木马：给人们一个他们想要的应用程序，而这个应用程序恰好是用新语言编写的。&lt;/p&gt;
&lt;h2 id="2-外部因素"&gt;2 外部因素&lt;/h2&gt;
&lt;p&gt;让我们首先承认一个确实影响编程语言流行度的外部因素。要变得流行，编程语言必须是流行系统的脚本语言。Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来Perl也是。Tcl是Tk的脚本语言。Java和Javascript旨在成为Web浏览器的脚本语言。&lt;/p&gt;
&lt;p&gt;Lisp不是一个大规模流行的语言，因为它不是大规模流行系统的脚本语言。它保留的流行度可以追溯到1960年代和1970年代，当时它是麻省理工学院的脚本语言。当时的许多伟大程序员都在某个时期与麻省理工学院有关联。在1970年代初期，在C之前，麻省理工学院的Lisp方言MacLisp是严肃黑客想要使用的唯一编程语言之一。&lt;/p&gt;
&lt;p&gt;今天，Lisp是两个适度流行系统的脚本语言，Emacs和Autocad，因此我怀疑今天大部分Lisp编程都是在Emacs Lisp或AutoLisp中完成的。&lt;/p&gt;
&lt;p&gt;编程语言不是孤立存在的。Hack是一个及物动词——黑客通常在hack某物——在实践中，语言是相对于它们用来hack的任何东西来评判的。所以如果你想设计一种流行的语言，你要么必须提供比语言更多的东西，要么你必须设计你的语言来取代某个现有系统的脚本语言。&lt;/p&gt;
&lt;p&gt;Common Lisp不受欢迎的部分原因是因为它是一个孤儿。它确实伴随着一个要hack的系统：Lisp Machine。但Lisp Machines（以及并行计算机）在1980年代被通用处理器日益增长的力量压垮了。如果Common Lisp是Unix的好脚本语言，它可能会保持流行。唉，它是一个非常糟糕的脚本语言。&lt;/p&gt;
&lt;p&gt;描述这种情况的一种方法是说语言不是根据其自身的优点来评判的。另一种观点是，编程语言除非也是某物的脚本语言，否则就不是真正的编程语言。如果这让人感到意外，这似乎不公平。我认为这并不比期望编程语言有实现更不公平。这只是编程语言的一部分。&lt;/p&gt;
&lt;p&gt;当然，编程语言需要好的实现，而且这必须是免费的。公司会为软件付费，但个人黑客不会，而你需要吸引的是黑客。&lt;/p&gt;
&lt;p&gt;语言也需要有一本关于它的书。这本书应该是薄的、写得好的，充满了好的例子。K&amp;amp;R是这里的理想。目前我几乎会说一种语言必须有一本O&amp;rsquo;Reilly出版的书。这正成为对黑客重要性的测试。&lt;/p&gt;
&lt;p&gt;也应该有在线文档。事实上，书可以作为在线文档开始。但我不认为物理书已经过时了。它们的格式方便，出版商施加的事实审查是一种有用的、虽然不完美的过滤器。书店是学习新语言的最重要地方之一。&lt;/p&gt;
&lt;h2 id="3-简洁"&gt;3 简洁&lt;/h2&gt;
&lt;p&gt;假设你能提供任何语言需要的三个东西——一个免费的实现、一本书、以及要hack的东西——你如何制造一种黑客会喜欢的语言？&lt;/p&gt;
&lt;p&gt;黑客喜欢的一件事是简洁。黑客是懒惰的，与数学家和现代主义建筑师是懒惰的方式相同：他们讨厌任何多余的东西。说一个即将编写程序的黑客基于他必须键入的字符总数来选择使用什么语言，至少是潜意识的，这离真相不远。如果这不是黑客思考的精确方式，语言设计者最好表现得好像是这样。&lt;/p&gt;
&lt;p&gt;试图用冗长的表达来宠用户，这些表达旨在类似英语，是错误的。Cobol因此缺陷而臭名昭著。黑客会认为被要求写&lt;/p&gt;
&lt;p&gt;add x to y giving z&lt;/p&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;p&gt;z = x+y&lt;/p&gt;</description></item><item><title>Beating the Averages</title><link>https://linguista.cn/person/paul_graham/essays_en/avg/</link><pubDate>Sun, 01 Apr 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/avg/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/avg/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/avg.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/avg.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/avg.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="beating-the-averages"&gt;Beating the Averages&lt;/h1&gt;
&lt;p&gt;Want to start a startup? Get funded by Y Combinator. April 2001, rev. April 2003&lt;/p&gt;
&lt;p&gt;(This article is derived from a talk given at the 2001 Franz Developer Symposium.)&lt;/p&gt;
&lt;p&gt;In the summer of 1995, my friend Robert Morris and I started a startup called Viaweb. Our plan was to write software that would let end users build online stores. What was novel about this software, at the time, was that it ran on our server, using ordinary Web pages as the interface.&lt;/p&gt;</description></item><item><title>Lisp for Web-Based Applications</title><link>https://linguista.cn/person/paul_graham/essays_en/lwba/</link><pubDate>Sun, 01 Apr 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/lwba/</guid><description>&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/lwba.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/lwba.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/lwba.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp-for-web-based-applications"&gt;Lisp for Web-Based Applications&lt;/h1&gt;
&lt;p&gt;After a link to Beating the Averages was posted on slashdot, some readers wanted to hear in more detail about the specific technical advantages we got from using Lisp in Viaweb. For those who are interested, here are some excerpts from a talk I gave in April 2001 at BBN Labs in Cambridge, MA.&lt;/p&gt;</description></item><item><title>基于Web应用的Lisp</title><link>https://linguista.cn/person/paul_graham/essays_zh/lwba/</link><pubDate>Sun, 01 Apr 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/lwba/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/lwba/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/lwba.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/lwba.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/lwba.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="基于web应用的lisp"&gt;基于Web应用的Lisp&lt;/h1&gt;
&lt;p&gt;在《击败平均值》的链接被发布在slashdot上之后，一些读者希望更详细地了解我们在Viaweb中使用Lisp获得的具体技术优势。对于那些感兴趣的人，以下是我2001年4月在剑桥BBN实验室的演讲节选。&lt;/p&gt;
&lt;p&gt;BBN演讲节选（ASCII）&lt;/p&gt;</description></item><item><title>超越平均水平</title><link>https://linguista.cn/person/paul_graham/essays_zh/avg/</link><pubDate>Sun, 01 Apr 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/avg/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/avg/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/avg.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/avg.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/avg.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="超越平均水平"&gt;超越平均水平&lt;/h1&gt;
&lt;p&gt;2001年4月&lt;/p&gt;
&lt;p&gt;如果你想知道什么是编程的&amp;quot;秘密&amp;quot;，那么就是编程语言之间存在很大的差异。这不仅仅是理论问题。实际上，这会对创业公司产生很大影响。&lt;/p&gt;
&lt;p&gt;创业公司成功的可能性有多大？如果你考虑所有的创业公司，大多数都会失败。但如果你只考虑那些成功的创业公司，它们都有一个共同点：它们使用某种秘密武器。它们做了一些大公司无法做的事情。&lt;/p&gt;
&lt;h2 id="语言的差异"&gt;语言的差异&lt;/h2&gt;
&lt;p&gt;编程语言之间存在巨大差异。有些语言比其他语言强大得多。如果你使用一种强大的语言，你可以比使用较弱语言的程序员更快地完成工作。&lt;/p&gt;
&lt;p&gt;大多数程序员对编程语言之间的差异了解甚少。他们知道一些语言比其他语言更&amp;quot;高级&amp;quot;，但他们不理解这些差异有多大。他们不理解使用强大语言可以给你带来多大的优势。&lt;/p&gt;
&lt;p&gt;使用强大语言不仅仅是写代码更快的问题。它是关于你能做什么的问题。在较弱的语言中，有些事情根本做不了，或者做起来非常困难。在强大的语言中，这些事情很容易。&lt;/p&gt;
&lt;h2 id="lisp的优势"&gt;Lisp的优势&lt;/h2&gt;
&lt;p&gt;Lisp是最强大的编程语言之一。它比大多数其他语言强大得多。使用Lisp的程序员比使用其他语言的程序员有巨大的优势。&lt;/p&gt;
&lt;p&gt;Lisp的优势不是微小的。它是巨大的。使用Lisp的团队可以比使用其他语言的团队小得多，但仍然完成更多的工作。&lt;/p&gt;
&lt;p&gt;Viaweb就是一个例子。Viaweb是第一个基于Web的应用程序。它让用户可以在线构建商店。我们三个人使用Lisp构建了Viaweb。我们的竞争对手使用其他语言，如C++和Perl。他们需要更多的人来完成同样的工作。&lt;/p&gt;
&lt;h2 id="为什么更多的人不使用lisp"&gt;为什么更多的人不使用Lisp？&lt;/h2&gt;
&lt;p&gt;如果Lisp如此强大，为什么更多的人不使用它？&lt;/p&gt;
&lt;p&gt;一个原因是Lisp与其他语言非常不同。大多数程序员习惯使用类似C的语言。Lisp看起来很奇怪。&lt;/p&gt;
&lt;p&gt;另一个原因是Lisp并不适合所有事情。它不是最好的系统编程语言。如果你正在编写设备驱动程序，C可能更好。&lt;/p&gt;
&lt;p&gt;但Lisp非常适合编写Web应用程序。这就是我们选择它用于Viaweb的原因。&lt;/p&gt;
&lt;h2 id="创业公司的优势"&gt;创业公司的优势&lt;/h2&gt;
&lt;p&gt;创业公司可以利用大公司无法使用的强大语言。大公司有太多惯性。它们使用特定的语言，因为它们总是使用这些语言。它们不能轻易改变。&lt;/p&gt;
&lt;p&gt;创业公司可以灵活得多。它们可以选择最适合工作的工具。&lt;/p&gt;
&lt;p&gt;这不仅仅是技术问题。这关乎竞争。如果你使用比竞争对手更强大的语言，你可以更快地移动。你可以做他们做不到的事情。&lt;/p&gt;
&lt;h2 id="实际例子"&gt;实际例子&lt;/h2&gt;
&lt;p&gt;在Viaweb，我们能够快速添加新功能。我们的竞争对手需要几周才能完成的事情，我们可以在几天内完成。&lt;/p&gt;
&lt;p&gt;我们能够添加我们的竞争对手无法添加的功能。Lisp让我们能够做到这一点。&lt;/p&gt;
&lt;p&gt;例如，我们能够添加一个让用户编辑HTML的功能。我们的竞争对手无法做到这一点，因为他们的语言不够强大。&lt;/p&gt;
&lt;h2 id="学习曲线"&gt;学习曲线&lt;/h2&gt;
&lt;p&gt;Lisp有一个陡峭的学习曲线。大多数程序员需要一段时间才能习惯它。&lt;/p&gt;
&lt;p&gt;但这是值得的。一旦你学会了Lisp，你就会比其他程序员更有生产力。&lt;/p&gt;
&lt;h2 id="结论"&gt;结论&lt;/h2&gt;
&lt;p&gt;编程语言之间存在巨大差异。这些差异对创业公司来说很重要。&lt;/p&gt;
&lt;p&gt;如果你正在创办一家创业公司，你应该考虑使用像Lisp这样的强大语言。它可以给你带来竞争优势。&lt;/p&gt;
&lt;p&gt;不要担心别人会怎么说。做你认为正确的事情。&lt;/p&gt;
&lt;p&gt;记住，创业公司的目标是成功。如果使用强大的语言帮助你成功，那就去做吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;这篇文章基于Paul Graham在2001年4月发表的原创作品，讨论了编程语言之间的差异以及它们对创业公司的重要性。&lt;/em&gt;&lt;/p&gt;</description></item><item><title>ANSI Common Lisp 简介</title><link>https://linguista.cn/person/paul_graham/essays_zh/acl1txtt1748944359/</link><pubDate>Sun, 01 Jan 1995 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/acl1txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/acl1txtt1748944359/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="ansi-common-lisp-简介"&gt;ANSI Common Lisp 简介&lt;/h1&gt;
&lt;p&gt;ANSI Common Lisp 简介&lt;/p&gt;
&lt;p&gt;（这是Paul Graham的《ANSI Common Lisp》一书的第一章。版权1995年，Prentice-Hall。）&lt;/p&gt;
&lt;h2 id="介绍"&gt;介绍&lt;/h2&gt;
&lt;p&gt;John McCarthy和他的学生于1958年开始在第一个Lisp实现上工作。除了Fortran之外，Lisp是仍在使用的最古老的语言。[1] 更值得注意的是，它仍然处于编程语言技术的前沿。了解Lisp的程序员会告诉你，这种语言有某种独特之处。&lt;/p&gt;
&lt;p&gt;Lisp的独特之处部分在于它被设计为可进化的。你可以使用Lisp来定义新的Lisp操作符。当新的抽象变得流行时（例如面向对象编程），事实证明在Lisp中实现它们总是很容易的。像DNA这样的语言不会过时。&lt;/p&gt;
&lt;h2 id="新工具"&gt;新工具&lt;/h2&gt;
&lt;p&gt;为什么学习Lisp？因为它让你做其他语言做不到的事情。如果你只是想写一个返回小于n的数字之和的函数，在Lisp和C中看起来会非常相似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun sum (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (&lt;span style="color:#66d9ef"&gt;let&lt;/span&gt; ((s &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (dotimes (i n s)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (incf s i))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/* C */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sum&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; n){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i, s &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; s &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你只需要做这样的简单事情，你使用哪种语言并不重要。假设相反，你想写一个函数，它接受一个数字n，并返回一个将n加到其参数上的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun addn (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;#&amp;#39;&lt;/span&gt;(lambda (x) (&lt;span style="color:#a6e22e"&gt;+&lt;/span&gt; x n)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addn在C中是什么样的？你根本写不出来。&lt;/p&gt;
&lt;p&gt;你可能会想知道，什么时候有人会想做这样的事情？编程语言教会你不要渴望它们不能提供的东西。你必须用一种语言思考才能用其编写程序，很难渴望你无法描述的东西。当我开始编写程序时——使用Basic——我不想念递归，因为我不知道有这样的东西。我用Basic思考。我只能构想迭代算法，为什么要想念递归？&lt;/p&gt;
&lt;p&gt;如果你不怀念词法闭包（这就是前面例子中制作的东西），暂时相信Lisp程序员一直使用它们。很难找到任何长度的Common Lisp程序不利用闭包。到第112页，你自己也会使用它们。而闭包只是我们在其他语言中找不到的抽象之一。&lt;/p&gt;</description></item><item><title>Introduction to ANSI Common Lisp</title><link>https://linguista.cn/person/paul_graham/essays_en/acl1txtt1748944359/</link><pubDate>Sun, 01 Jan 1995 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/acl1txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/acl1txtt1748944359/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="introduction-to-ansi-common-lisp"&gt;Introduction to ANSI Common Lisp&lt;/h1&gt;
&lt;p&gt;Introduction to ANSI Common Lisp&lt;/p&gt;
&lt;p&gt;(This is the first chapter of ANSI Common Lisp, by Paul Graham. Copyright 1995, Prentice-Hall.)&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;John McCarthy and his students began work on the first Lisp implementation in 1958. After Fortran, Lisp is the oldest language still in use. [1] What&amp;rsquo;s more remarkable is that it is still in the forefront of programming language technology. Programmers who know Lisp will tell you, there is something about this language that sets it apart.&lt;/p&gt;</description></item><item><title>Welcome to Lisp</title><link>https://linguista.cn/person/paul_graham/essays_en/acl2txtt1748944359/</link><pubDate>Sun, 01 Jan 1995 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/acl2txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/acl2txtt1748944359/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="welcome-to-lisp"&gt;Welcome to Lisp&lt;/h1&gt;
&lt;p&gt;This chapter aims to get you programming as soon as possible. By the end of it you will know enough Common Lisp to begin writing programs.&lt;/p&gt;
&lt;h2 id="21-form"&gt;2.1 Form&lt;/h2&gt;
&lt;p&gt;It is particularly true of Lisp that you learn it by using it, because Lisp is an interactive language. Any Lisp system will include an interactive front-end called the toplevel. You type Lisp expressions into the toplevel, and the system displays their values. Lisp usually displays a prompt to tell you that it&amp;rsquo;s waiting for you to type something. Many implementations of Common Lisp use &amp;gt; as the toplevel prompt. That&amp;rsquo;s what we&amp;rsquo;ll use here.&lt;/p&gt;</description></item><item><title>欢迎来到Lisp</title><link>https://linguista.cn/person/paul_graham/essays_zh/acl2txtt1748944359/</link><pubDate>Sun, 01 Jan 1995 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/acl2txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/acl2txtt1748944359/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="欢迎来到lisp"&gt;欢迎来到Lisp&lt;/h1&gt;
&lt;p&gt;本章旨在让你尽快开始编程。到本章结束时，你将了解足够的Common Lisp知识来开始编写程序。&lt;/p&gt;
&lt;h2 id="21-形式"&gt;2.1 形式&lt;/h2&gt;
&lt;p&gt;对于Lisp来说尤其如此，你通过使用它来学习它，因为Lisp是一种交互式语言。任何Lisp系统都包含一个称为toplevel的交互式前端。你将Lisp表达式输入到toplevel中，系统会显示它们的值。Lisp通常会显示一个提示符来告诉你它在等待你输入内容。许多Common Lisp实现使用&amp;gt;作为toplevel提示符。这就是我们在这里要使用的。&lt;/p&gt;
&lt;p&gt;最简单的Lisp表达式之一是整数。如果我们在提示符后输入1，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; 1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;系统将打印它的值，然后是另一个提示符，表示它准备好接受更多输入。在这种情况下，显示的值与我们输入的相同。像1这样的数字被称为求值为自身。&lt;/p&gt;
&lt;p&gt;当我们输入需要一些工作来求值的表达式时，生活变得更加有趣。例如，如果我们想要将两个数字相加，我们输入类似这样的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在表达式(+ 2 3)中，+被称为运算符，数字2和3被称为参数。在日常生活中，我们会将这个表达式写为2 + 3，但在Lisp中，我们将+运算符放在前面，后面跟着参数，整个表达式用一对括号括起来：(+ 2 3)。这被称为前缀表示法，因为运算符在前。&lt;/p&gt;
&lt;p&gt;这种写表达式的方式起初可能看起来很奇怪，但实际上这种表示法是Lisp最棒的特点之一。例如，如果我们想要将三个数字相加，在普通表示法中我们必须使用+两次，2 + 3 + 4，而在Lisp中我们只需添加另一个参数：(+ 2 3 4)&lt;/p&gt;
&lt;p&gt;我们通常使用+的方式是，它必须恰好有两个参数：一个在左边，一个在右边。前缀表示法的灵活性意味着，在Lisp中，+可以接受任意数量的参数，包括无参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;2
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3 4)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;9
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3 4 5)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;14
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为运算符可以接受不同数量的参数，我们需要括号来表示表达式的开始和结束。表达式可以嵌套。也就是说，表达式中的参数本身可能是复杂的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (/ (- 7 1) (- 4 2))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用英语来说，这是七减一，除以四减二。&lt;/p&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/person/paul_graham/essays_en/progbot/</link><pubDate>Fri, 01 Jan 1993 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_en/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_zh/progbot/"&gt;中文版本&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;January 1993 (This essay is from the introduction to On Lisp.)&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a long-standing principle of programming style that the functional elements of a program should not be too large. If some component of a program grows beyond the stage where it&amp;rsquo;s readily comprehensible, it becomes a mass of complexity which conceals errors as easily as a big city conceals fugitives. Such software will be hard to read, hard to test, and hard to debug.&lt;/p&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/person/paul_graham/essays_zh/progbot/</link><pubDate>Fri, 01 Jan 1993 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/progbot/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;
&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;
&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;
&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;
&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;
&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;
&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;
&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;
&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;
&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;
&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;
&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description></item></channel></rss>