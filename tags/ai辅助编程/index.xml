<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI辅助编程 on Linguista</title><link>https://linguista.cn/tags/ai%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/</link><description>Recent content in AI辅助编程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 19 Oct 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/ai%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Andrej Karpathy的编程哲学与AI辅助编程实践指南</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/andrej-karpathy-programming-philosophy-ai-coding/</link><pubDate>Sun, 19 Oct 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/andrej-karpathy-programming-philosophy-ai-coding/</guid><description>&lt;h1 id="andrej-karpathy的编程哲学与ai辅助编程实践指南"&gt;Andrej Karpathy的编程哲学与AI辅助编程实践指南&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文整理了Andrej Karpathy关于编程学习和AI辅助编程的核心理念。他强调&amp;quot;亲手构建&amp;quot;是获取深度理解的唯一途径，提倡找到问题的&amp;quot;第一近似项&amp;quot;来构建知识坡道。在AI辅助编程方面，他认为自动完成是当前的最佳平衡点，并指出了编码模型在原创性、认知理解和代码质量方面的局限性。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;Andrej Karpathy的编程哲学建立在一个坚定的信念之上：如果不能构建它，就无法真正理解它。这一理念源自费曼，成为了他学习和教学的核心理念。他强调，真正的知识获取不应该停留在阅读博客或观看幻灯片层面，而是要通过亲手编写代码、组织代码、运行代码来实现。这种方法能够迫使我们直面自己的知识盲区，从而实现更深层次的理解。&lt;/p&gt;
&lt;p&gt;在学习方法上，Karpathy提出了几个关键原则。首先是避免复制粘贴——即使在参考大型代码库时，也应该在一个显示器上展示参考代码，在另一个显示器上从头开始构建。其次是他从物理学背景中借鉴的&amp;quot;第一近似项&amp;quot;理念，即找到系统的认知核心。他的Micrograd仓库就是这一理念的实践，仅用100行Python代码展示了神经网络训练的本质——通过链式法则递归应用计算梯度，其他所有内容都只是效率优化。&lt;/p&gt;
&lt;p&gt;关于教育理念，Karpathy认为应该构建&amp;quot;知识坡道&amp;quot;，让学生经历先遇到问题、再学习解决方案的过程。优秀的教育应该先呈现&amp;quot;痛点&amp;quot;，给学生自己思考和尝试的机会，这样能最大化知识获取效果。这种循序渐进的方式与他的编程哲学一脉相承，都是通过实践来深化理解。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第一近似项&lt;/strong&gt;：这是Karpathy从物理学中借鉴的概念，指找到系统的最简化核心模型。以他的Micrograd为例，100行代码就能展示神经网络训练的数学本质——梯度计算通过链式法则递归应用。所有其他内容（优化器、层抽象等）都只是为了效率而添加的复杂度。掌握第一近似项能够帮助学习者快速抓住问题的本质，避免在细节中迷失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识坡道&lt;/strong&gt;：Karpathy将教育视为构建&amp;quot;坡道&amp;quot;的工程技术过程。这个坡道的设计原则是先让学生遇到实际问题，感受到解决方案的必要性，然后再呈现工具和方法。这种&amp;quot;问题先行&amp;quot;的教学方式能够最大化学习效果，因为它模拟了真实的知识创造过程——先有需求，再有解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;亲手构建原则&lt;/strong&gt;：这是Karpathy最核心的学习理念。他认为阅读文档、观看教程都只是知识的被动接收，只有通过亲手编写代码、调试错误、解决问题，才能真正将知识内化。即使在参考他人的代码时，他也坚持要自己输入而不是复制粘贴，因为打字过程中的每一个决策都是加深理解的机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI辅助编程的三个层次&lt;/strong&gt;：Karpathy将当前的编程方式分为三类——完全拒绝LLM、使用自动完成辅助、以及&amp;quot;代工式编程&amp;quot;。他认为自动完成是当前的最佳平衡点，因为它保持了程序员的架构师角色，同时利用AI提高输入效率。这种方式的&amp;quot;信息带宽&amp;quot;很高：程序员只需定位光标并输入前几个字母，模型就能理解意图并完成代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码模型的认知局限&lt;/strong&gt;：Karpathy在构建Nanochat仓库时发现，当前的AI编码模型在多个方面存在不足。它们不擅长编写从未存在过的原创代码，往往无法理解非典型的编程方式，倾向于创建过度防御性的臃肿代码，并且经常使用已弃用的API。这些缺陷源于模型的训练数据——它们学习的是互联网上的常见代码模式，而当开发者试图创新时，模型反而会成为干扰。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://twitter.com/karpathy"&gt;Andrej Karpathy on Programming and Learning&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Andrej Karpathy&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Zed与Sequoia共建协作式编程新未来</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/zed-deltadb-collaborative-coding-future/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/zed-deltadb-collaborative-coding-future/</guid><description>&lt;h1 id="zed与sequoia共建协作式编程新未来"&gt;Zed与Sequoia共建协作式编程新未来&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍了Zed获得由Sequoia Capital领投的3200万美元B轮融资，并阐述了Zed团队的长期愿景：打造一种全新的软件协作方式，让代码讨论与代码本身紧密相连，突破传统快照式版本控制的局限。Zed正在开发基于操作级别的版本控制系统DeltaDB，旨在实现人与AI代理之间的实时、持续协作。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先分析了传统版本控制系统（特别是Git）在协作开发中的根本性局限。现实中的软件开发是持续的对话过程，涉及个人、团队以及AI代理之间的交流。然而，现有的协作工具主要基于快照式的提交机制，导致代码讨论往往与代码本身脱节。当开发者需要针对特定代码片段展开讨论时，只能链接到某个快照版本或将代码复制到聊天工具中，这些快照很快就会过时，宝贵的上下文信息随之丢失。在AI代理协作场景下，这种局限更加明显——现有工具要求每次交流都必须生成快照，极大增加了操作负担。&lt;/p&gt;
&lt;p&gt;为了解决这些问题，Zed团队开发了DeltaDB——一种基于操作级别的全新版本控制系统。DeltaDB采用CRDTs（无冲突复制数据类型）技术，能够实时、增量地记录和同步代码变更。它与Git兼容，但其基于操作的设计支持Git快照无法实现的实时交互。对于异步协作，DeltaDB的细粒度变更追踪支持字符级永久链接，即使代码发生大幅重构，也能将讨论锚定在任意代码位置，而不仅仅是最近变更的快照。&lt;/p&gt;
&lt;p&gt;Zed的愿景是将IDE变为真正的协作空间，让代码库成为一个&amp;quot;活的&amp;quot;可导航历史，记录软件演变的全过程。DeltaDB不仅记录代码本身，还保留了代码为何演变至当前状态的背景信息，包括假设、约束和决策。这些信息可供AI代理查询，从而做出更智能的编辑，理解代码背后的逻辑和前因后果。Zed和DeltaDB均采用开源策略，先开发后开源，并提供可选的付费服务，推动协作工具的持续进化。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;操作级版本控制&lt;/strong&gt;：传统版本控制系统（如Git）基于快照（snapshot），只能记录离散的提交点。而DeltaDB采用CRDTs技术，能够记录每一个操作级别的变更，实现实时的增量同步。这种设计让协作从离散的提交变为连续的对话流，特别适合人与AI代理之间频繁、即时的交互场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码讨论与代码的紧密关联&lt;/strong&gt;：现有工具将代码讨论与代码本身分离，导致上下文信息容易丢失。DeltaDB通过细粒度的变更追踪和永久链接功能，确保讨论始终与最新的代码状态保持同步。即使代码大幅重构，讨论仍然可以锚定在正确的位置，形成完整的协作历史。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;活的代码库&lt;/strong&gt;：Zed的愿景是让代码库成为可导航的&amp;quot;活&amp;quot;历史，不仅记录代码的变化，还保留演变的背景信息（假设、约束、决策）。当新工程师遇到问题或AI代理需要理解代码时，可以直接查询这些背景信息，从而做出更智能的决策。这种设计将代码库从静态的文件集合转变为动态的知识库。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://zed.dev/blog/sequoia-backs-zed"&gt;Sequoia Backs Zed&amp;rsquo;s Vision for Collaborative Coding&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Zed团队&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025年8月20日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>AI原生软件工程师</title><link>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</guid><description>&lt;h1 id="ai原生软件工程师"&gt;AI原生软件工程师&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文定义了AI原生软件工程师的概念，即将AI深度融入日常开发工作流程、视其为协作伙伴而非威胁的工程师。文章阐述了核心思维转变——从恐惧AI取代转向主动利用AI放大自身能力，提出信任但验证的协作原则，并给出了从工具准备到逐步建立AI熟练度的实践路径，强调工程师仍需对代码质量承担全部责任。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI原生思维&lt;/strong&gt;：将AI内化为思考问题和构建软件的核心方式，对每项任务主动思考AI如何协助完成，而非被动等待&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文工程&lt;/strong&gt;：通过精心构造提示词和上下文信息，引导AI生成高质量输出的技术手段，是高级工程师发挥专业优势的关键能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信任但验证&lt;/strong&gt;：将AI视为知识丰富但经验尚浅的结对编程伙伴，利用其速度和信息量的同时，工程师必须对每一行代码的质量和正确性负最终责任&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程师即管理者&lt;/strong&gt;：AI时代工程师角色从亲力亲为转向协调和监督AI智能体完成任务，通过规则文件和结构化代码塑造人机协作环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进式采用&lt;/strong&gt;：从小处着手逐步建立AI熟练度，先将任务交给AI模型观察表现，再结合编码助手和智能体工具形成完整的AI优先工作流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者：Addy Osmani&lt;/li&gt;
&lt;li&gt;日期：2025年7月2日&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href="https://addyo.substack.com/p/the-ai-native-software-engineer"&gt;The AI-Native Software Engineer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交互式报告：&lt;a href="https://linguage.github.io/articles/ai-native-software-engineer.html"&gt;AI原生软件工程师&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AI原生软件工程师&lt;/em&gt; 是指那些将AI深度融入日常工作流程，视其为伙伴以放大自身能力的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这需要一个根本性的&lt;strong&gt;思维转变&lt;/strong&gt;。AI原生工程师不会想“AI可能会取代我”，而是对每项任务都问自己：“&lt;em&gt;AI能帮助我更快、更好或以不同方式完成这项任务吗？&lt;/em&gt;”。&lt;/p&gt;
&lt;p&gt;这种思维模式是乐观和积极主动的——你将AI视为提高生产力和创造力的倍增器，而非威胁。采用正确的方法，&lt;strong&gt;AI可以将你作为工程师的产出提高2倍、5倍，甚至可能10倍&lt;/strong&gt;。经验丰富的开发者尤其会发现，他们的专业知识使他们能够以产生高水平结果的方式来提示AI；高级工程师可以通过适当的&lt;a href="https://x.com/karpathy/status/1937902205765607626"&gt;上下文工程&lt;/a&gt;，向AI提出正确的问题，从而获得与同行交付结果相当的答案。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!t2_Y!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ae2c5e0-27c6-4959-b37d-67f2c40b2e09_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;成为AI原生意味着拥抱&lt;strong&gt;持续学习和适应&lt;/strong&gt;——工程师从一开始就将基于AI的辅助和自动化融入软件构建中。这种思维模式会带来对可能性的兴奋而非恐惧。&lt;/p&gt;
&lt;p&gt;是的，可能会有不确定性和学习曲线——我们许多人都经历过兴奋、恐惧然后又回到兴奋的情绪过山车——但最终目标是落脚于兴奋和机遇。AI原生工程师将AI视为一种委派开发中重复或耗时部分（如样板代码、文档起草或测试生成）的方式，从而解放自己，专注于更高层次的问题解决和创新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——AI是协作者，而非替代品：&lt;/strong&gt; AI原生工程师将AI视为一个知识渊博但经验尚浅的结对编程伙伴，并且全天候可用。&lt;/p&gt;
&lt;p&gt;你仍然主导开发过程，但会不断利用AI获取想法、解决方案，甚至是警告。例如，你可能会使用AI助手来集思广益架构方案，然后凭借自己的专业知识来完善这些想法。这种协作可以显著加快开发速度，同时提高质量——&lt;em&gt;如果你能保持监督&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;重要的是，你不能将责任完全推给AI。把它想象成与一个阅读过所有StackOverflow帖子和API文档的初级开发者合作：他们拥有大量信息，可以快速生成代码，但&lt;strong&gt;你负责指导他们并验证其输出&lt;/strong&gt;。这种“&lt;a href="https://addyo.substack.com/p/the-trust-but-verify-pattern-for"&gt;信任但验证&lt;/a&gt;”的思维模式至关重要，我们稍后会再次讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!qzj1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4ff8ce3d-bcdc-45ed-933b-c0a1038c63ea_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;坦率地说：AI 生成的劣质内容是真实存在的，这不能成为&lt;a href="https://addyo.substack.com/p/vibe-coding-is-not-an-excuse-for"&gt;低质量工作&lt;/a&gt;的借口。使用这些工具的一个持续风险是草率批准的建议、微妙的幻觉和简单的懒惰相结合，这远远低于专业工程标准。这就是为什么“验证”是这个口号中不可协商的部分。作为工程师，你不仅仅是工具的使用者；你是最终的担保人。你仍然对你提交的每一行代码的质量、可读性、安全性和正确性负有全部直接责任。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!Qzt7!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F61fdf82a-2bcc-4a81-853e-779af54c24a2_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——现在每个工程师都是管理者：&lt;/strong&gt; 工程师的角色正在发生根本性变化。有了AI智能体，你更多地是协调工作，而不是亲力亲为地执行所有工作。&lt;/p&gt;
&lt;p&gt;你仍然对提交到主分支的每一项改动负责，但你更多地关注定义和“分配”要完成的工作。在不远的将来，我们可能会越来越多地说“&lt;a href="https://x.com/levie/status/1938647740554092586"&gt;现在每个工程师都是管理者&lt;/a&gt;”。合法的工作可以指派给Jules或Codex等后台智能体，或者你可以让Claude Code/Gemini CLI/OpenCode处理分析或代码迁移项目。工程师需要有意识地塑造代码库，使其更容易与AI协作，这可以通过使用规则文件（例如GEMINI.md）、良好的READMEs和结构良好的代码来实现。这使得工程师扮演了&lt;a href="https://www.infoworld.com/article/3994519/the-tough-task-of-making-ai-code-production-ready.html"&gt;监督者、导师和验证者&lt;/a&gt;的角色。AI优先的团队规模更小，能完成更多工作，并且能够&lt;a href="https://www.forrester.com/blogs/appgen-is-here-say-goodbye-to-software-development-as-you-know-it/"&gt;缩短SDLC的步骤&lt;/a&gt;，从而更快地交付更高质量的产品。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!wUui!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7cfea4-0f99-4c8d-81bd-d4c81070eee4_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级优势：&lt;/strong&gt; 通过将AI完全融入你的工作流程，你可以实现显著的生产力飞跃，可能更快地发布更多功能，而不会牺牲质量（当然，这需要考虑任务复杂性等细微差别）。&lt;/p&gt;
&lt;p&gt;日常任务（从代码格式化到编写单元测试）可以在几秒钟内完成。也许更重要的是，AI可以增强你的理解：就像有一个随叫随到的专家，可以解释代码或在你专业领域之外的领域提出解决方案。结果是，AI原生工程师可以承担更雄心勃勃的项目，或者以更小的团队处理相同的工作量。从本质上讲，&lt;strong&gt;AI扩展了你的能力&lt;/strong&gt;，让你在更高的抽象层次上工作。但前提是需要有效使用它——这就是正确的思维模式和实践发挥作用的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例——思维模式的实践：&lt;/strong&gt; 想象你正在调试一个棘手的问题或评估一个新的技术栈。传统方法可能涉及大量的Google搜索或阅读文档。而AI原生方法是与支持搜索基础或深度研究的AI助手互动：描述错误或询问技术栈的优缺点，让AI提供见解甚至代码示例。&lt;/p&gt;
&lt;p&gt;你仍然负责解释和实施，但AI会加速信息收集和可能的解决方案。一旦你习惯了，这种协作式问题解决就会成为第二天性。养成习惯，问自己：“&lt;em&gt;AI如何能帮助我完成这项任务？&lt;/em&gt;”直到这成为一种反射。随着时间的推移，你将培养出AI擅长什么以及如何有效提示它的直觉。&lt;/p&gt;
&lt;p&gt;总而言之，&lt;strong&gt;成为AI原生意味着将AI内化为你思考问题和构建软件的核心方式&lt;/strong&gt;。这是一种与机器协作的思维模式：利用它们的优势（速度、知识、模式识别）来补充你自己的优势（创造力、判断力、上下文）。有了这个基础，我们就可以进入将AI融入日常工作的实用步骤。&lt;/p&gt;
&lt;p&gt;如果你对AI原生工作流程完全陌生，一开始可能会感到望而生畏。关键是&lt;strong&gt;从小处着手，逐步建立&lt;/strong&gt;你的AI熟练度。在本节中，我们将提供具体指导，帮助你在日常工程任务中从零开始，高效地使用AI。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!OGxs!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3ef50d3c-e6f1-4b5e-a850-2177e561bbc1_1536x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以上是对我们最终可能在软件生命周期中实现AI的推测性展望。我仍然坚信需要人工参与（工程、设计、产品、用户体验等），以确保质量不会下降。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1：第一个改变是什么？你通常从AI开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI原生工作流程并非偶尔寻找AI可以提供帮助的任务；它通常是首先将任务交给AI模型，看看它的表现如何。&lt;a href="https://www.ignorance.ai/p/ai-at-pulley"&gt;一个团队指出&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;典型的工作流程是首先将任务交给AI模型（通过Cursor或CLI程序）……并理解很多任务仍然是“碰运气”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你是在研究一个领域还是一个竞争对手？从Gemini深度研究开始。发现自己陷入关于某个设计方面的无休止争论？当你的团队争论不休时，你可能已经用AI构建了三个原型来验证这个想法。Google员工已经&lt;a href="https://x.com/rmedranollamas/status/1938305816185966898"&gt;用它来制作幻灯片、调试生产事故等等&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当你听到“但LLM会产生幻觉，聊天机器人给出糟糕的答案”时，是时候更新你的工具链了。今天任何&lt;a href="https://fly.io/blog/youre-all-nuts/"&gt;认真使用AI编码的人都在使用智能体&lt;/a&gt;。幻觉可以通过适当的&lt;a href="https://blog.langchain.com/the-rise-of-context-engineering/"&gt;上下文工程&lt;/a&gt;和智能体反馈循环得到显著缓解和管理。思维转变是基础性的：我们所有人都应该立即成为AI优先的用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤2：准备好正确的AI工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要顺利集成AI，你需要在你的环境中至少设置一个编码助手。许多工程师从VS Code中的&lt;strong&gt;GitHub Copilot&lt;/strong&gt;开始，它具有代码自动完成和代码生成功能。如果你使用VS Code等IDE，可以考虑安装一个AI扩展（例如，&lt;strong&gt;Cursor&lt;/strong&gt;是一个专门的AI增强代码编辑器，而**&lt;a href="https://addyo.substack.com/p/why-i-use-cline-for-ai-engineering"&gt;Cline&lt;/a&gt;&lt;strong&gt;是一个用于AI智能体的VS Code插件——稍后会详细介绍这些）。这些工具非常适合初学者，因为它们在后台运行，为你正在编辑的任何文件实时提供代码建议。在编辑器之外，你还可以在单独的窗口中探索&lt;/strong&gt;ChatGPT、Gemini或Claude**，以获取问答式的帮助。从工具开始很重要，因为它降低了使用AI的摩擦。一旦安装，每当你想到“也许AI可以帮助我完成这项任务”时，AI就近在咫尺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤3：学习提示基础——具体并提供上下文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效使用AI是一项技能，这项技能的核心是**&lt;a href="https://addyo.substack.com/p/the-prompt-engineering-playbook-for"&gt;提示工程&lt;/a&gt;**。新用户常犯的一个错误是给AI一个过于模糊的指令，然后对结果感到失望。记住，AI不是读心术；它对你给出的提示做出反应。多一点上下文或清晰度会大有帮助。例如，如果你有一段代码，想要它的解释或单元测试，不要只说_“为这个写测试。”_ 相反，&lt;strong&gt;在你的提示中描述代码的预期行为和要求&lt;/strong&gt;。比较以下两个为React登录表单组件编写测试的提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;糟糕的提示：&lt;/strong&gt; “你能为我的React组件写测试吗？”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更好的提示：&lt;/strong&gt; “我有一个&lt;code&gt;LoginForm&lt;/code&gt; React组件，包含一个电子邮件字段、密码字段和提交按钮。它在成功提交时显示成功消息，在失败时显示错误消息，通过&lt;code&gt;onSubmit&lt;/code&gt;回调。&lt;strong&gt;请编写一个Jest测试文件&lt;/strong&gt;，该文件：(1) 渲染表单，(2) 填写有效和无效输入，(3) 提交表单，(4) 断言&lt;code&gt;onSubmit&lt;/code&gt;以正确数据被调用，以及 (5) 检查成功和错误状态是否正确渲染。”&lt;/p&gt;</description></item><item><title>编码作为手艺——回归旧式健身房</title><link>https://linguista.cn/rosetta/technology/coding-as-craft-going-back-to-the-old-gym/</link><pubDate>Tue, 22 Apr 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/coding-as-craft-going-back-to-the-old-gym/</guid><description>&lt;h1 id="编码作为手艺回归旧式健身房"&gt;编码作为手艺——回归旧式健身房&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以洛奇·巴尔博亚的旧式健身房为隐喻，探讨在AI日益渗透编程工作的时代，开发者应如何保持对编码手艺的掌控。作者主张AI适合处理样板代码和文档总结等机械性工作，但编程的核心思考、架构设计和认知挣扎不应被外包，因为正是这些挣扎塑造了工程师的成长与能力。文章倡导有意识地与AI协作，而非不假思索地依赖AI。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;认知挣扎（Cognitive Struggle）——指开发者在面对难题时经历的卡顿、思考和突破过程，这一过程能形成深层记忆和技能成长，是不可被AI替代的学习路径&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动自觉使用与有意识协作（Reflexive vs. Intentional）——前者指不假思索地依赖AI完成一切，后者强调在明确场景下有选择地使用AI，并对其输出保持批判性审视&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旧式健身房（Old Gym）——借用电影洛奇的隐喻，代表开发者直接与问题搏斗、不依赖AI缓冲的原始训练环境，象征回归手艺磨炼的本源&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码手艺（Coding as Craft）——将编程视为一门需要持续打磨的手艺而非纯粹的产出活动，强调过程中的思考、设计与学习同样重要&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI使用界限（AI Usage Boundaries）——为AI辅助设定明确边界，将其限定于样板代码生成和文档查阅等辅助性任务，核心算法和架构决策则保留由人完成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章来源： &lt;a href="https://cekrem.github.io/posts/coding-as-craft-going-back-to-the-old-gym/"&gt;Coding as Craft: Going Back to the Old Gym&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2025年4月22日&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;近期，Shopify的CEO Tobi Lütke分享了他对AI在编码中作用的看法，指出“主动自觉地使用AI现已成为Shopify的基本要求”。他信息的核心要点是，AI正在彻底改变我们的工作方式，每个人都应该搭上这班列车，否则就有被甩下的风险。我稍微转述了一下，但大致如此——请查看原文以了解完整的背景和内容。&lt;/p&gt;
&lt;p&gt;这触动了我，但并非他所期望的那种方式。在与Elm工程师同行的Slack对话中，我发现自己输入了以下内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间点很有趣。我刚切换回vim，就是为了进一步远离AI对我编码的干扰。我上次关于AI的演讲副标题是“自动化无聊的部分”（灵感来自那本经典的Python书籍），对我来说，AI就是干这个的。&lt;/p&gt;
&lt;p&gt;然而，编码并非无聊的部分，它是我的手艺，我想享受它并保持敏锐。当然，如果你手头只有LLM（大语言模型），用它来提问和讨论话题是可以的。但“主动自觉地使用AI”听起来像是我不希望出现在我名下的诊断结果。&lt;/p&gt;
&lt;p&gt;如果人们不再经历那种偶尔的僵局——咬紧牙关、审视问题、哭泣、散步、祈祷和呐喊，直到豁然开朗（并且你学到了东西！），我会称之为严重的倒退，而非进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我对这次交流以及前辈们的其他评论反思得越多，就越意识到它关联到一些更深层次的东西，关乎我们与技术和手艺的关系。是时候谈谈回归旧式健身房了。&lt;/p&gt;
&lt;h2 id="洛奇巴尔博亚原则-the-rocky-balboa-principle"&gt;洛奇·巴尔博亚原则 (The Rocky Balboa Principle)&lt;/h2&gt;
&lt;p&gt;在电影《洛奇3》中，有一个关键时刻，米奇（Mickey）质问洛奇（Rocky）是如何失去锐气的：“你过去像超人一样，但最糟糕的事情发生在了一个拳手身上：你变得文明（安逸）了！”&lt;/p&gt;
&lt;p&gt;米奇的解决方案？“我们离开这儿，回那个旧健身房去！”&lt;/p&gt;
&lt;p&gt;这一幕一直留在我心中，因为它捕捉到了关于精通技艺和技能发展的一些深刻道理。“旧健身房”代表了真实成长发生的原始、必要条件。它不舒适，不豪华，但真正的锤炼在那里完成。&lt;/p&gt;
&lt;p&gt;在编码的语境下，我们的“旧式健身房”是我们直接与问题、算法和架构搏斗，而没有AI为我们生成解决方案这个缓冲垫的心智空间。&lt;/p&gt;
&lt;h2 id="ai作为工具而非替代品"&gt;AI作为工具，而非替代品&lt;/h2&gt;
&lt;p&gt;首先明确一点：我并非反对AI。事实上，我发现它极其有用——用于处理那些无聊的部分。&lt;/p&gt;
&lt;p&gt;AI擅长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成样板代码&lt;/li&gt;
&lt;li&gt;总结文档&lt;/li&gt;
&lt;li&gt;解释复杂概念&lt;/li&gt;
&lt;li&gt;帮助调试棘手的错误信息&lt;/li&gt;
&lt;li&gt;起草单元测试&lt;/li&gt;
&lt;li&gt;格式化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是编程的核心——思考、设计、架构决策——这些是我希望作为我的手艺加以珍视的部分。这些是我希望通过在旧式健身房训练来保持强壮的肌肉。&lt;/p&gt;
&lt;h2 id="认知挣扎的价值-the-value-of-cognitive-struggle"&gt;认知挣扎的价值 (The Value of Cognitive Struggle)&lt;/h2&gt;
&lt;p&gt;与难题搏斗的过程有其不可替代的价值。当你卡住时，完全卡住时，你可能会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沮丧地咬紧牙关&lt;/li&gt;
&lt;li&gt;离开电脑&lt;/li&gt;
&lt;li&gt;去散步&lt;/li&gt;
&lt;li&gt;向上帝祈祷和/或痛哭一场&lt;/li&gt;
&lt;li&gt;回来再尝试不同方法&lt;/li&gt;
&lt;li&gt;重复直至……突然间，豁然开朗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那个“啊哈！”的时刻会重塑你的大脑。它创建了神经通路，让你永久性地在你所做的事情上变得更强。这就是编码界的肌肉记忆，也是我们作为工程师成长的方式。&lt;/p&gt;
&lt;p&gt;当我们将这种挣扎外包给AI时，我们就剥夺了我们自身的这些成长机会。我们得到了解决方案却不理解其所以然。我们得到了代码却没有手艺的沉淀。&lt;/p&gt;
&lt;p&gt;AI可以生成代码，但它（目前）还不能理解那些使系统随着时间推移真正可维护和适应性强的细致入微的决策。它不会像拥有深厚经验和来之不易知识的人那样，用心和考量去设计你的领域层（domain layer）。并且重申：它是否在特定任务上成功不应是你唯一关心的，如果你在乎你的手艺——你是否学到了东西也应该重要！&lt;/p&gt;</description></item></channel></rss>