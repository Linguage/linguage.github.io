<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>游戏开发 on Linguista</title><link>https://linguista.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link><description>Recent content in 游戏开发 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 23 Aug 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>马力欧64内存浪费全解析</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/mario64-memory-waste-analysis/</link><pubDate>Sat, 23 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/mario64-memory-waste-analysis/</guid><description>&lt;h1 id="马力欧64内存浪费全解析"&gt;马力欧64内存浪费全解析&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文深入分析《超级马力欧64》在任天堂64主机仅4MB内存环境下的内存分配现状，揭示了游戏开发过程中存在的诸多内存浪费现象。尽管开发团队已采用多种优化手段，但由于手动内存分配的历史局限、代码未优化、对象池设计低效等问题，游戏仍浪费了大量内存空间。通过技术手段，理论上甚至可以让马力欧64运行在内存更小的PlayStation 1主机上。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先介绍了任天堂64主机的内存限制与马力欧64的内存分配现状。1996年N64仅有4MB内存，需要容纳游戏代码、引擎、音乐、输出缓冲区和角色状态等多种数据，内存极度紧张。在某些关卡中，仅增加两张32x64像素的贴图就会导致内存溢出，开发者不得不采用压缩、复用、删减细节等技巧来&amp;quot;塞进&amp;quot;所有数据。马力欧64的4MB内存被划分为多个区域，包括Z缓冲区、内存池、音乐数据、代码、变量状态、引擎代码和帧输出缓冲区，所有空间看似被&amp;quot;刚好&amp;quot;用满，实则存在大量浪费。&lt;/p&gt;
&lt;p&gt;文章详细分析了六大类内存浪费现象。一是手动分配导致的内存空洞，程序员手动指定各内存段的起止地址，导致段与段之间出现大量未被利用的空白空间；二是代码与引擎区的冗余，游戏以&amp;quot;调试模式&amp;quot;编译，包含大量无用注释和调试信息，仅改变编译模式即可节省约50%空间；三是角色状态与对象池的浪费，每个角色都分配固定的608字节空间，无论实际需求如何，对象池也固定为240个但实际最多用到180个；四是音乐与音效系统的低效，音乐区有18%空间始终为零，未被使用；五是贴图与几何数据的冗余，贴图常被分配全彩通道即使只需灰度；六是缓冲区与Z缓冲区的边缘浪费，屏幕黑边和Z缓冲区底部8行像素被渲染但不显示。&lt;/p&gt;
&lt;p&gt;最后，文章提出了内存分配的&amp;quot;建筑师-工人&amp;quot;心智模型，分析了现代内存管理的进步。手动分配虽灵活但极易出错和浪费，现代做法更倾向于让编译器自动连续分配。文章以《塞尔达传说：时之笛》为例，说明采用&amp;quot;overlay&amp;quot;机制按需加载角色和关卡数据可极大节省内存，而马力欧64一次性加载全部导致80%空间长期闲置。文章指出，有些浪费是开发便利或兼容性的权衡，在开发周期和性能之间做出取舍。当游戏能正常运行且没有明显瓶颈时，进一步优化内存意义有限，开发者往往选择&amp;quot;够用就好&amp;quot;而非极致压榨。后续游戏在内存管理上有显著进步，体现了技术和经验的积累。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;手动内存分配&lt;/strong&gt;：程序员像建筑师一样手动规划每一块内存的用途和位置，编译器像工人按指令分配空间。这种方式虽灵活但极易出错和浪费，容易在段与段之间留下未被利用的空洞。现代开发更倾向于让编译器自动连续分配，减少空洞和维护成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存空洞&lt;/strong&gt;：在手动内存分配中，由于计算失误或预留扩展空间，导致不同内存段之间出现完全未被利用的空白区域。例如帧缓冲区后910字节空白、音乐区113字节空白、Z缓冲区后36800字节空白（约73张贴图的空间），这些浪费可以通过优化分配策略避免。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象池固定分配&lt;/strong&gt;：马力欧64为每个角色对象分配固定的608字节空间，无论对象复杂程度如何，其中约一半空间对大多数对象来说是多余的。对象池固定为240个对象，但实际关卡最多只用180个左右，这种设计让&amp;quot;刷怪&amp;quot;类玩法成为可能，但对普通流程来说是巨大浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试代码冗余&lt;/strong&gt;：游戏代码和引擎部分未针对体积进行优化，甚至以&amp;quot;调试模式&amp;quot;编译，包含大量无用注释、重复代码和调试信息。仅将代码编译为&amp;quot;体积最小&amp;quot;模式即可节省约50%空间，引擎区有一半内容仅在关卡加载时用到，之后完全闲置，可以在用完后释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按需加载机制&lt;/strong&gt;：《塞尔达传说：时之笛》采用&amp;quot;overlay&amp;quot;机制，按需加载角色和关卡数据，极大节省内存。相比之下，马力欧64一次性加载全部数据，导致80%空间长期闲置。这种&amp;quot;只加载所需&amp;quot;原则是现代内存管理的重要策略，可以在硬件限制下实现更丰富的游戏内容。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=oZcbgNdWL7w"&gt;Mario 64 wastes SO MUCH MEMORY&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Kaze Emanuar&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-08-23&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>俄罗斯和乌克兰知名软件概览</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/russia-ukraine-software-overview/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/russia-ukraine-software-overview/</guid><description>&lt;h1 id="俄罗斯和乌克兰知名软件概览"&gt;俄罗斯和乌克兰知名软件概览&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文系统梳理了俄罗斯和乌克兰两国在软件开发领域的代表性产品。乌克兰的 Grammarly、MacPaw、GitLab、4A Games、Readdle 等公司在写作辅助、工具软件、代码托管、游戏开发和移动应用领域具有重要影响力；俄罗斯的 7-Zip、WinRAR、Nginx、Yandex、Telegram、JetBrains、卡巴斯基实验室等则在压缩软件、Web 服务、搜索引擎、即时通讯、开发环境和安全防护等领域占据重要地位。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从乌克兰和俄罗斯两国的国情背景出发，分别介绍了两国在软件开发领域的重要产品。乌克兰方面，IT 产业出口在 2022 年突破 70 亿美元，孕育了 Grammarly 这样的 AI 写作辅助工具、MacPaw 的 CleanMyMac X 等 macOS 工具、GitLab 开源代码托管平台、4A Games 的《地铁》系列游戏以及 Readdle 的 PDF Expert 和 Spark 等应用。这些产品在全球范围内拥有数千万用户。&lt;/p&gt;
&lt;p&gt;俄罗斯方面，作为世界上面积最大的国家，在软件领域同样成果丰硕。Igor Pavlov 开发的 7-Zip 以高效压缩算法和免费使用著称；尤金·罗谢尔的 WinRAR 和 RAR 格式同样广受欢迎；Igor Sysoev 的 Nginx 是全球最流行的 Web 服务器之一；Yandex 是俄罗斯本土搜索引擎巨头；Telegram 以强大的加密功能闻名；JetBrains 的集成开发环境工具深受开发者喜爱；卡巴斯基实验室在网络安全领域具有重要地位。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Grammarly&lt;/strong&gt;：总部位于美国的乌克兰技术公司产品，基于人工智能和自然语言处理技术，可自动检测英文语法、拼写和标点错误，是全球广泛使用的数字写作辅助工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt;：由俄罗斯程序员 Igor Sysoev 开发的 Web 服务器软件，支持高并发网络流量，可作为 Web 服务器、反向代理服务器、负载均衡器和缓存服务器使用，是现代互联网基础设施的重要组成部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Telegram&lt;/strong&gt;：由帕维尔·杜罗夫开发的即时通讯应用，以端到端加密和私密性著称，支持文本消息、语音通话和文件传输，在全球拥有大量用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JetBrains&lt;/strong&gt;：总部位于捷克、创始人为俄罗斯人的软件公司，开发了 PyCharm、IntelliJ IDEA、WebStorm 等集成开发环境工具，为开发者提供高效编程体验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitLab&lt;/strong&gt;：由乌克兰程序员开发的开源代码托管平台，使用 Ruby 和 Go 语言编写，提供从项目规划到 CI/CD、监控和安全性的全方位 DevOps 解决方案。&lt;/p&gt;</description></item><item><title>使用LÖVE构建游戏原型的探索</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/building-game-prototypes-with-love/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/building-game-prototypes-with-love/</guid><description>&lt;h1 id="使用löve构建游戏原型的探索"&gt;使用LÖVE构建游戏原型的探索&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文记录了作者在2025年完成并发布一个完整游戏的目标，以及他使用LÖVE框架进行游戏原型开发的冬季假期经历。LÖVE是一个用Lua语言制作2D游戏的框架，具有简单而强大的API。作者分享了他的学习体验、代码示例，以及国际象棋UI和卡牌游戏原型的开发过程，为游戏开发者提供了宝贵的实践参考。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从作者的个人目标开始谈起——到2025年完成一个可以在Steam或App Store上销售的完整游戏。作者此前有制作小型游戏的经验，但这次希望能够完成并发布一个完整的游戏项目。为了实现这一目标，他选择在冬季假期期间使用LÖVE框架进行原型开发。&lt;/p&gt;
&lt;p&gt;LÖVE是一个用于2D游戏开发的框架，使用Lua语言编写。作者在使用LÖVE之前已经写过约200行Lua代码，因此学习LÖVE的语法对他来说没有困难。他强调了LÖVE API的简洁性和强大功能——能够用少量代码展示完整的游戏功能。文章提供了一个让玩家控制方块在屏幕上移动的代码示例，展示了LÖVE的核心回调函数结构。&lt;/p&gt;
&lt;p&gt;在实践部分，作者分享了两个具体项目：国际象棋用户界面和卡牌游戏UI。国际象棋项目源于作者每年冬天都会回归国际象棋的习惯，他通过LÖVE的回调函数捕捉鼠标输入，实现了一个基础的国际象棋界面。卡牌游戏原型则展示了卡牌交互动画，作者特别强调了动画在卡牌游戏中的重要性。&lt;/p&gt;
&lt;p&gt;最后，作者概述了他2025年的游戏开发计划，包括游戏设计、原型创建、游戏测试等步骤。他也提到可能会使用Godot引擎进行更复杂的游戏开发，并将其原型代码开源供其他开发者参考。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LÖVE框架&lt;/strong&gt;：LÖVE是一个免费、开源的框架，用于使用Lua语言制作2D游戏。它的API设计简洁而强大，开发者可以用很少的代码实现完整的游戏功能。LÖVE的核心结构基于三个主要回调函数：&lt;code&gt;load()&lt;/code&gt;用于初始化，&lt;code&gt;update()&lt;/code&gt;用于处理游戏逻辑，&lt;code&gt;draw()&lt;/code&gt;用于渲染画面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏原型开发&lt;/strong&gt;：原型开发是游戏开发过程中的重要环节，它允许开发者快速验证游戏概念和机制。LÖVE特别适合原型开发，因为它的学习曲线平缓，开发速度快。作者通过国际象棋UI和卡牌游戏两个例子，展示了如何快速构建可玩的游戏原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua编程语言&lt;/strong&gt;：Lua是一种轻量级、高效的脚本语言，常用于游戏开发。语法简洁，易于学习。作者提到在使用LÖVE前只写了约200行Lua代码，但这足以让他开始构建游戏原型。Lua的动态特性和简洁语法使其成为快速原型开发的理想选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏开发迭代流程&lt;/strong&gt;：作者展示了从概念设计到原型实现，再到测试和迭代的完整流程。他计划2025年进行一系列游戏设计和开发步骤，包括设计游戏、创建原型、进行游戏测试等。这种迭代方法是现代游戏开发的标准实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动画在游戏中的重要性&lt;/strong&gt;：在卡牌游戏原型部分，作者特别强调了动画的重要性。流畅的动画能够显著提升游戏体验，使玩家操作更加直观和愉悦。这体现了游戏开发中&amp;quot;游戏手感&amp;quot;（game feel）的重要性——即玩家与游戏互动时的整体感受。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://healeycodes.com/building-game-prototypes-with-love"&gt;Building Game Prototypes with LÖVE&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Andrew Healey&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年12月&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>