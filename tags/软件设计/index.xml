<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>软件设计 on Linguista</title><link>https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</link><description>Recent content in 软件设计 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>软件设计原则的四个教训</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</guid><description>&lt;h1 id="软件设计原则的四个教训"&gt;软件设计原则的四个教训&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者设计和实现大型服务项目的实践经验，总结了四个重要的软件设计原则。这些原则从反面教训出发，帮助工程师避免常见的软件设计陷阱，包括数据同步问题、过度抽象、测试可靠性以及状态管理等核心议题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先介绍了作者的实践背景，通过一个大型服务项目的开发经历，提炼出四个反复出现的设计原则。这些原则往往与传统观点存在差异，体现了实践中获得的真实经验。&lt;/p&gt;
&lt;p&gt;第一原则强调维护单一数据源的重要性。作者指出，当同一数据在多个地方维护时，很容易出现同步错误。派生数据应该动态计算而非单独存储，这样可以避免数据不一致的问题。虽然计算成本可能增加，但可靠性是更重要的考虑因素。&lt;/p&gt;
&lt;p&gt;第二原则提出了一个反直觉的观点——请重复自己（PRY）。作者反思了DRY（Don&amp;rsquo;t Repeat Yourself）原则的局限性，认为过度抽象会导致代码复杂化，反而违背了简化的初衷。适度的代码重复有时是保持代码可维护性的更好选择。&lt;/p&gt;
&lt;p&gt;第三原则关注测试策略，建议避免过度使用Mock。Mock虽然能简化单元测试，但可能导致测试与实际环境脱节。作者推荐使用真实依赖或本地服务器进行测试，以提高测试的可靠性和实际意义。&lt;/p&gt;
&lt;p&gt;第四原则强调最小化可变状态的重要性。在优化过程中，过度依赖缓存和数据库会增加状态管理的复杂性。现代计算机性能足够强大，可以承受一定的冗余计算，因此简洁的状态管理应该优先于性能优化。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单一数据源&lt;/strong&gt;：指同一数据应该只在一个地方维护和存储，避免在多个位置重复保存相同数据。当需要数据时，应该从唯一的数据源获取，而不是使用本地缓存或副本。对于派生数据，应该通过计算获得而不是单独存储，这样可以避免数据同步错误和一致性问题的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PRY原则&lt;/strong&gt;：即&amp;quot;Please Repeat Yourself&amp;quot;，是对传统DRY原则的反思和补充。DRY原则强调不要重复代码，但过度应用会导致不必要的抽象，使代码变得复杂难懂。PRY原则认为，适度的代码重复是可接受的，有时候甚至是更好的选择，因为它可以保持代码的简单性和可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock依赖&lt;/strong&gt;：指在测试中使用模拟对象替代真实的依赖组件。Mock可以隔离被测试的代码，简化测试环境，但过度使用会导致测试与实际生产环境脱节，测试可能通过但实际运行时出现问题。作者建议尽量使用真实依赖或集成测试来验证软件的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变状态&lt;/strong&gt;：指程序运行过程中可以改变的数据状态。可变状态越多，状态同步和一致性管理的难度就越大。最小化可变状态意味着减少程序中需要维护的动态数据，优先使用不可变数据和计算结果，这样可以降低软件复杂度，减少同步错误的发生概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生数据&lt;/strong&gt;：指从原始数据通过计算或处理得到的数据。例如，可支配余额是从账户余额减去固定支出计算得到的。派生数据应该动态计算而不是单独存储，这样可以避免维护多个数据源导致的同步问题，确保数据的一致性和准确性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://read.engineerscodex.com/p/4-software-design-principles-i-learned?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;4 Software Design Principles I Learned the Hard Way&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Engineers Codex&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Notion CEO Ivan Zhao 软件设计的未来与美观实用并存理念</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/notion-ceo-ivan-zhao-interview/</link><pubDate>Fri, 10 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/notion-ceo-ivan-zhao-interview/</guid><description>&lt;h1 id="notion-ceo-ivan-zhao-软件设计的未来与美观实用并存理念"&gt;Notion CEO Ivan Zhao 软件设计的未来与美观实用并存理念&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文是对 Notion 创始人兼 CEO Ivan Zhao 的深度访谈记录。Ivan 分享了 Notion 的设计哲学、用户策略以及未来发展规划。他强调软件应该兼具美观和实用，将 Notion 比作&amp;quot;软件界的乐高&amp;quot;。访谈还探讨了如何平衡创造者与使用者的需求，2025 年在性能、离线模式和移动端的技术投资计划，以及如何通过用户反馈驱动产品迭代。截至 2025 年，Notion 已拥有超过 1 亿用户，估值超过 100 亿美元。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本次访谈围绕 Notion 的设计理念展开，Ivan 首先分享了他的设计灵感来源——威廉·莫里斯的工艺美术运动理念&amp;quot;家中不应有不美观或无用的东西&amp;quot;。他将这一理念应用到软件设计中，强调 Notion 应该既美观又实用，既具有创造性又能满足实际需求。这种设计哲学体现在产品的方方面面，从左侧边栏的简洁设计到色彩选择、圆角处理等细节，都旨在为用户创造平静、舒适的使用体验。&lt;/p&gt;
&lt;p&gt;访谈接着探讨了 Notion 如何平衡&amp;quot;建造者&amp;quot;和&amp;quot;使用者&amp;quot;两类不同用户的需求。Ivan 承认目前的 Notion 更像一堆散落的乐高积木，对新手缺乏足够的引导。他强调需要为非创造者用户提供更多模板和引导，同时为创造者提供更强大的模块和功能。这两类用户之间存在良好的共生关系——创造者制作的模板和解决方案可以帮助其他用户更好地使用 Notion。&lt;/p&gt;
&lt;p&gt;关于 2025 年的发展规划，Ivan 明确表示将重点投资于四个技术领域：提升大型数据库的处理速度、改善移动端体验、支持低网速或离线模式、以及提升系统的可靠性和扩展性。这些基础性技术投入将为 Notion 未来几年的产品创新奠定坚实基础。&lt;/p&gt;
&lt;p&gt;最后，访谈强调了用户反馈在 Notion 产品发展中的核心作用。Ivan 的手机会实时接收所有用户反馈，虽然无法逐一阅读，但能够感知用户的需求和痛点。Notion 团队会系统化地分析这些反馈，将其转化为具体的产品改进任务，确保用户的声音能够真正影响产品的发展方向。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;美观与实用并存&lt;/strong&gt;：Ivan 受威廉·莫里斯启发，认为优秀的设计应该兼具美观性和实用性。这种理念不仅体现在 Notion 的产品界面设计上，如温暖的米白色调、圆润的边角处理等细节，更体现在产品的整体定位上——既要像乐高一样具有无限的创造可能性，又要提供足够的实用性让用户能够高效完成工作。这种设计哲学让 Notion 在功能强大的同时保持了人性化的温度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件界的乐高&lt;/strong&gt;：这是 Notion 对自身的定位，既强调模块化的灵活性，又注重易用性。乐高积木既可以是简单的玩具，也可以构建复杂的机械装置，Notion 也希望实现这种从简单到复杂的覆盖。但目前 Notion 在引导非创造者用户方面还有提升空间，需要通过模板、市场等功能为新手提供更多支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户反馈驱动&lt;/strong&gt;：Ivan 通过手机实时接收用户反馈，这种方式让 CEO 能够直接感知用户的需求和痛点。虽然无法阅读每一条反馈，但这种&amp;quot;氛围感知&amp;quot;对于保持产品团队与用户的连接至关重要。Notion 还会系统化地分析反馈内容，提取关键词和涉及的产品模块，将其转化为产品路线图中的具体任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术基础投资&lt;/strong&gt;：2025 年 Notion 将重点投资于性能、离线模式、可靠性、扩展性和移动端体验。这些看似不性感的基础性技术工作，实际上是支撑产品持续创新的关键。特别是对大型数据库性能的优化和对移动端的重视，反映了 Notion 对用户实际使用场景的深入理解。&lt;/p&gt;</description></item><item><title>代理型 AI 的强大之处及其实现原理</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/agentic-ai-power-architecture-principles/</link><pubDate>Fri, 10 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p3/agentic-ai-power-architecture-principles/</guid><description>&lt;h1 id="代理型-ai-的强大之处及其实现原理"&gt;代理型 AI 的强大之处及其实现原理&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;代理型 AI 系统通过将复杂查询分解为一系列由不同组件处理的微步骤，而非依赖单一 LLM 一次性解决问题。本文详细阐述了代理型 AI 相较于传统 LLM 系统的六大核心优势：灵活性与可修改性、模块化、可扩展性、职责分离与松耦合、鲁棒性以及一致性，并通过客户支持聊天机器人、科学文献处理系统、Uber QueryGPT 等实际案例，展示了如何将软件工程领域的成熟设计原则成功应用于 AI 系统架构中。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;代理型 AI 系统的核心思想在于借鉴传统软件工程的最佳实践，将控制、效率和规模的思想引入大语言模型领域。与传统 LLM 系统依赖单一模型处理所有任务不同，代理型架构通过任务分解和专业化组件协作，显著提升了系统的准确性、稳定性和可维护性。&lt;/p&gt;
&lt;p&gt;文章首先定义了代理型 AI 系统的基本概念，强调其通过将用户查询拆解为微步骤，由不同专门组件协同工作的机制。随后，文章系统性地探讨了六大核心优势：灵活性使系统更易于修改和适应变化；模块化通过独立组件降低复杂性；可扩展性确保系统能够应对增长的工作负载；职责分离简化开发并减少意外副作用；鲁棒性保证系统在部分故障时仍能正常运行；一致性则通过减少 LLM 的不确定性交互提高系统可预测性。&lt;/p&gt;
&lt;p&gt;每个优势都配有详细的实践案例，从客户支持聊天机器人的多代理协作，到科学文献处理系统的分布式架构，再到自动驾驶汽车的安全冗余设计，生动展示了代理型 AI 在实际应用中的价值。作者最后强调，代理型 AI 并非革命性概念，而是将软件领域成熟的架构原则有机融入 AI 系统设计的自然演进。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;代理型 AI 系统&lt;/strong&gt;：将复杂查询分解为一系列微步骤，由不同专门组件或代理协同处理的系统架构。与传统依赖单一 LLM 的方法相比，这种分解式处理方式显著提高了准确性、减少了不可控错误，并使系统更易于扩展和维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块化设计&lt;/strong&gt;：将系统分解为更小、独立的模块，每个模块专注于特定功能。这种设计降低了整体复杂性，使开发团队能够专注于个别组件的优化，同时便于测试、调试和后续升级。客户支持聊天机器人的案例表明，通过设置查询处理、订单跟踪、响应生成和升级等专门代理，可以在提高性能的同时降低运营成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：系统在处理增加的工作负载或更大数据量时，不牺牲性能的能力。这对于利用规模经济至关重要。科学文献处理系统通过摄取、分析、检索、排名和聚合等专门代理实现分布式处理，而 Uber 的 QueryGPT 则通过在数据过滤后才调用 LLM，实现了成本的亚线性增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;职责分离与松耦合&lt;/strong&gt;：将软件系统组织成专注于特定功能的不同部分，简化开发流程，降低复杂性，并减少意外副作用的风险。IQIDIS 法律 AI 初创公司的实践表明，通过为不同司法管辖区的案例法创建独立存储环境，以及为多模态内容和自定义嵌入提供专属空间，可以有效避免错误推荐并提高系统安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鲁棒性与一致性&lt;/strong&gt;：鲁棒性指系统在面对错误、意外输入或部分故障时保持功能和性能的能力，这对于医疗保健或法律等关键领域应用至关重要。自动驾驶汽车通过多个专门代理控制不同功能，当某个代理故障时，其他代理可以接管或启动紧急程序。一致性则通过增加确定性组件的使用和限制 LLM 的不必要交互，使系统表现出更可预测的行为，减少用户困惑并简化调试过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://artificialintelligencemadesimple.substack.com/p/why-is-agentic-ai-so-powerful-agentsthoughts"&gt;Why is Agentic AI so Powerful [Agents][Thoughts]&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Devansh&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-10&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>黑客与画家</title><link>https://linguista.cn/person/paul_graham/essays_zh/hp/</link><pubDate>Thu, 01 May 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/hp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/hp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="黑客与画家"&gt;黑客与画家&lt;/h1&gt;
&lt;p&gt;2003年5月&lt;/p&gt;
&lt;p&gt;（本文源于在哈佛大学的一次客座讲座，该讲座整合了之前在东北大学的一次演讲。）&lt;/p&gt;
&lt;p&gt;当我完成计算机科学研究生学业后，我去艺术学院学习绘画。很多人似乎对感兴趣于计算机的人也会对绘画感兴趣感到惊讶。他们似乎认为黑客和绘画是截然不同的工作类型——黑客工作是冷酷、精确、有条理的，而绘画则是某种原始冲动的狂热表达。&lt;/p&gt;
&lt;p&gt;这两种形象都是错误的。黑客和绘画有很多共同之处。事实上，在我认识的所有不同类型的人中，黑客和画家是最相似的。&lt;/p&gt;
&lt;p&gt;黑客和画家的共同点是他们都是创造者。与作曲家、建筑师和作家一样，黑客和画家试图做的是创造好东西。他们本身并不是在做研究，尽管在试图创造好东西的过程中他们发现了一些新技术，那就更好了。&lt;/p&gt;
&lt;p&gt;我从来不喜欢&amp;quot;计算机科学&amp;quot;这个词。我不喜欢它的主要原因是没有这样的东西。计算机科学是一堆关系不大的领域的拼凑，因历史的偶然而被组合在一起，就像南斯拉夫一样。一端是实际上是数学家的人，但他们称自己做的事情为计算机科学，以便获得DARPA资助。中间是从事类似计算机自然史工作的人——例如研究通过网络路由数据的算法行为。然后在另一端是黑客，他们试图编写有趣的软件，对他们来说，计算机只是表达媒介，就像对建筑师来说是混凝土，对画家来说是颜料一样。这就像是数学家、物理学家和建筑师都必须在同一个系里一样。&lt;/p&gt;
&lt;p&gt;有时黑客所做的事情被称为&amp;quot;软件工程&amp;quot;，但这个术语同样具有误导性。优秀的软件设计师并不比建筑师更像工程师。建筑和工程之间的界限并没有明确界定，但它是存在的。它在于做什么和如何做之间：建筑师决定做什么，工程师弄清楚如何做。&lt;/p&gt;
&lt;p&gt;做什么和如何做不应过于分离。如果你试图在不知道如何做的情况下决定做什么，那是在自找麻烦。但黑客工作绝不仅仅是决定如何实现某个规范。在最好的情况下，它是创建规范——但事实证明做到这一点的最好方法是实现它。&lt;/p&gt;
&lt;p&gt;也许有一天&amp;quot;计算机科学&amp;quot;会像南斯拉夫一样被分解成其组成部分。这可能是件好事。特别是如果这意味着我自己的领域——黑客的独立。&lt;/p&gt;
&lt;p&gt;将所有这些不同类型的工作捆绑在一个部门可能在行政上很方便，但在智力上是混乱的。这是我不喜欢&amp;quot;计算机科学&amp;quot;这个名字的另一个原因。可以说，中间的人在做类似实验科学的事情。但两端的人，黑客和数学家，实际上并不是在做科学。&lt;/p&gt;
&lt;p&gt;数学家似乎并不为此困扰。他们很高兴地开始证明定理，就像数学系的数学家一样，并且很快就会停止注意到他们工作的建筑外面写着&amp;quot;计算机科学&amp;quot;。但对黑客来说，这个标签是个问题。如果他们所做的事情被称为科学，这让他们觉得他们应该表现得科学。因此，大学和研究实验室里的黑客不做他们真正想做的事情，即设计美丽的软件，而是觉得他们应该写研究论文。&lt;/p&gt;
&lt;p&gt;在最好的情况下，论文只是一种形式。黑客编写很酷的软件，然后写一篇关于它的论文，论文就成为了软件所代表成就的代理。但这种不匹配经常导致问题。很容易从创造美丽的东西转向创造丑陋的东西，而这些东西更适合作为研究论文的题材。&lt;/p&gt;
&lt;p&gt;不幸的是，美丽的东西并不总是最好的论文主题。首先，研究必须是原创的——正如任何写过博士论文的人所知，确保你在探索未知领域的方法是占据一块没有人想要的地盘。其次，研究必须是实质性的——笨拙的系统会产生更丰富的论文，因为你可以写为了完成工作而必须克服的障碍。没有什么比从错误假设开始更能产生丰富的问题了。大多数人工智能都是这个规则的例子；如果你假设知识可以表示为谓词逻辑表达式的列表，其参数代表抽象概念，你将有很多论文要写关于如何使其工作。正如里奇·里卡多常说的：&amp;ldquo;露西，你有很多解释要做。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;创造美丽东西的方法往往是对现有事物进行微妙的调整，或者以稍新的方式组合现有的想法。这种工作很难在研究论文中传达。&lt;/p&gt;
&lt;p&gt;那么为什么大学和研究实验室继续用出版物来判断黑客呢？原因与&amp;quot;学术能力&amp;quot;用简单的标准化测试衡量，或者程序员的生产力用代码行数衡量是一样的。这些测试很容易应用，没有什么比一个勉强有效的简单测试更诱人的了。&lt;/p&gt;
&lt;p&gt;衡量黑客真正试图做的事情，设计美丽的软件，会困难得多。你需要良好的设计感来判断好的设计。人们识别好设计的能力与他们对自己能做到的信心之间没有任何相关性，除了可能是负相关。&lt;/p&gt;
&lt;p&gt;唯一的外部测试是时间。随着时间的推移，美丽的东西往往会繁荣，丑陋的东西往往会被抛弃。不幸的是，所涉及的时间可能比人类寿命还长。塞缪尔·约翰逊说，作家的声誉需要一百年才能收敛。你必须等待作家有影响力的朋友死去，然后他们所有的追随者都死去。&lt;/p&gt;
&lt;p&gt;我认为黑客只能接受自己声誉中有很大的随机成分。在这方面，他们与其他创造者没有什么不同。事实上，相比之下，他们是幸运的。时尚在黑客中的影响力远不如在绘画中那么大。&lt;/p&gt;
&lt;p&gt;有比被人误解你的作品更糟糕的事情。更危险的是你会自己误解你的作品。相关领域是你寻找想法的地方。如果你发现自己身处计算机科学系，自然会有一种诱惑，例如认为黑客是理论计算机科学理论的应用版本。我在研究生院的整个时间里，脑海中总有一种不安的感觉，觉得我应该知道更多理论，而且在期末考试后三周内忘记所有东西是非常疏忽的。&lt;/p&gt;
&lt;p&gt;现在我意识到我错了。黑客需要了解计算理论的程度，与画家需要了解颜料化学的程度差不多。你需要知道如何计算时间和空间复杂性以及图灵完备性。你可能还想记住至少状态机的概念，以防你不得不编写解析器或正则表达式库。事实上，画家必须记住的颜料化学知识比这多得多。&lt;/p&gt;
&lt;p&gt;我发现，最好的想法来源不是名字中有&amp;quot;计算机&amp;quot;一词的其他领域，而是创造者居住的其他领域。绘画比计算理论是更丰富的想法来源。&lt;/p&gt;
&lt;p&gt;例如，我在大学里学到的是，一个人应该在完全接触计算机之前在纸上完整地构思一个程序。我发现我不是这样编程的。我发现我喜欢坐在计算机前编程，而不是在纸上。更糟糕的是，我不是耐心地写出完整的程序并确保它是正确的，而是倾向于只是喷出完全没有希望的代码，然后逐渐把它塑造成形。我学到的是，调试是一种最后阶段，你捕捉打字错误和疏忽。按照我的工作方式，编程似乎就是由调试组成的。&lt;/p&gt;
&lt;p&gt;很长时间以来，我对此感觉很糟糕，就像我曾经因为小学时握铅笔的方式和他们教我的不一样而感到难过一样。如果我看过其他创造者，画家或建筑师，我会意识到我所做的事情有一个名字：素描。据我所知，他们在大学教我的编程方法完全是错的。你应该在编写程序时构思程序，就像作家、画家和建筑师所做的那样。&lt;/p&gt;
&lt;p&gt;意识到这一点对软件设计有实际意义。这意味着编程语言最重要的特性应该是可塑的。编程语言是用来思考程序的，而不是表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果人们真的像他们在大学教我的那样写程序，静态类型会是个好主意。但这不是我认识的任何黑客写程序的方式。我们需要一种让我们能够涂鸦、涂抹和弄脏的语言，而不是一种你必须用一杯类型平衡在膝盖上与严格的老婶婶编译器礼貌交谈的语言。&lt;/p&gt;
&lt;p&gt;既然我们在讨论静态类型，认同创造者将使我们免于困扰科学的另一个问题：数学嫉妒。科学界的每个人都秘密认为数学家比他们聪明。我认为数学家也相信这一点。无论如何，结果是科学家倾向于使他们的工作看起来尽可能数学化。在像物理学这样的领域，这可能不会造成太大伤害，但离自然科学越远，这个问题就越大。&lt;/p&gt;
&lt;p&gt;一页公式看起来非常令人印象深刻。（提示：为了更加令人印象深刻，使用希腊变量。）因此，有很大的诱惑去做你可以正式处理的问题，而不是那些重要的，比如说，重要的问题。&lt;/p&gt;
&lt;p&gt;如果黑客认同其他创造者，比如作家和画家，他们就不会感到诱惑去做这种事情。作家和画家不遭受数学嫉妒。他们觉得他们在做完全不相关的事情。我认为黑客也是如此。&lt;/p&gt;
&lt;p&gt;如果大学和研究实验室阻止黑客做他们想做的工作，也许他们的位置是在公司。不幸的是，大多数公司也不会让黑客做他们想做的事情。大学和研究实验室强迫黑客成为科学家，公司强迫他们成为工程师。&lt;/p&gt;
&lt;p&gt;我自己直到最近才发现这一点。当雅虎收购Viaweb时，他们问我想做什么。我从来不太喜欢商业方面，说我只想黑客。当我到雅虎时，我发现黑客对他们来说意味着实现软件，而不是设计它。程序员被视为技术人员，将产品经理的愿景（如果那算是的话）翻译成代码。&lt;/p&gt;
&lt;p&gt;这似乎是大公司的默认计划。他们这样做是因为它减少了结果的标准差。只有一小部分黑客能够真正设计软件，公司经营者很难挑选出这些人。因此，大多数公司不将软件的未来委托给一个才华横溢的黑客，而是设置成由委员会设计，黑客只实现设计。&lt;/p&gt;
&lt;p&gt;如果你想赚钱，记住这一点，因为这是创业公司获胜的原因之一。大公司希望减少设计结果的标准差，因为他们想避免灾难。但当你抑制波动时，你既失去了高点，也失去了低点。这对大公司来说不是问题，因为他们不是靠做出伟大的产品获胜的。大公司靠比其他大公司少些糟糕获胜。&lt;/p&gt;
&lt;p&gt;所以如果你能找到一种方法与一家大公司进行设计战争，大到其软件是由产品经理设计的，他们将永远无法跟上你。不过，这些机会并不容易找到。很难让大公司参与设计战争，就像很难让城堡内的对手进行肉搏战一样。例如，编写一个比微软Word更好的文字处理器会很容易，但微软在其操作系统垄断的城堡内，即使你做到了，可能甚至不会注意到。&lt;/p&gt;
&lt;p&gt;进行设计战争的地方是新市场，在那里还没有人设法建立任何防御工事。在那里，你可以通过大胆的设计方法，以及让同样的人既设计又实现产品而大获全胜。微软自己一开始就是这样做的。苹果也是如此。惠普也是如此。我怀疑几乎所有成功的创业公司都是如此。&lt;/p&gt;
&lt;p&gt;所以构建伟大软件的一种方法是创办自己的创业公司。然而，这有两个问题。一是在创业公司，你必须做很多编程以外的事情。在Viaweb，如果我能有四分之一的时间黑客，我就觉得自己很幸运。我在其他四分之三的时间里不得不做的事情从乏味到可怕不等。我对此有一个基准，因为我曾经不得不离开董事会会议去补牙。我记得坐在牙医的椅子上，等待钻头，感觉就像在度假。&lt;/p&gt;
&lt;p&gt;创业公司的另一个问题是，赚钱的软件和有趣的软件之间没有太多重叠。编程语言写起来很有趣，微软的第一个产品确实是，但现在没有人会为编程语言付钱。如果你想赚钱，你往往被迫从事对任何人来说都太麻烦而无法免费解决的问题。&lt;/p&gt;
&lt;p&gt;所有创造者都面临这个问题。价格由供求关系决定，对有趣工作的需求不如解决个人客户日常问题的需求多。在外百老汇戏剧中表演不如在贸易展上穿着大猩猩服装在别人的展位工作赚钱。写小说不如为垃圾处理器写广告文案赚钱。黑客编程语言不如想办法将某公司的遗留数据库连接到他们的Web服务器赚钱。&lt;/p&gt;
&lt;p&gt;我认为这个问题的答案，在软件的情况下，是一个几乎所有创造者都知道的概念：日常工作。这个词始于音乐家，他们晚上表演。更一般地说，这意味着你做一种工作是为了钱，做另一种是为了爱。&lt;/p&gt;
&lt;p&gt;几乎所有创造者在职业生涯早期都有日常工作。画家和作家尤其如此。如果你幸运，你可以找到与你真正工作密切相关的日常工作。音乐家似乎经常在唱片店工作。从事某种编程语言或操作系统工作的黑客同样可能能够使用它获得日常工作。[1]&lt;/p&gt;
&lt;p&gt;当我说答案是为黑客提供日常工作，并在业余时间从事美丽软件工作时，我并不是在提出一个新想法。这就是开源黑客的全部内容。我要说的是，开源可能是正确的模式，因为它已经被所有其他创造者独立证实。&lt;/p&gt;
&lt;p&gt;任何雇主都不愿让黑客从事开源项目，这让我感到惊讶。在Viaweb，我们不愿意雇佣任何不这样做的人。当我们面试程序员时，我们主要关心的是他们在业余时间编写什么样的软件。除非你热爱它，否则你不能真正做好任何事情，如果你热爱黑客，你将不可避免地从事自己的项目。[2]&lt;/p&gt;
&lt;p&gt;因为黑客是创造者而不是科学家，寻找隐喻的正确地方不是科学，而是其他类型的创造者。绘画还能教给我们什么关于黑客的知识？&lt;/p&gt;
&lt;p&gt;我们可以从绘画的例子中学到的一件事，或者至少确认的是，如何学习黑客。你主要通过做来学习绘画。黑客也是如此。大多数黑客不是通过上大学编程课程来学习黑客的。他们在十三岁时通过编写自己的程序来学习黑客。即使在大学课程中，你也主要通过黑客来学习黑客。[3]&lt;/p&gt;
&lt;p&gt;因为画家在他们身后留下了作品的痕迹，你可以看着他们通过做来学习。如果你按时间顺序看一位画家的作品，你会发现每幅画都建立在以前画中学到的东西的基础上。当一幅画中有某个东西效果很好时，你通常可以在一些早期绘画中以较小的形式找到它的版本1。&lt;/p&gt;
&lt;p&gt;我认为大多数创造者都是这样工作的。作家和建筑师似乎也是如此。也许黑客应该更像画家，定期从头开始，而不是继续在一个项目上工作多年，并试图将他们以后的想法作为修订纳入其中。&lt;/p&gt;
&lt;p&gt;黑客通过做来学习黑客这一事实是黑客与科学不同的另一个标志。科学家不是通过做科学来学习科学，而是通过做实验和解决问题集。科学家开始做的工作是完美的，在这个意义上说，他们只是试图重现别人已经为他们做过的工作。最终，他们达到可以做原创工作的地步。而黑客从一开始就在做原创工作；只是非常糟糕。所以黑客从原创开始，然后变好，科学家从好开始，然后变原创。&lt;/p&gt;</description></item><item><title>为什么 Arc 不是特别面向对象的</title><link>https://linguista.cn/person/paul_graham/essays_zh/noop/</link><pubDate>Mon, 01 Oct 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/noop/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/noop/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/noop.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/noop.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/noop.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="为什么-arc-不是特别面向对象的"&gt;为什么 Arc 不是特别面向对象的&lt;/h1&gt;
&lt;p&gt;目前有一种对面向对象编程的狂热，但我认识的一些最聪明的程序员是对此最不兴奋的人。&lt;/p&gt;
&lt;p&gt;我自己的感觉是，面向对象编程在某些情况下是一种有用的技术，但它不是必须渗透到你写的每个程序中的东西。你应该能够定义新类型，但不必将每个程序都表达为新类型的定义。&lt;/p&gt;
&lt;p&gt;我认为人们喜欢面向对象编程有五个原因，其中三个半是坏的：&lt;/p&gt;
&lt;p&gt;如果你有一个静态类型的语言，没有词法闭包或宏，面向对象编程是令人兴奋的。在某种程度上，它提供了一种绕过这些限制的方法。（见 Greenspun 第十规则。）&lt;/p&gt;
&lt;p&gt;面向对象编程在大公司很受欢迎，因为它适合他们编写软件的方式。在大公司，软件往往由大量（且经常变动的）平庸程序员团队编写。面向对象编程对这些程序员施加了一种纪律，防止任何一个人造成太大的损害。代价是产生的代码充满了协议和重复。这对大公司来说不是太高的价格，因为他们的软件无论如何都可能是臃肿和充满重复的。&lt;/p&gt;
&lt;p&gt;面向对象编程产生了很多看起来像工作的东西。在折叠纸的时代，有一种程序员只会在一页上放五到十行代码，前面是二十行精心格式化的注释。面向对象编程对这些来说就像可卡因：它让你将所有这些脚手架直接整合到源代码中。Lisp 黑客可能通过将符号推到列表上来处理的东西，变成了整个类的文件和方法。所以如果你想说服自己或其他人你正在做很多工作，这是一个好工具。&lt;/p&gt;
&lt;p&gt;如果语言本身是一个面向对象的程序，它可以被用户扩展。嗯，也许。或者也许你可以通过提供面向对象编程的子概念单点来做得更好。例如，重载本质上并不与类绑定。我们拭目以待。&lt;/p&gt;
&lt;p&gt;面向对象的抽象很好地映射到某些特定类型程序的领域，比如模拟和 CAD 系统。&lt;/p&gt;
&lt;p&gt;我个人从来不需要面向对象的抽象。Common Lisp 有一个极其强大的对象系统，我从未使用过一次。我做过很多事情（例如，制作充满闭包的哈希表），这些在较弱的语言中需要面向对象技术，但我从未不得不使用 CLOS。&lt;/p&gt;
&lt;p&gt;也许我只是很愚蠢，或者只在应用程序的有限子集上工作过。基于自己的编程经验设计语言是有危险的。但放入你从未需要的东西因为它被认为是个好主意似乎更危险。&lt;/p&gt;</description></item></channel></rss>