<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>简洁性 on Linguista</title><link>https://linguage.github.io/tags/%E7%AE%80%E6%B4%81%E6%80%A7/</link><description>Recent content in 简洁性 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 07 Jun 2007 22:12:07 +0000</lastBuildDate><atom:link href="https://linguage.github.io/tags/%E7%AE%80%E6%B4%81%E6%80%A7/index.xml" rel="self" type="application/rss+xml"/><item><title>不要过度优化</title><link>https://linguage.github.io/terencetao/writing-guide/zh/dont-overoptimise.zh/</link><pubDate>Thu, 07 Jun 2007 22:12:07 +0000</pubDate><guid>https://linguage.github.io/terencetao/writing-guide/zh/dont-overoptimise.zh/</guid><description>&lt;p&gt;&lt;a href="https://linguage.github.io/terencetao/writing-guide/en/dont-overoptimise/"&gt;原文(English)&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]"
 data-url="https://terrytao.wordpress.com/advice-on-writing-papers/dont-overoptimise/"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline"
 href="https://terrytao.wordpress.com/advice-on-writing-papers/dont-overoptimise/"
 target="_blank"
 rel="noopener"
 &gt;
 https://terrytao.wordpress.com/advice-on-writing-papers/dont-overoptimise/
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="不要过度优化"&gt;不要过度优化&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;我们应该忘记那些小的效率，大约 97% 的时间是这样：过早的优化是万恶之源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;唐纳德·克努斯，《文学编程》，转述托尼·霍尔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href="https://linguage.github.io/terencetao/writing-guide/on-writing.zh/"&gt;我所有关于如何写论文的其他建议&lt;/a&gt;之后，我应该补充一个平衡性的说明：存在一种&lt;em&gt;过于&lt;/em&gt;完美主义的危险，即试图让论文的每个部分都尽可能&amp;quot;最优&amp;quot;。在论文的所有&amp;quot;简单&amp;quot;改进都完成后，人们会遇到收益递减规律，任何进一步的改进要么需要大量的时间和精力，要么需要在论文的其他品质上做出一些权衡。&lt;/p&gt;
&lt;p&gt;例如，假设一个人有一个足以证明当前论文主要定理的可用引理。然后可以尝试通过使假设更弱、结论更强来&amp;quot;优化&amp;quot;这个引理，但这可能会以延长引理证明为代价，并模糊引理与论文其余部分的契合方式。相反方向，也可以通过用一个更弱（但更容易证明）的陈述来替换同一个引理，该陈述仍然勉强足以证明主要定理，但现在不适合在任何后续应用中使用。因此，当试图在一个方向或另一个方向上改进引理时，会遇到权衡。（在这种情况下，解决这种权衡的一种方法是陈述并证明引理的一种表述，然后添加关于另一种表述的备注，即陈述强版本并备注我们只使用特殊情况，或者陈述弱版本并备注可能存在更强版本。）&lt;/p&gt;
&lt;p&gt;精心优化结果和符号，希望这将有助于该领域未来的研究人员，这有点冒险；后来的作者可能会引入新的见解或新工具，使这些精心优化的结果过时。只有当您已经知道后续论文（可能是您正在撰写的论文的续篇）确实会严重依赖这些结果和符号时，或者当当前论文显然将在很长一段时间内成为该主题的权威论文时，这才真正有利可图。&lt;/p&gt;
&lt;p&gt;如果您还没有为论文写过&lt;a href="https://linguage.github.io/terencetao/writing-guide/zh/write-a-rapid-prototype-first.zh/"&gt;快速原型&lt;/a&gt;，那么优化引理实际上可能是完全浪费时间，因为在写作过程的后期您可能会发现，为了处理原始论证中未预见到的故障，或者为了改进论文的整体组织，引理无论如何都需要修改。&lt;/p&gt;
&lt;p&gt;我有时看到作者试图以牺牲所有其他属性为代价来优化论文的长度，错误地认为简洁等同于简单。虽然较短的论文可能比较长的论文更简单，但这通常只有在论文的简短是&lt;em&gt;自然&lt;/em&gt;实现而不是人为实现的情况下才成立。如果通过删除所有示例、备注、空白、动机和讨论，或者通过删除&amp;quot;冗余&amp;quot;&lt;a href="https://linguage.github.io/terencetao/writing-guide/zh/take-advantage-of-the-english-language.zh/"&gt;英语短语&lt;/a&gt;并纯粹依赖数学缩写（例如用 ∀ 代替&amp;quot;对于所有&amp;quot;等）和各种不合语法的缩略语来实现简洁，那么这通常是一个糟糕的权衡；有点讽刺的是，过度压缩的论文可能被读者认为比更长、更温和、更从容地处理相同材料的论文&lt;em&gt;更难&lt;/em&gt;阅读。（另请参阅&amp;quot;&lt;a href="https://linguage.github.io/terencetao/writing-guide/zh/give-appropriate-amounts-of-detail.zh/"&gt;提供适量的细节&lt;/a&gt;&amp;quot;。）&lt;/p&gt;
&lt;p&gt;另一方面，优化论文的&lt;em&gt;可读性&lt;/em&gt;总是一件好事（除非以严谨性或准确性为代价），为此付出的努力会受到读者的赞赏。&lt;/p&gt;</description></item><item><title>简洁即力量</title><link>https://linguage.github.io/paul_graham/essays_zh/power/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguage.github.io/paul_graham/essays_zh/power/</guid><description>&lt;p&gt;→ &lt;a href="https://linguage.github.io/paul_graham/essays_en/power/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]"
 data-url="https://www.paulgraham.com/power.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/power.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/power.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="简洁即力量"&gt;简洁即力量&lt;/h1&gt;
&lt;p&gt;2002年5月&lt;/p&gt;
&lt;p&gt;&amp;ldquo;通过代数符号将大量意义压缩到一个小空间中，这是另一个有助于我们习惯性推理的因素。&amp;rdquo; - 查尔斯·巴贝奇，引自艾弗森的图灵奖演讲&lt;/p&gt;
&lt;p&gt;在LL1邮件列表上关于《书呆子的复仇》所提出问题的讨论中，保罗·普雷斯科德写了一些让我印象深刻的话。Python的目标是规范性和可读性，而不是简洁性。表面上看来，这对编程语言来说似乎是一个相当不利的评价。据我所知，简洁性=力量。如果是这样，那么替换后我们得到Python的目标是规范性和可读性，而不是力量。这似乎不是一个你想要做出的权衡（如果这确实是一个权衡的话）。这几乎等同于说Python的目标不是作为一种有效的编程语言。&lt;/p&gt;
&lt;p&gt;简洁性等于力量吗？在我看来，这是一个重要的问题，可能是对任何对语言设计感兴趣的人来说最重要的问题，直接面对这个问题会很有用。我还不确定答案是否是简单的&amp;quot;是&amp;quot;，但这似乎是一个很好的开始假设。&lt;/p&gt;
&lt;h2 id="假设"&gt;假设&lt;/h2&gt;
&lt;p&gt;我的假设是简洁性就是力量，或者足够接近，除了在病态的例子中，你可以将它们视为相同。&lt;/p&gt;
&lt;p&gt;在我看来，简洁性就是编程语言的意义所在。计算机对于直接用机器语言被告知要做什么同样满意。我认为我们开发高级语言的主要原因是获得杠杆作用，这样我们就可以用高级语言的10行代码来表达（更重要的是思考）需要1000行机器语言才能完成的事情。换句话说，高级语言的主要目的是使源代码更小。&lt;/p&gt;
&lt;p&gt;如果更小的源代码是高级语言的目的，而某种东西的力量是它实现其目的的程度，那么编程语言力量的衡量标准就是它使你的程序变得多小。&lt;/p&gt;
&lt;p&gt;相反，不能使你的程序更小的语言在编程语言应该做的事情上做得不好，就像一把不好切的刀或难以辨认的印刷品。&lt;/p&gt;
&lt;h2 id="衡量标准"&gt;衡量标准&lt;/h2&gt;
&lt;p&gt;但是从什么意义上来说更小呢？代码大小最常见的衡量标准是代码行数。但我认为这个衡量标准最常见是因为它最容易测量。我不认为有人真正相信它是程序长度的真正测试。不同的语言对于在一行中放多少内容有不同的约定；在C语言中，很多行只有一个或两个分隔符。&lt;/p&gt;
&lt;p&gt;另一个简单的测试是程序中的字符数，但这也不是很好；一些语言（例如Perl）只是使用比其他语言更短的标识符。&lt;/p&gt;
&lt;p&gt;我认为程序大小的更好衡量标准是元素的数量，其中元素是如果你画一个表示源代码的树，会成为不同节点的任何东西。变量或函数的名称是一个元素；整数或浮点数是一个元素；一段字面文本是一个元素；模式元素或格式指令是一个元素；新块是一个元素。有一些边界情况（-5是两个元素还是一个？）但我认为大多数情况对每种语言都是相同的，所以它们不会对比较产生太大影响。&lt;/p&gt;
&lt;p&gt;这个衡量标准需要充实，在特定语言的情况下可能需要解释，但我认为它试图衡量正确的东西，即程序拥有的部分数量。我认为在这个练习中你会画的树就是你为了构思程序而必须在头脑中构建的东西，它的大小与你必须做的工作量成正比，无论是写还是读。&lt;/p&gt;
&lt;h2 id="设计"&gt;设计&lt;/h2&gt;
&lt;p&gt;这种衡量标准可以让我们比较不同的语言，但至少对我而言，这不是它的主要价值。简洁性测试的主要价值是作为设计语言的指导。语言之间最有用的比较是同一种语言的两个潜在变体之间的比较。我能在语言中做什么来使程序更短？&lt;/p&gt;
&lt;p&gt;如果程序的概念负荷与其复杂性成正比，而给定的程序员可以容忍固定的概念负荷，那么这与问&amp;quot;我能做什么来让程序员完成最多工作？&amp;ldquo;是相同的。这在我看来与问&amp;quot;我如何设计一种好的语言？&amp;ldquo;是相同的。&lt;/p&gt;
&lt;p&gt;（顺便说一句，没有什么比设计语言更能明显地证明&amp;quot;所有语言都是等价的&amp;quot;这个老生常谈是错误的了。当你设计一种新语言时，你不断地比较两种语言——如果我做了x的语言，如果我没做x的语言——来决定哪个更好。如果这真是一个无意义的问题，你不妨抛硬币。）&lt;/p&gt;
&lt;p&gt;以简洁性为目标似乎是寻找新想法的好方法。如果你能做一些让许多不同程序更短的事情，这可能不是巧合：你可能发现了一个有用的新抽象。你甚至可以编写一个程序来帮助搜索源代码中的重复模式。在其他语言中，那些以简洁性著称的语言是寻找新想法的地方：Forth、Joy、Icon。&lt;/p&gt;
&lt;h2 id="比较"&gt;比较&lt;/h2&gt;
&lt;p&gt;据我所知，第一个写这些相关文章的人是弗雷德·布鲁克斯在《人月神话》中。他写道，无论使用什么语言，程序员每天似乎生成大致相同数量的代码。我在二十出头第一次读到这个时，这是一个很大的惊喜，似乎有巨大的含义。这意味着（a）让软件写得更快的方法是使用更简洁的语言，（b）花功夫这样做的人可以把不这样做的竞争对手远远甩在后面。&lt;/p&gt;
&lt;p&gt;布鲁克斯的假设，如果它是真的，似乎处于黑客精神的核心。从那以后的几年里，我密切关注我能得到的关于这个问题的任何证据，从正式研究到个人项目的轶事。我没有看到任何与他相矛盾的证据。&lt;/p&gt;
&lt;p&gt;我还没有看到我认为决定性的证据，我也不期望看到。像卢茨·普雷克特尔对编程语言的比较这样的研究，虽然产生了我期望的那种结果，但往往使用太短的问题，无法成为有意义的测试。语言的更好测试是在需要一个月编写的程序中发生什么。而真正的测试，如果你像我一样相信语言的主要目的是为了便于思考（而不仅仅是在你思考完后告诉计算机要做什么），是你能用它写出什么新东西。所以任何需要满足预定义规范的语言比较都在测试稍微错误的东西。&lt;/p&gt;
&lt;p&gt;语言的真正测试是你发现和解决新问题的能力，而不是你用它解决别人已经制定的问题的能力。这是两个完全不同的标准。在艺术中，像刺绣和马赛克这样的媒介，如果你事先知道你想制作什么，效果很好，但如果你不知道，就绝对糟糕。当你想在制作过程中发现图像时——就像你必须处理像人物图像这样复杂的东西一样——你需要使用更流动的媒介，如铅笔、水墨或油画。实际上，挂毯和马赛克的制作方式是先制作一幅画，然后复制它。（&amp;ldquo;卡通&amp;quot;这个词最初用来描述用于这个目的的画。）&lt;/p&gt;
&lt;p&gt;这意味着我们永远不可能对编程语言的相对力量有准确的比较。我们会有精确的比较，但不会有准确的比较。特别是，为了比较语言而进行的明确研究，因为它们可能会使用小问题，并且必须使用预定义的问题，往往会低估更强大语言的力量。&lt;/p&gt;
&lt;p&gt;来自现场的报告，虽然它们必然不如&amp;quot;科学&amp;quot;研究精确，但可能更有意义。例如，爱立信的乌尔夫·维格进行了一项研究，结论是Erlang比C++简洁4-10倍，开发软件的速度也相应更快：爱立信内部开发项目之间的比较表明，包括软件开发的所有阶段在内的每行/小时生产力相似，几乎与使用的语言（Erlang、PLEX、C、C++或Java）无关。区分不同语言的成为源代码量。该研究还明确处理了布鲁克斯书中只是隐含的一点（因为他测量的是调试代码的行数）：用更强大语言编写的程序往往有更少的错误。这本身就成为一个目的，在网络交换机等应用中，可能比程序员的生产力更重要。&lt;/p&gt;
&lt;h2 id="味道测试"&gt;味道测试&lt;/h2&gt;
&lt;p&gt;最终，我认为你必须凭直觉行事。用这种语言编程感觉如何？我认为找到（或设计）最好语言的方法是对语言让你思考的出色程度变得高度敏感，然后选择/设计感觉最好的语言。如果某些语言功能笨拙或限制性，别担心，你会知道的。&lt;/p&gt;
&lt;p&gt;这种高度敏感是有代价的。你会发现你无法忍受在笨拙的语言中编程。我觉得在没有宏的语言中编程是无法忍受的限制性，就像习惯动态类型的人发现必须回到必须声明每个变量类型、不能制作不同类型对象列表的语言中编程是无法忍受的限制性一样。我不是唯一一个这样的人。我知道许多Lisp黑客都经历过这种情况。事实上，编程语言相对力量的最准确衡量标准可能是了解该语言的人愿意接受任何使用该语言的工作的百分比，不管应用领域如何。&lt;/p&gt;
&lt;h2 id="限制性"&gt;限制性&lt;/h2&gt;
&lt;p&gt;我认为大多数黑客都知道语言感觉限制性是什么意思。当你有这种感觉时发生了什么？我认为这与当你想走的街道被封锁，你必须绕很长的路才能到达你想去的地方时的感觉相同。你有想说的话，但语言不允许你说。&lt;/p&gt;
&lt;p&gt;这里真正发生的事情，我认为，是限制性语言是一种不够简洁的语言。问题不仅仅是你不能说你计划说的话。而是语言让你绕的弯路更长。试试这个思维实验。假设你想写某个程序，语言不允许你按计划的方式表达它，而是强迫你用某种更短的方式写程序。至少对我来说，这不会感觉很有限制性。这就像你想走的街道被封锁，十字路口的警察给你指了一条捷径而不是绕路。太好了！&lt;/p&gt;
&lt;p&gt;我认为限制性的感觉大部分（百分之九十？）来自于被迫使你在语言中写的程序比你头脑中的更长。限制性主要是缺乏简洁性。所以当一种语言感觉有限制性时，这（大部分）意味着它不够简洁，而当一种语言不够简洁时，它会感觉有限制性。&lt;/p&gt;
&lt;h2 id="可读性"&gt;可读性&lt;/h2&gt;
&lt;p&gt;我开始引用的引言提到了另外两个品质，规范性和可读性。我不确定性规范性是什么，或者规范和可读的代码比仅仅可读的代码有什么优势，如果有的话。但我想我知道可读性是什么意思，我认为它也与简洁性有关。&lt;/p&gt;
&lt;p&gt;我们必须小心区分单行代码的可读性和整个程序的可读性。重要的是后者。我同意Basic的一行代码可能比Lisp的一行代码更易读。但用Basic编写的程序行数会比用Lisp编写的相同程序多（特别是当你进入格林斯彭之地时）。阅读Basic程序的总工作量肯定会更大。总工作量 = 每行工作量 × 行数&lt;/p&gt;
&lt;p&gt;我不像确信力量与简洁性成正比那样确信可读性与简洁性成正比，但简洁性肯定是可读性的一个因素（在数学意义上；见上面的公式）。所以，说语言的目标是可读性而不是简洁性可能甚至没有意义；这就像说目标是可读性，而不是可读性。&lt;/p&gt;
&lt;p&gt;每行可读性对第一次遇到语言的用户来说，意味着源代码看起来不具威胁性。所以每行可读性可能是一个好的营销决策，即使它是一个糟糕的设计决策。它与让人们分期付款的非常成功的技术同构：不是用高昂的前期价格吓唬他们，而是告诉他们低月付款。分期付款对买方来说是净亏损，而每行可读性对程序员来说可能也是如此。买方将进行很多很多低月付款；而程序员将阅读很多很多单独可读的行。&lt;/p&gt;
&lt;p&gt;这种权衡比编程语言更早。如果你习惯于阅读小说和报纸文章，你第一次阅读数学论文的经历可能会令人沮丧。阅读一页可能需要半小时。然而，我很确定符号不是问题，尽管感觉上可能是。数学论文难读是因为思想难。如果你用散文表达相同的思想（正如数学家在发展出简洁的符号之前必须做的那样），它们不会更容易读，因为论文会增长到一本书的大小。&lt;/p&gt;</description></item></channel></rss>