<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>介绍 on Linguista</title><link>https://linguage.github.io/tags/%E4%BB%8B%E7%BB%8D/</link><description>Recent content in 介绍 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://linguage.github.io/tags/%E4%BB%8B%E7%BB%8D/index.xml" rel="self" type="application/rss+xml"/><item><title>ANSI Common Lisp 简介</title><link>https://linguage.github.io/paul_graham/essays_zh/acl1txtt1748944359/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguage.github.io/paul_graham/essays_zh/acl1txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguage.github.io/paul_graham/essays_en/acl1txtt1748944359/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="ansi-common-lisp-简介"&gt;ANSI Common Lisp 简介&lt;/h1&gt;
&lt;p&gt;ANSI Common Lisp 简介&lt;/p&gt;
&lt;p&gt;（这是Paul Graham的《ANSI Common Lisp》一书的第一章。版权1995年，Prentice-Hall。）&lt;/p&gt;
&lt;h2 id="介绍"&gt;介绍&lt;/h2&gt;
&lt;p&gt;John McCarthy和他的学生于1958年开始在第一个Lisp实现上工作。除了Fortran之外，Lisp是仍在使用的最古老的语言。[1] 更值得注意的是，它仍然处于编程语言技术的前沿。了解Lisp的程序员会告诉你，这种语言有某种独特之处。&lt;/p&gt;
&lt;p&gt;Lisp的独特之处部分在于它被设计为可进化的。你可以使用Lisp来定义新的Lisp操作符。当新的抽象变得流行时（例如面向对象编程），事实证明在Lisp中实现它们总是很容易的。像DNA这样的语言不会过时。&lt;/p&gt;
&lt;h2 id="新工具"&gt;新工具&lt;/h2&gt;
&lt;p&gt;为什么学习Lisp？因为它让你做其他语言做不到的事情。如果你只是想写一个返回小于n的数字之和的函数，在Lisp和C中看起来会非常相似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun sum (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (&lt;span style="color:#66d9ef"&gt;let&lt;/span&gt; ((s &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (dotimes (i n s)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (incf s i))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/* C */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sum&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; n){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i, s &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; s &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你只需要做这样的简单事情，你使用哪种语言并不重要。假设相反，你想写一个函数，它接受一个数字n，并返回一个将n加到其参数上的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun addn (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;#&amp;#39;&lt;/span&gt;(lambda (x) (&lt;span style="color:#a6e22e"&gt;+&lt;/span&gt; x n)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addn在C中是什么样的？你根本写不出来。&lt;/p&gt;
&lt;p&gt;你可能会想知道，什么时候有人会想做这样的事情？编程语言教会你不要渴望它们不能提供的东西。你必须用一种语言思考才能用其编写程序，很难渴望你无法描述的东西。当我开始编写程序时——使用Basic——我不想念递归，因为我不知道有这样的东西。我用Basic思考。我只能构想迭代算法，为什么要想念递归？&lt;/p&gt;
&lt;p&gt;如果你不怀念词法闭包（这就是前面例子中制作的东西），暂时相信Lisp程序员一直使用它们。很难找到任何长度的Common Lisp程序不利用闭包。到第112页，你自己也会使用它们。而闭包只是我们在其他语言中找不到的抽象之一。&lt;/p&gt;</description></item></channel></rss>