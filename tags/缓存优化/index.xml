<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>缓存优化 on Linguista</title><link>https://linguista.cn/tags/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</link><description>Recent content in 缓存优化 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 22 Jan 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>静态搜索树比二分搜索快40倍</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/static-search-trees-faster-binary-search/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/static-search-trees-faster-binary-search/</guid><description>&lt;h1 id="静态搜索树比二分搜索快40倍"&gt;静态搜索树：比二分搜索快40倍&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文详细介绍了如何通过一系列优化技术，将静态有序数组的搜索性能从传统二分搜索的1150ns优化至27ns，实现超过40倍的性能提升。文章从缓存行优化、SIMD向量化、预取技术、内存布局改进等多个维度展开，深入探讨了S+树（S-tree）的设计与实现，并展示了在生物信息学基因索引等实际场景中的应用价值。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先明确了问题场景：给定一个静态的排序32位无符号整数数组，需要高效查询返回不小于给定值的最小元素。这是一个典型的静态搜索问题，常见于后缀数组索引、数据库索引等场景。作者以生物信息学中的DNA索引为动机背景——单个人类基因组包含30亿碱基对，需要高效的静态数据结构进行快速查询。&lt;/p&gt;
&lt;p&gt;接着，文章系统性地介绍了优化路径。第一步是理解硬件特性：CPU以64字节缓存行为单位工作，传统二分搜索和Eytzinger布局在每个缓存行中只使用一个值，内存带宽利用率极低。第二步是优化节点内的查找操作：从线性扫描开始，逐步引入自动向量化、尾随零计数、Popcount、手动SIMD等技术。第三步是优化搜索过程本身：通过批处理查询、预取下一节点、减少指针算术开销、交错处理多层查询等手段提升吞吐量。&lt;/p&gt;
&lt;p&gt;在树布局优化方面，文章探讨了左树布局（存储左子树最大值而非右子树最小值）、反向存储、全数组存储等方案，并确定了节点大小B=15（分支因子16）为较优选择。更进一步，文章介绍了前缀分区技术：将值按前缀分为多个部分，每个部分构建独立搜索树，包括完全布局、紧凑子树、混合方案、重叠树等变体。在人类基因组数据上的测试显示，分区方法可以进一步提升性能。&lt;/p&gt;
&lt;p&gt;最终，通过多线程并行，查询时间可从27ns进一步降至7ns，但此时性能瓶颈转移到了总RAM带宽。文章总结了完整的优化路径，并展望了分支搜索、插值搜索、数据压缩、范围查询等未来工作方向。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Eytzinger布局&lt;/strong&gt;：一种数组重排策略，将完全二叉树的节点按广度优先顺序存储，使得根节点位于中间位置，其子节点分别位于1/4和3/4位置，以此类推。这种布局使得二分搜索路径上的元素在内存中更加紧凑，提高了缓存命中率，是后续S+树优化的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S+树（S-tree）&lt;/strong&gt;：B树与Eytzinger布局的混合数据结构。内部节点存储多个键值（通常B=15，分支因子16）用于分支选择，所有实际值存储在叶子节点中并在内部节点重复。它兼顾了B树的高分支因子（减少树高度）和Eytzinger布局的缓存友好性，是静态搜索场景下的高效选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SIMD向量化&lt;/strong&gt;：单指令多数据流技术的应用。在节点内查找时，不是逐个比较，而是使用AVX2/AVX-512等指令集同时比较16个或更多值，将比较结果转为位掩码，通过尾随零计数或popcount指令快速定位目标位置。这充分利用了现代CPU的并行计算能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预取与批处理&lt;/strong&gt;：CPU在执行当前操作的同时，提前从内存加载即将需要的数据到缓存中。通过同时处理多个查询（批处理），CPU可以在等待一个查询的内存访问完成时，继续处理其他查询，从而隐藏内存延迟，提高整体吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前缀分区&lt;/strong&gt;：将整个值空间按高位前缀分为多个区间，每个区间构建独立的搜索树。这样第一层只需找到正确的分区树，后续搜索在较小的树上进行。对于非均匀分布的数据，可以通过前缀映射表平衡各分区大小，进一步提升缓存局部性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://curiouscoding.nl/posts/static-search-tree/"&gt;Static search trees: 40x faster than binary search&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Curious Coding&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>