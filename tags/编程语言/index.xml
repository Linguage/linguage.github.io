<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言 on Linguista</title><link>https://linguista.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 编程语言 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Python创始人Guido van Rossum与开源传奇</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/python-founder-guido-van-rossum-documentary/</link><pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/python-founder-guido-van-rossum-documentary/</guid><description>&lt;h1 id="python创始人guido-van-rossum与开源传奇"&gt;Python创始人Guido van Rossum与开源传奇&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本纪录片回顾了Python编程语言从上世纪90年代初在荷兰阿姆斯特丹的一个科研所诞生，到成长为全球最受欢迎的编程语言的全过程。主线聚焦于Guido van Rossum（吉多·范罗苏姆）等核心人物的经历，剖析Python的设计理念、社区文化、开放源代码的波折、中途险些夭折的危机，以及它如何推动人工智能、数据科学和互联网企业蓬勃发展。纪录片最终总结，Python之所以能改变世界，除了简单优雅的语言本身，更源于一个包容、共享、富有乐趣和责任感的社区。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;Python的起源可以追溯到Guido van Rossum在荷兰CWI研究所参与的ABC项目。这个旨在面向非专业技术人员普及编程知识的项目虽因传播局限和管理层原因未能成功，但让Guido深刻体会到现有语言的繁琐和高门槛。在后续参与Amoeba分布式操作系统开发时，他发现C语言不利于快速开发，ABC又过于抽象，因此萌生了创造一门兼具脚本语言便利和底层交互能力新语言的想法。1989年圣诞期间，Guido用&amp;quot;休假项目&amp;quot;的心态着手创造Python，沿用ABC的缩进控制语句分组特色，名字来源于Monty Python英国喜剧团体，寓意编程应当有趣。&lt;/p&gt;
&lt;p&gt;Python通过Usenet早期网络公告板分发出去，全球开发者通过电子邮件和Usenet反馈推动语言迭代。1994年在美国NIST举办的首届Python研讨会，20多位用户线下交流奠定了社区基调。Guido受邀加入美国CNRI机构后，Python.org等基础设施诞生，他也获得了&amp;quot;BDFL&amp;quot;（终身仁慈独裁者）称号，成为最终技术决策者。Python Software Foundation（PSF）的成立保证了语言的独立性，不会被任何公司把持。&lt;/p&gt;
&lt;p&gt;Python的核心理念体现在Tim Peters总结的&amp;quot;Zen of Python&amp;quot;中，包括&amp;quot;优美胜于丑陋&amp;quot;、&amp;ldquo;简单优于复杂&amp;rdquo;、&amp;ldquo;可读性很重要&amp;quot;等原则。这些理念深深影响了语言设计和社区氛围。Python之所以能持续强劲增长，是因为从Web开发（Dropbox、YouTube）、数据科学（Anaconda）到AI/ML（TensorFlow、PyTorch）每一波技术浪潮都选择了Python作为核心接口。最典型的危机是Python 2到Python 3的大规模迁移，&amp;ldquo;破坏性升级&amp;quot;带来社区分裂，但在大公司示范带动下最终完成统一。&lt;/p&gt;
&lt;p&gt;Python社区刻意推动多元化与包容性，PyCon会议女性演讲者比例从最初的1%跃升到33%-40%。PyLadies、Mentorship计划等组织培养了女性核心开发者，给初学者、非专业开发者、科学家提供平等友善的沟通氛围。在治理方面，Python从个人掌舵（BDFL）过渡为五人&amp;quot;转型指导委员会&amp;rdquo;，通过PEP（Python增强提案）机制实现民主透明决策。语言进化哲学强调拒绝对向后兼容的教条执守，注重实践驱动，社区主导自下而上，包容失败鼓励冒险。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BDFL（终身仁慈独裁者）&lt;/strong&gt;：Python早期治理模式，Guido van Rossum作为最终技术决策者，不设冗余组织，倡导自由创新，一人拍板。这种模式保证了语言发展的连贯性和决策效率，同时也要求领导者具有高度的责任感和社区信任。后来这一模式演变为五人指导委员会，实现更加民主的治理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python之禅（Zen of Python）&lt;/strong&gt;：由Tim Peters以幽默诗歌方式总结的Python设计哲学，包括&amp;quot;优美胜于丑陋&amp;rdquo;、&amp;ldquo;简单优于复杂&amp;rdquo;、&amp;ldquo;可读性很重要&amp;rdquo;、&amp;ldquo;应有一种明显的办法&amp;quot;等原则。这些理念不仅影响语言功能设计，也塑造了库开发风格和社区交流氛围，让Python特别适合科学计算、AI等需要高度合作透明的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PEP（Python增强提案）&lt;/strong&gt;：Python的核心决策机制，通过民主、透明的提案流程让社区充分讨论重大变革。每一次重大决策都留下详细文档，历史可追溯。这种机制平衡了创新灵活性和社区参与度，成为Python持续进化的重要制度保障。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包容性社区文化&lt;/strong&gt;：Python社区刻意推动多元化，从性别、年龄、专业背景等多方面提升包容性。PyCon女性演讲者比例从1%提升到40%，PyLadies等组织培养边缘群体开发者。这种包容性不仅体现在人口统计学特征，更侧重于给初学者和非专业开发者提供友善的沟通氛围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实践驱动进化&lt;/strong&gt;：Python从不承诺&amp;quot;永远不变&amp;rdquo;，而是不断吸纳需求变化，拥抱生态多样性。重点关注&amp;quot;实际需求&amp;quot;和&amp;quot;可用解决方案&amp;quot;，而非为创新而创新。典型如数据科学、AI兴起时社区迅速拥抱新方向，体现了语言的实用主义导向和适应能力。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0"&gt;Python: The Documentary | An origin story&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;CultRepo制作团队（核心人物Guido van Rossum等）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>为什么选择 Clojure</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/why-clojure-economy-of-expression/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/why-clojure-economy-of-expression/</guid><description>&lt;h1 id="为什么选择-clojure"&gt;为什么选择 Clojure&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文作者回顾了自己五十年来使用过的众多编程语言，最终认为 Lisp，尤其是 Clojure，是最简洁、最优雅、最易用的编程语言。作者认为 Clojure 的&amp;quot;表达经济性&amp;quot;远超其他语言，极简的语法让开发者能够用更少的代码、更少的精力，清晰直接地表达问题和解决方案。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇，作者介绍了自己丰富的编程语言经历。在长达五十年的编程生涯中，他曾使用过汇编、Java、Fortran、COBOL、PL/1、C、Pascal、C++、Lua、Smalltalk、Logo 等几十种语言，涵盖静态类型、动态类型、无类型、栈式、逻辑式等多种范式。最初作者并不喜欢 Lisp，认为其语法过于学术化。十年前，通过接触《SICP》并发现 Clojure，作者经历了数年的摸索和挫折，才逐渐体会到 Clojure 的简洁和优雅。&lt;/p&gt;
&lt;p&gt;作者将选择 Clojure 的核心理由概括为&amp;quot;表达经济性&amp;quot;。Clojure 的语法极简，几乎没有任何语法规则，开发者可以用更少的代码表达复杂问题，减少了&amp;quot;语法体操&amp;quot;。通过与 Java 代码的对比，作者展示了 Clojure 的简洁性优势。&lt;/p&gt;
&lt;p&gt;在文章的后半部分，作者回应了关于 Clojure 的常见质疑，包括括号太多、性能问题、与 JavaScript 的兼容性、动态类型问题、IDE 支持、重构能力、与 Java 的互操作性、开发者来源、新语言竞争等。作者认为 Clojure 的极简语法不仅适合小型项目，更适合构建大型系统，开发效率和可维护性远超 Java、C++。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;表达经济性（Economy of Expression）&lt;/strong&gt;：这是作者选择 Clojure 的核心理由。表达经济性意味着用最少的语法和代码表达最复杂的逻辑。Clojure 的极简语法让开发者能够用更少的代码、更少的精力，清晰直接地表达问题和解决方案。作者强调，Clojure 几乎没有语法或语法规则，这大大降低了思维负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极简语法&lt;/strong&gt;：Clojure 的语法极简，几乎可以用几条规则覆盖所有情况。&lt;code&gt;(&lt;/code&gt; 表示开始一个列表，&lt;code&gt;)&lt;/code&gt; 表示结束最近的未闭合列表，名称即函数名，&lt;code&gt;*&lt;/code&gt; 是乘法函数，&lt;code&gt;#&lt;/code&gt; 表示后面的列表是一个匿名函数，&lt;code&gt;%&lt;/code&gt; 表示匿名函数的第一个参数，&lt;code&gt;defn&lt;/code&gt; 用于定义新函数，&lt;code&gt;[]&lt;/code&gt; 表示向量。这些简单的规则已经涵盖了 Clojure 80% 的语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;：作者认为未来属于函数式编程，而 Lisp 天生函数式。Clojure 作为一种 Lisp 方言，继承了这一特性。函数式编程的不可变性、高阶函数等特性，使得代码更加简洁、可维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态类型与测试&lt;/strong&gt;：作者认为动态类型系统配合测试和 &lt;code&gt;clojure/spec&lt;/code&gt; 库，可以实现&amp;quot;设计契约&amp;quot;风格的开发，达到与静态类型系统相同甚至更高的代码质量。类型声明会增加语法复杂度，降低表达经济性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与 Java 生态的互操作性&lt;/strong&gt;：Clojure 运行在 Java 虚拟机上，可以直接调用 Java，Java 也能调用 Clojure，互操作性无障碍。这使得 Clojure 可以充分利用 Java 生态的丰富资源。&lt;/p&gt;</description></item><item><title>创新与数学的永恒价值编程语言的启示</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/innovation-math-programming-lisp-eternal-value/</link><pubDate>Tue, 11 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025_p2/innovation-math-programming-lisp-eternal-value/</guid><description>&lt;h1 id="创新与数学的永恒价值编程语言的启示"&gt;创新与数学的永恒价值：编程语言的启示&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以DeepSeek的创新突破为引子，通过保罗·格雷厄姆的经典文章《书呆子的复仇》，深入探讨了编程语言创新的本质。文章指出，尽管编程语言看似不断演进，但其根基——数学，具有永恒的价值。Lisp语言从数学理论演算诞生，至今仍对现代编程语言产生深远影响，揭示了技术创新的深层逻辑。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇以深圳公司DeepSeek的创始人梁文锋的采访切入，指出中国企业在创新领域的突破正在改变全球竞争格局。这一现象引出了一个更深层次的问题：什么才是真正的创新？作者通过编程语言的发展历程来回答这个问题。&lt;/p&gt;
&lt;p&gt;在软件行业中，经理与开发者之间常因技术选择产生冲突。经理们倾向于选择&amp;quot;业界标准&amp;quot;如Java，却忽视了编程语言之间的本质差异。Java语言的诞生本身就是对C++弱点的回应，这证明编程语言并非等价。不同语言的&amp;quot;酷&amp;quot;感反映了其设计哲学和功能特性的差异。&lt;/p&gt;
&lt;p&gt;从历史维度看，现代编程语言如Java、Perl、Python、Ruby都在设计上越来越接近Lisp。Lisp语言自1958年诞生以来，其影响力历久弥新，这与其数学本质密不可分。Lisp最初并非作为编程语言设计，而是基于数学理论演算，其核心&lt;code&gt;eval&lt;/code&gt;函数最初仅用于理论研究。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Lisp语言的数学本质&lt;/strong&gt;：Lisp并非作为实用编程语言诞生，而是源于数学理论演算。这种数学基础使其具有超越时代的永恒性，其设计理念至今仍影响着现代编程语言的发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程语言的演进方向&lt;/strong&gt;：Lisp和Fortran代表了编程语言发展的两大方向。Lisp从数学理论走向实践，Fortran从硬件架构走向高级抽象。现代语言的发展仍在努力接近Lisp的水平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创新与追随者的差异&lt;/strong&gt;：真正的创新并非简单地跟随&amp;quot;业界标准&amp;quot;，而是理解技术的本质。DeepSeek以创新者身份参与竞争，正是这种精神的体现。编程语言的历史表明，基于数学本质的创新具有持久价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;酷&amp;quot;感的本质&lt;/strong&gt;：不同编程语言的&amp;quot;酷&amp;quot;感反映了其灵活性和功能特性。Perl比Java&amp;quot;酷&amp;rdquo;，Python和Ruby更先进，这种感知背后是语言设计哲学的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术选择的本质&lt;/strong&gt;：经理们倾向选择&amp;quot;不会出错&amp;quot;的业界标准，但忽视了问题本身的特性。编程语言之间存在本质差异，选择合适的语言需要综合考虑问题的复杂性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mp.weixin.qq.com/s/R4pl0pJCI5MhKxIbaELF4w"&gt;书呆子的复仇：创新和数学一样永不过时&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;保罗·格雷厄姆&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-02-11&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>唐纳德克努斯与TeX系统的传奇历程</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/donald-knuth-tex-legend-yakshave/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/donald-knuth-tex-legend-yakshave/</guid><description>&lt;h1 id="唐纳德克努斯与tex系统的传奇历程"&gt;唐纳德克努斯与TeX系统的传奇历程&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文详细介绍了计算机科学先驱唐纳德克努斯与TeX排版系统的传奇故事。克努斯为排版其巨著《计算机编程艺术》第二版而发明TeX，在实现过程中展现了极致的&amp;quot;牦牛剃须&amp;quot;精神——为解决核心问题而创造了一系列相关工具和系统，包括WEB编程语言、文学编程范式、布局算法、Computer Modern字体、METAFONT字体描述语言等。文章不仅展现了克努斯在计算机科学多个领域的卓越成就，也探讨了TeX系统如何通过社区贡献持续演进，成为至今仍在广泛使用的排版系统。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以幽默的方式称克努斯为&amp;quot;牦牛剃须刀的守护神&amp;quot;，这一称呼源于他实现的TeX系统——一个完美且运行时间长的&amp;quot;牦牛剃须刀&amp;quot;项目。文章首先介绍了TeX的起源：克努斯在1970年代准备出版《计算机编程艺术》第二版时，对当时的排版质量极为不满，决定发明自己的排版系统。这套著作本身就是一个巨大的&amp;quot;牦牛剃须&amp;quot;项目，克努斯甚至为说明程序而发明了自己的计算机MIX和MIX汇编语言。&lt;/p&gt;
&lt;p&gt;文章的核心部分详细列举了TeX实现过程中的八重&amp;quot;牦牛剃须&amp;quot;：克努斯不仅发明了WEB编程语言（可转换为PASCAL），还创造了文学编程范式；他不仅实现了文本布局功能，还与Michael Plass共同提出了全新的布局算法；他不仅需要字体，还亲自设计了Computer Modern字体系列；他不仅需要字体创作工具，还编写了METAFONT字体描述语言及解释器；他提出了独特的版本控制方案，并避免了使用它；他实现了DVI输出格式。每一层都是为解决上一层问题而创造的新的&amp;quot;牦牛剃须&amp;quot;。&lt;/p&gt;
&lt;p&gt;文章后半部分探讨了社区对TeX的贡献和延续。Leslie Lamport创建了LaTeX，分离了表示和内容；后来又出现了ConTeXt等变体。面对现代技术需求（Unicode、现代字体格式、PDF输出等），社区创建了专门的TeX解释器，如pdflatex、xelatex、lualatex等。文章最后强调，TeX系统凝聚了克努斯多年的工作和知识，其特殊性质使其难以被简单替代，这也正是克努斯作为&amp;quot;牦牛剃须刀守护神&amp;quot;的真正意义。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;牦牛剃须&lt;/strong&gt;：源自Unix文化，比喻为了解决一个看似简单的问题，最终需要完成一系列先决任务，层层递进，仿佛要剃须得先养牦牛。克努斯的TeX项目是这一概念的极致体现——为排版一本书而创造了编程语言、编程范式、布局算法、字体、字体工具、输出格式等完整生态系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文学编程&lt;/strong&gt;：克努斯发明的编程范式，强调代码应像文学作品一样组织，便于人类阅读理解。WEB语言将Pascal代码和TeX文档混合在一起，源代码既是可执行程序又是技术文档，这一思想深刻影响了后来的文档生成工具和 literate programming 实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本控制哲学&lt;/strong&gt;：克努斯为TeX设计了独特的版本编号方案——从版本3开始，每次更新逼近π的下一个数字位（当前为3.141592653），以此象征TeX已趋于稳定，不再有重大修改。这一创意性的版本控制方式体现了克努斯对TeX完成度的自信，也避免了使用者陷入版本升级的困扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社区剃须&lt;/strong&gt;：文章提出的概念，指社区在开源项目基础上的持续&amp;quot;牦牛剃须&amp;quot;工作。TeX原版用WEB编写，社区将其转换为C；TeX只支持ASCII，社区创建支持UTF-8的XeTeX和LuaTeX；TeX输出DVI，社区实现直接输出PDF的pdfTeX。这些延续性工作让TeX在保持核心稳定的同时适应了现代技术需求。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://yakshav.es/the-patron-saint-of-yakshaves/"&gt;唐纳德克努斯——牦牛剃须的守护神&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;唐纳德克努斯&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-11&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Fish Shell 4.0 从C到Rust的忒修斯之船移植之路</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/fish-shell-4-0-rust-migration/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/fish-shell-4-0-rust-migration/</guid><description>&lt;h1 id="fish-shell-40-从c到rust的忒修斯之船移植之路"&gt;Fish Shell 4.0 从C到Rust的忒修斯之船移植之路&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文详细记录了Fish Shell从C++迁移到Rust的完整历程。Fish团队采用&amp;quot;忒修斯之船&amp;quot;策略，逐步替换代码库中的组件，确保每个阶段都有可运行的程序。迁移过程中解决了C++工具链差异、线程安全问题以及代码复杂性等挑战，最终成功完成Rust移植，使代码库更加简洁、性能有所提升，并实现了自安装包功能。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先阐述了Fish Shell最初使用C++开发所遇到的困境，包括不同平台的工具和编译器差异、人体工程学问题以及线程安全挑战。这些问题的累积促使团队考虑转向更现代、更安全的编程语言。&lt;/p&gt;
&lt;p&gt;接着文章介绍了选择Rust的核心理由：更好的工具链体验、清晰友好的错误信息、便捷的rustup安装方式，以及Rust在安全性和并发性方面的设计优势。Rust对多平台的广泛支持（macOS、Linux、BSD）也确保了Fish的兼容性不会受影响。&lt;/p&gt;
&lt;p&gt;最精彩的部分是&amp;quot;忒修斯之鱼&amp;quot;移植策略的详细说明——团队没有选择重写，而是逐步将C++组件移植到Rust，利用autocxx生成C++与Rust之间的绑定，确保整个迁移过程中始终有一个可工作的程序。文章还分享了关键时间节点、遇到的挑战（如可移植性和本地化问题）以及最终取得的成就和未来规划。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;忒修斯之船移植策略&lt;/strong&gt;：这是一种渐进式代码迁移方法，源自哲学思想实验&amp;quot;忒修斯之船&amp;quot;——如果逐步替换船上的所有木板，它还是原来的船吗？Fish团队将这一理念应用到代码迁移中，每次替换一小部分C++代码为Rust代码，确保每个阶段都有可运行的程序。这种策略避免了重写的高风险，让迁移过程可控且可回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;autocxx绑定生成&lt;/strong&gt;：在C++和Rust共存的过渡期，团队使用autocxx工具自动生成两种语言之间的绑定层。这大大简化了跨语言调用的复杂性，让C++代码可以逐步调用Rust实现的新功能，无需手动编写繁琐的FFI（外部函数接口）代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rustup工具链&lt;/strong&gt;：Rust的官方安装管理工具，让开发者能够轻松安装和管理不同版本的Rust。这解决了C++开发中常见的&amp;quot;我的机器上能跑&amp;quot;问题——不同平台的编译器版本差异导致的行为不一致。rustup确保了全球开发者使用统一、稳定的工具链。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译时格式字符串检查&lt;/strong&gt;：Rust的一个独特优势，能够在编译阶段验证格式字符串的正确性。但这给Fish的国际化翻译带来了挑战——因为翻译文件是运行时加载的，无法在编译时检查。团队需要创造性地解决这个问题，在保持类型安全的同时支持多语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自安装包&lt;/strong&gt;：迁移到Rust后，Fish能够提供&amp;quot;自安装&amp;quot;的分发方式。这得益于Rust优秀的打包和跨平台编译能力，用户可以获得更简洁的安装体验，无需复杂的依赖配置。这是Rust生态系统优势的直接体现。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://fishshell.com/blog/rustport/"&gt;Fish 4.0: The Fish Of Theseus&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;ridiculousfish&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024-12-28&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Linus Torvalds 访谈 - 内核、生成式AI、电动汽车、编程语言等</title><link>https://linguista.cn/rosetta/chat-notes/linus-torvalds-interview-kernel-genai-evs-programming-languages/</link><pubDate>Thu, 17 Oct 2024 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/chat-notes/linus-torvalds-interview-kernel-genai-evs-programming-languages/</guid><description>&lt;h1 id="linus-torvalds-访谈---内核生成式ai电动汽车编程语言等"&gt;Linus Torvalds 访谈 - 内核、生成式AI、电动汽车、编程语言等&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Linux 创始人 Linus Torvalds 在维也纳开源峰会上接受深度访谈，分享了他在内核开发中的角色变化、社区从早期狂野西部到成熟稳定的演变历程、维护者面临的压力与挑战，以及他对 Rust 语言引入内核、AI 炒作周期、电动汽车体验等热门话题的坦诚看法。&lt;/p&gt;
&lt;div class="video-card group relative w-full overflow-hidden rounded-2xl border border-border bg-surface shadow-sm transition hover:shadow-md "&gt;
 &lt;div style="aspect-ratio: 16/9;" class="w-full relative bg-black/5 dark:bg-white/5"&gt;
 &lt;iframe
 src="https://www.youtube-nocookie.com/embed/s4wlrxFf2lM?rel=0&amp;amp;modestbranding=1&amp;amp;playsinline=1"
 title="Linus Torvalds 访谈 - 内核、生成式AI、电动汽车、编程语言等"
 class="absolute inset-0 w-full h-full border-0"
 loading="lazy"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
 allowfullscreen&gt;
 &lt;/iframe&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;合并窗口期 - Linux 内核开发周期中用于接收新功能和变更的特定时间段，由 Linus Torvalds 负责审查和合并各子系统维护者提交的代码&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;维护者层级模型 - 内核社区随规模扩张形成的信任与管理结构，Torvalds 依赖约50至100位顶尖维护者，再由他们各自管理下游开发者&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户空间兼容性原则 - Linux 内核开发中坚持的核心准则，即内核更新不应破坏现有用户空间程序的正常运行，保障系统稳定性和向后兼容&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rust 引入内核 - 将 Rust 编程语言作为 C 语言之外的第二种内核开发语言，旨在提升内存安全性，但社区态度尚不统一&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全漏洞即Bug - Torvalds 对内核安全问题的核心哲学，主张将安全漏洞视为普通 Bug 进行修复，而非特殊化处理&lt;/strong&gt;：&lt;/p&gt;</description></item><item><title>怪异语言</title><link>https://linguista.cn/person/paul_graham/essays_zh/weird/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/weird/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/weird/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/weird.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/weird.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/weird.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="怪异语言"&gt;怪异语言&lt;/h1&gt;
&lt;p&gt;2021年8月&lt;/p&gt;
&lt;p&gt;当人们说根据他们的经验所有编程语言基本上等价时，他们做出的不是关于语言的陈述，而是关于他们做过的编程类型的陈述。&lt;/p&gt;
&lt;p&gt;99.5%的编程包括将库函数调用粘合在一起。所有流行的语言在这方面都同样好。所以一个人可以很容易地花费整个职业生涯在流行编程语言的交集中操作。&lt;/p&gt;
&lt;p&gt;但另外0.5%的编程不成比例地有趣。如果你想了解它由什么组成，怪异语言的怪异性是一个很好的线索。&lt;/p&gt;
&lt;p&gt;怪异语言不是偶然怪异的。至少好的不是。好的怪异语言的怪异性通常暗示着存在某种不仅仅是通常的库函数调用的粘合的编程形式。&lt;/p&gt;
&lt;p&gt;一个具体的例子：Lisp宏。Lisp宏即使对许多Lisp程序员来说也显得怪异。它们不仅不在流行语言的交集中，而且它们的性质使得在语言中正确实现它们而不将其变成Lisp的方言会很困难。宏绝对证明超越了粘合编程的技术。例如，通过首先为该类型的问题编写一种语言，然后在其中编写你的特定应用程序来解决问题。这不是你用宏能做的全部；它只是程序操作技术空间中的一个区域，即使现在还远未被完全探索。&lt;/p&gt;
&lt;p&gt;所以如果你想扩展你对编程可能性的概念，一种方法是学习怪异语言。选择一种大多数程序员认为怪异但其中位数用户聪明的语言，然后专注于这种语言与流行语言交集之间的差异。你能用这种语言说什么，而在其他语言中说会极其不便？在学习如何说你以前不能说的话的过程中，你可能会学习如何想你以前不能想的事。&lt;/p&gt;
&lt;p&gt;感谢Trevor Blackwell、Patrick Collison、Daniel Gackle、Amjad Masad和Robert Morris阅读草稿。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://paulgraham.com/weird.ja.html"&gt;日语翻译&lt;/a&gt;&lt;/p&gt;</description></item><item><title>如果Lisp这么好</title><link>https://linguista.cn/person/paul_graham/essays_zh/iflisp/</link><pubDate>Thu, 01 May 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/iflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/iflisp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/iflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/iflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/iflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="如果lisp这么好"&gt;如果Lisp这么好&lt;/h1&gt;
&lt;p&gt;2003年5月&lt;/p&gt;
&lt;p&gt;如果Lisp这么好，为什么没有更多人使用它？我最近在一次演讲中被听众中的一个学生问到了这个问题。而且不是第一次了。&lt;/p&gt;
&lt;p&gt;在语言方面，就像在许多事情中一样，流行度和质量之间没有太大关联。为什么约翰·格里沙姆（《诉讼之王》销售排名第44）比简·奥斯汀（《傲慢与偏见》销售排名第6191）卖得更好？即使是格里沙姆会声称这是因为他是更好的作家吗？&lt;/p&gt;
&lt;p&gt;这是《傲慢与偏见》的第一句话：&amp;ldquo;凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;举世公认的真理？&amp;rdquo; 对于一个爱情故事的第一句话来说，这些词太长了。&lt;/p&gt;
&lt;p&gt;就像简·奥斯汀的作品一样，Lisp看起来很难。它的语法，或者说缺乏语法，使它看起来完全不同于大多数人习惯的语言。在学习Lisp之前，我也害怕它。我最近发现了一本1983年的笔记本，我在上面写道：&amp;ldquo;我想我应该学习Lisp，但它看起来太陌生了。&amp;ldquo;幸运的是，我当时19岁，对学习新东西没有太多抵触。我非常无知，学习几乎任何东西都意味着学习新事物。&lt;/p&gt;
&lt;p&gt;被Lisp吓到的人们编造了其他不使用它的理由。当C是默认语言时，标准的借口是Lisp太慢。现在Lisp方言是可用语言中较快的之一，这个借口已经消失了。现在的标准借口是公开循环的：其他语言更流行。&lt;/p&gt;
&lt;p&gt;（小心这种推理。它会让你得到Windows。）&lt;/p&gt;
&lt;p&gt;流行度总是自我延续的，但在编程语言中尤其如此。为流行语言编写的库更多，这使它们更流行。程序经常必须与现有程序一起工作，如果它们用相同的语言编写，这会更容易，所以语言像病毒一样从程序传播到程序。管理者更喜欢流行的语言，因为它们给他们更多对开发者的控制力，开发者可以更容易被替换。&lt;/p&gt;
&lt;p&gt;确实，如果编程语言都或多或少等价，那么使用除最流行语言之外的任何语言都没有什么理由。但它们并不都等价，差远了。这就是为什么不那么流行的语言，像简·奥斯汀的小说，继续存在的原因。当其他人在阅读最新的约翰·格里沙姆小说时，总会有一小部分人在阅读简·奥斯汀。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;日语翻译 | 罗马尼亚语翻译 | 西班牙语翻译&lt;/em&gt;&lt;/p&gt;</description></item><item><title>百年编程语言</title><link>https://linguista.cn/person/paul_graham/essays_zh/hundred/</link><pubDate>Tue, 01 Apr 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/hundred/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/hundred/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hundred.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hundred.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hundred.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="百年编程语言"&gt;百年编程语言&lt;/h1&gt;
&lt;p&gt;2003年4月&lt;/p&gt;
&lt;p&gt;（本文源于在PyCon 2003的主题演讲。）&lt;/p&gt;
&lt;p&gt;很难预测一百年后的生活会是什么样子。我们只能确定几件事。我们知道每个人都会驾驶飞行汽车，区划法律将会放宽以允许建造数百层高的建筑，大部分时间都会是黑暗的，女性都会接受武术训练。在这里，我想聚焦于这个图景中的一个细节。他们会用什么样的编程语言来编写控制那些飞行汽车的软件？&lt;/p&gt;
&lt;p&gt;思考这个问题之所以有价值，并不是因为我们真的能用到这些语言，而是因为，如果我们幸运的话，我们会使用从现在到那个时间点的路径上的语言。&lt;/p&gt;
&lt;p&gt;我认为，像物种一样，语言会形成进化树，到处都有死胡同分支。我们已经看到这种情况正在发生。Cobol尽管曾经流行，但似乎没有任何知识后代。它是一个进化死胡同——尼安德特人式的语言。&lt;/p&gt;
&lt;p&gt;我预测Java也会有类似的命运。人们有时给我写信说，&amp;ldquo;你怎么能说Java不会成为一种成功的语言？它已经是成功的语言了。&amp;ldquo;我承认它是，如果你用关于它的书籍所占用的书架空间（特别是关于它的单本书籍），或者相信必须学习它才能找到工作的本科生数量来衡量成功的话。当我说Java不会成为成功的语言时，我的意思更具体：Java将是一个进化死胡同，就像Cobol一样。&lt;/p&gt;
&lt;p&gt;这只是一个猜测。我可能是错的。我在这里的重点不是批评Java，而是提出进化树的问题，让人们思考，语言X在树的哪个位置？问这个问题的原因不仅仅是为了让我们的鬼魂在一百年后说我告诉过你这样。这是因为靠近主要分支是寻找现在适合编程的语言的有用启发式方法。&lt;/p&gt;
&lt;p&gt;在任何给定的时间，你可能最幸福地处于进化树的主要分支上。即使仍然有很多尼安德特人，成为其中的一员也一定很糟糕。克罗马农人会不断过来殴打你并偷走你的食物。&lt;/p&gt;
&lt;p&gt;我想知道一百年后语言会是什么样子，这样我就知道现在应该赌树的哪个分支。&lt;/p&gt;
&lt;p&gt;语言的进化与物种的进化不同，因为分支可以融合。例如，Fortran分支似乎正在与Algol的后代融合。理论上这对物种也是可能的，但不太可能发生在比细胞更大的生物上。&lt;/p&gt;
&lt;p&gt;语言更有可能融合，部分是因为可能性空间较小，部分是因为突变不是随机的。语言设计师有意地融合其他语言的思想。&lt;/p&gt;
&lt;p&gt;对于语言设计师来说，思考编程语言的进化可能导致的方向特别有用，因为他们可以相应地引导。在这种情况下，&amp;ldquo;停留在主分支上&amp;quot;不仅仅是选择好语言的方法。它成为做出正确语言设计决策的启发式方法。&lt;/p&gt;
&lt;p&gt;任何编程语言都可以分为两部分：一组扮演公理角色的基本运算符，以及语言的其余部分，原则上可以用这些基本运算符来编写。&lt;/p&gt;
&lt;p&gt;我认为基本运算符是语言长期生存的最重要因素。其余的你可以改变。这就像买房子的规则，你首先应该考虑位置。其他的一切你都可以稍后修复，但你不能修复位置。&lt;/p&gt;
&lt;p&gt;我认为不仅公理要选择得好，而且数量要少。数学家一直对公理有这样的感觉——越少越好——我认为他们抓住了要点。&lt;/p&gt;
&lt;p&gt;至少，仔细审视语言的核心，看看是否有任何可以剔除的公理，这必须是一个有用的练习。我在我作为一个邋遢人的漫长职业生涯中发现，冗余会产生冗余，我看到这种情况不仅发生在软件中，也发生在床下和房间角落。&lt;/p&gt;
&lt;p&gt;我有一种预感，进化树的主要分支通过那些具有最小、最干净核心的语言。你能在语言本身中编写的语言部分越多越好。&lt;/p&gt;
&lt;p&gt;当然，即使问一百年后编程语言会是什么样子，我也做出了一个很大的假设。一百年后我们还会编写程序吗？我们不会只是告诉计算机我们想要它们做什么吗？&lt;/p&gt;
&lt;p&gt;到目前为止，那个部门没有太多进展。我猜测一百年后人们仍会使用我们能识别的程序来告诉计算机做什么。可能有些我们现在通过编写程序来解决的问题，一百年后你不必编写程序来解决，但我认为仍会有大量我们今天所做的那种编程。&lt;/p&gt;
&lt;p&gt;认为任何人都能预测任何技术在一百年后会是什么样子可能显得 presumptuous。但请记住，我们背后已经有将近五十年的历史。当我们考虑到语言在过去五十年中进化得多么缓慢时，展望一百年是一个可以把握的想法。&lt;/p&gt;
&lt;p&gt;语言进化缓慢是因为它们并不是真正的技术。语言是符号。程序是你希望计算机为你解决问题的形式化描述。所以编程语言的进化速度更像数学符号的进化速度，而不是交通或通信的进化速度。数学符号确实在进化，但没有你在技术中看到的巨大飞跃。&lt;/p&gt;
&lt;p&gt;无论一百年后计算机由什么制成，似乎可以安全地预测它们会比现在快得多。如果摩尔定律继续发挥作用，它们将快74 quintillion（73,786,976,294,838,206,464）倍。这很难想象。事实上，速度部门最可能的预测可能是摩尔定律将停止工作。任何应该每十八个月翻一番的东西似乎最终都会遇到某种基本限制。但我毫不怀疑计算机会快得多。即使它们最终只快一百倍，这也应该大大改变编程语言的基本规则。除此之外，还会有更多空间给现在被认为是慢的语言，即那些不能产生非常高效代码的语言。&lt;/p&gt;
&lt;p&gt;然而，有些应用仍然需要速度。我们想用计算机解决的有些问题是计算机创造的；例如，你必须处理视频图像的速度取决于另一台计算机生成它们的速度。还有另一类问题本身就具有无限吸收计算周期的能力：图像渲染、密码学、模拟。&lt;/p&gt;
&lt;p&gt;如果一些应用可以变得越来越低效，而其他应用继续要求硬件能够提供的所有速度，更快的计算机将意味着语言必须覆盖更广泛的效率范围。我们已经看到这种情况正在发生。按照过去几十年的标准，一些流行新语言的当前实现惊人地浪费。&lt;/p&gt;
&lt;p&gt;这不仅仅是编程语言发生的事情。这是一个普遍的历史趋势。随着技术的改进，每一代人都能做前一代人认为是浪费的事情。三十年前的人会对我们如此随意地打长途电话感到惊讶。一百年前的人会更惊讶有一天一个包裹会通过孟菲斯从波士顿旅行到纽约。&lt;/p&gt;
&lt;p&gt;我已经可以告诉你未来一百年更快的硬件将给我们的所有额外周期会发生什么。它们几乎都会被浪费掉。&lt;/p&gt;
&lt;p&gt;我学习编程时计算机能力很稀缺。我记得取出我Basic程序中的所有空格，使它们能适合4K TRS-80的内存。想到所有这些惊人低效的软件一遍又一遍地烧掉周期做同样的事情，我觉得有点恶心。但我认为我的直觉在这里是错的。我就像一个长大的穷人，即使是为了重要的事情也不能忍受花钱，比如去看医生。&lt;/p&gt;
&lt;p&gt;有些浪费确实是令人厌恶的。例如，SUVs即使运行在永远不会耗尽且不产生污染的燃料上，也可能是令人厌恶的。SUVs之所以令人厌恶，是因为它们是一个令人厌恶的问题的解决方案。（如何使小型货车看起来更阳刚。）但并非所有浪费都是坏的。现在我们有了支持它的基础设施，计算你的长途通话分钟数开始显得吝啬。如果你有资源，更优雅的思考方式是把所有电话通话视为一类事情，无论对方在哪里。&lt;/p&gt;
&lt;p&gt;有好浪费，也有坏浪费。我对好浪费感兴趣——那种通过花费更多，我们可以获得更简单设计的浪费。我们将如何利用新、更快的硬件给我们带来的浪费周期的机会？&lt;/p&gt;
&lt;p&gt;对速度的渴望在我们这些拥有可怜计算机的人心中根深蒂固，以至于需要 conscious 努力来克服它。在语言设计中，我们应该有意识地寻找可以用效率换取哪怕是最小的便利增加的情况。&lt;/p&gt;
&lt;p&gt;大多数数据结构的存在是因为速度。例如，今天的许多语言既有字符串也有列表。在语义上，字符串或多或少是列表的一个子集，其中元素是字符。那么为什么你需要单独的数据类型呢？你真的不需要。字符串的存在仅仅是为了效率。但是用使程序运行得更快的hack来使语言的语义变得混乱是很蹩脚的。在语言中拥有字符串似乎是一个过早优化的例子。&lt;/p&gt;
&lt;p&gt;如果我们将语言的核心视为一组公理，那么仅仅为了效率而增加不增加表达能力的额外公理肯定是令人厌恶的。效率很重要，但我认为这不是获得它的正确方法。&lt;/p&gt;
&lt;p&gt;我认为解决这个问题的正确方法是将程序的含义与实现细节分开。不要同时拥有列表和字符串，只拥有列表，同时有某种方式给编译器优化建议，使其能够在必要时将字符串布置为连续的字节。&lt;/p&gt;
&lt;p&gt;由于速度在程序的大部分中都不重要，你通常不需要费心处理这种微观管理。随着计算机变得越来越快，这一点会越来越真实。&lt;/p&gt;
&lt;p&gt;少说实现细节也应该使程序更灵活。规范在程序编写过程中会改变，这不仅是不可避免的，而且是可取的。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;essay&amp;quot;这个词来自法语动词&amp;quot;essayer&amp;rdquo;，意思是&amp;quot;尝试&amp;rdquo;。essay在原始意义上是你写来试图弄清楚某些东西的东西。这在软件中也会发生。我认为一些最好的程序是essay，从这个意义上说，作者们在开始时并不知道他们确切地想要写什么。&lt;/p&gt;
&lt;p&gt;Lisp黑客们已经知道灵活使用数据结构的价值。我们倾向于编写程序的第一版本，使其用列表做所有事情。这些初始版本可能如此惊人地低效，以至于需要conscious努力不去思考它们在做什么，就像，至少对我而言，吃牛排需要conscious努力不去思考它来自哪里。&lt;/p&gt;
&lt;p&gt;一百年后的程序员最寻找的，最重要的是一种语言，你可以用最少的努力组合成一个令人难以置信的低效版本1程序。至少，这是我们现在会描述的方式。他们会说他们想要一种易于编程的语言。&lt;/p&gt;
&lt;p&gt;低效的软件并不令人厌恶。令人厌恶的是让程序员做不必要工作的语言。浪费程序员时间是真正的低效，而不是浪费机器时间。随着计算机变得越来越快，这一点会变得越来越清晰。&lt;/p&gt;</description></item><item><title>设计与研究</title><link>https://linguista.cn/person/paul_graham/essays_zh/desres/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/desres/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/desres/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/desres.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/desres.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/desres.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="设计与研究"&gt;设计与研究&lt;/h1&gt;
&lt;p&gt;2003年1月&lt;/p&gt;
&lt;p&gt;（本文源自2002年秋季NEPLS会议的主题演讲。）&lt;/p&gt;
&lt;p&gt;访问这个国家的人常常惊讶地发现，美国人喜欢以询问&amp;quot;你是做什么的？&amp;ldquo;来开始对话。我从来不喜欢这个问题。我很少有一个简洁的答案。但我想我终于解决了这个问题。现在，当有人问我做什么时，我会直视他们的眼睛说&amp;quot;我正在设计一种新的Lisp方言。&amp;ldquo;我推荐这个答案给任何不喜欢被问及做什么的人。对话会立即转向其他话题。&lt;/p&gt;
&lt;p&gt;我不认为自己在研究编程语言。我只是在设计一种，就像有人可能设计一座建筑、一把椅子或一种新字体一样。我不是在试图发现什么新东西。我只是想创造一种编程起来很舒服的语言。在某些方面，这个假设让生活轻松很多。&lt;/p&gt;
&lt;p&gt;设计和研究之间的区别似乎是一个新与好的问题。设计不一定要新，但一定要好。研究不一定要好，但一定要新。我认为这两条路在顶端汇合：最好的设计通过使用新思想超越其前人，而最好的研究解决的不仅是新的问题，而且是真正值得解决的问题。所以最终我们的目标是相同的目的地，只是从不同的方向接近。&lt;/p&gt;
&lt;p&gt;今天我要谈论的是从背面看你的目标是什么样子的。当你把编程语言视为设计问题而非研究课题时，你会做什么不同的事情？&lt;/p&gt;
&lt;p&gt;最大的区别是你更关注用户。设计始于问，这是为谁而做的，他们从中需要什么？例如，一个好的建筑师不是先创建一个设计然后强加给用户，而是通过研究预期用户并找出他们需要什么来开始。&lt;/p&gt;
&lt;p&gt;注意我说的是&amp;quot;他们需要的&amp;rdquo;，而不是&amp;quot;他们想要的&amp;rdquo;。我并不是说作为一名设计师工作意味着像快餐厨师一样工作，做客户告诉你的任何事情。这在艺术领域的各个领域都有所不同，但我不认为有任何领域是由那些完全按照客户要求做事的人做出最好的作品的。&lt;/p&gt;
&lt;p&gt;在衡量好设计的标准是它对用户有多好用这一点上，顾客永远是对的。如果你写了一本让所有人都感到无聊的小说，或者一把坐着极不舒服的椅子，那么你的工作就很糟糕，就是这样。说小说或椅子是根据最先进的理论原理设计的，这并不是辩解。&lt;/p&gt;
&lt;p&gt;然而，做出对用户有用的东西并不意味着简单地做用户告诉你做的事情。用户不知道所有的选择是什么，而且常常对他们真正想要的东西感到困惑。&lt;/p&gt;
&lt;p&gt;这个悖论的答案，我认为是你必须为用户设计，但必须设计用户需要的东西，而不是仅仅设计他们说他们想要的东西。这很像做医生。你不能仅仅治疗病人的症状。当病人告诉你他们的症状时，你必须找出真正的问题所在，并治疗那个。&lt;/p&gt;
&lt;p&gt;这种对用户的关注是一种公理，大多数好的设计实践都可以从中推导出来，大多数设计问题都围绕着它。&lt;/p&gt;
&lt;p&gt;如果好的设计必须满足用户的需求，那么用户是谁？当我说设计必须为用户时，我并不是说好的设计旨在某种最低标准。你可以选择任何你想要的用户群体。例如，如果你在设计一个工具，你可以为从初学者到专家的任何人设计，而针对一个群体的好设计对另一个群体可能是坏的设计。关键是，你必须选择某个用户群体。我认为除非参考某个预期用户，否则你甚至无法谈论好或坏的设计。&lt;/p&gt;
&lt;p&gt;如果预期用户包括设计师自己，你最有可能获得好的设计。当你为不包括你自己的群体设计东西时，它往往是为那些你认为比你不够复杂的人设计的，而不是更复杂的。&lt;/p&gt;
&lt;p&gt;这是一个问题，因为无论多么仁慈，居高临下地看待用户似乎不可避免地会腐蚀设计师。我怀疑美国很少有住房项目是由期望住在那里的建筑师设计的。你可以在编程语言中看到同样的现象。C、Lisp和Smalltalk是为它们自己的设计师使用而创建的。Cobol、Ada和Java是为其他人使用而创建的。&lt;/p&gt;
&lt;p&gt;如果你认为你在为白痴设计东西，那么很可能你设计的东西不够好，即使是对白痴来说。即使你为最复杂的用户设计东西，你仍然在为人类设计。在研究方面情况不同。在数学中，你选择抽象不是因为它们容易理解，而是因为它们能让证明更短。我认为这对科学大体上也是如此。科学思想并不是为了符合人体工程学。&lt;/p&gt;
&lt;p&gt;在艺术领域，情况非常不同。设计完全是关于人的。人体是个奇怪的东西，但当你设计一把椅子时，那就是你设计的对象，没有办法回避。所有艺术都必须迎合人类的兴趣和局限性。例如，在绘画中，在其他条件相同的情况下，有人的画比没有人的画更有趣。文艺复兴时期的伟大画作都充满了人，这不仅仅是历史的偶然。如果不是这样，绘画作为媒介就不会拥有它所拥有的声望。&lt;/p&gt;
&lt;p&gt;不管喜欢与否，编程语言也是为人类服务的，我怀疑人脑就像人体一样凹凸不平且特异。有些思想人们很容易掌握，有些则不然。例如，我们处理细节的能力似乎非常有限。正是这个事实使得编程语言一开始就是个好主意；如果我们能处理细节，我们可以直接用机器语言编程。&lt;/p&gt;
&lt;p&gt;还要记住，语言主要不是完成程序的形式，而是程序必须在其中开发的东西。任何艺术领域的人都会告诉你，你可能需要不同的媒介来处理这两种情况。例如，大理石是完成思想的漂亮、耐用的媒介，但对于开发新思想来说，它却是一种无可救药的僵化媒介。&lt;/p&gt;
&lt;p&gt;程序就像证明一样，是一棵树的修剪版本，这棵树过去到处都有错误的分支。所以语言的测试不仅仅是完成的程序在它里面看起来有多干净，而是到达完成程序的路径有多干净。一个能给你优雅完成程序的设计选择可能不会给你一个优雅的设计过程。例如，我写过几个定义宏的宏，充满了嵌套的反引号，现在看起来像小宝石，但写它们花费了数小时最丑陋的试错，而且坦率地说，我仍然不完全确定它们是正确的。&lt;/p&gt;
&lt;p&gt;我们常常表现得好像语言的测试是完成的程序在它里面看起来有多好。当你看到同一个程序用两种语言编写，一个版本短得多时，这似乎很有说服力。当你从艺术的角度接近这个问题时，你不太可能依赖这种测试。你不想最终得到一个像大理石一样的编程语言。&lt;/p&gt;
&lt;p&gt;例如，在软件开发中拥有一个交互式顶层（在Lisp中称为读取-求值-打印循环）是一个巨大的胜利。当你有一个这样的东西时，它对语言的设计有实际影响。它对于一个必须在使用前声明变量的语言来说效果不佳，例如。当你只是在顶层输入表达式时，你希望能够将x设置为某个值，然后开始对x做事情。你不想必须先声明x的类型。你可以对任何一个前提提出异议，但如果一个语言必须有顶层才能方便，而强制类型声明与顶层不兼容，那么任何强制类型声明的语言都不可能方便编程。&lt;/p&gt;
&lt;p&gt;在实践中，要获得好的设计，你必须接近并保持接近你的用户。你必须不断在实际用户上校准你的想法，尤其是在开始时。简·奥斯汀的小说如此之好的原因之一是她把它们大声读给家人听。这就是为什么她从不沉溺于自我放纵的风景描述或矫饰的哲学思考。（哲学在那里，但它被编织进故事中，而不是像标签一样粘贴在上面。）如果你打开一本普通的&amp;quot;文学&amp;quot;小说，想象把它作为你写的东西大声读给朋友听，你会敏锐地感觉到那种东西对读者来说是多么令人难以忍受。&lt;/p&gt;
&lt;p&gt;在软件世界，这个想法被称为&amp;quot;较差就是更好&amp;quot;。实际上，&amp;ldquo;较差就是更好&amp;quot;的概念中混合了几个想法，这就是为什么人们仍在争论较差是否真的更好。但这个混合中的主要思想之一是，如果你在构建新东西，你应该尽快将原型放到用户面前。&lt;/p&gt;
&lt;p&gt;另一种方法可能叫做&amp;quot;万福玛丽亚策略&amp;rdquo;。你不是快速拿出原型并逐步改进它，而是试图在一次长传触地中创建完整、完成的产品。据我所知，这是灾难的根源。无数创业公司在互联网泡沫期间这样自我毁灭。我从未听说过有成功的案例。&lt;/p&gt;
&lt;p&gt;软件世界之外的人可能没有意识到的是，&amp;ldquo;较差就是更好&amp;quot;的思想在整个艺术领域都有体现。例如，在绘画中，这个思想在文艺复兴时期被发现。现在几乎每个绘画老师都会告诉你，获得准确绘画的正确方法不是慢慢地围绕物体的轮廓工作，因为错误会累积，最后你会发现线条不相遇。相反，你应该在大致正确的地方画几条快速的线，然后逐渐完善这个初始草图。&lt;/p&gt;
&lt;p&gt;在大多数领域，传统上原型是用不同材料制作的。要切割成金属的字体最初是用刷子在纸上设计的。要铸成青铜的雕像是用蜡建模的。要在挂毯上刺绣的图案是用墨水在纸上绘制的。要用石头建造的建筑是在较小规模的木材上测试的。&lt;/p&gt;
&lt;p&gt;当油画在十五世纪首次流行时令人兴奋的原因是，你实际上可以从原型制作完成的作品。如果你愿意，可以做一个初步的绘图，但你不必受它约束；你可以在完成绘画时解决所有细节，甚至做重大改变。&lt;/p&gt;
&lt;p&gt;在软件中你也可以这样做。原型不一定只是一个模型；你可以将其精制成成品。我认为你应该在可能的时候总是这样做。它能让你利用一路上获得的新见解。但也许更重要的是，它对士气有好处。&lt;/p&gt;
&lt;p&gt;士气在设计中至关重要。我很惊讶人们不多谈论它。我的第一个绘画老师告诉我：当你画某样东西感到无聊时，画出来的东西看起来会很无聊。例如，假设你必须画一栋建筑，你决定单独画每一块砖。如果你愿意，你可以这样做，但如果你中途感到无聊并开始机械地画砖而不是观察每一块，那么画出来的效果会比仅仅暗示砖块要差。&lt;/p&gt;
&lt;p&gt;通过逐步完善原型来建造东西对士气有好处，因为它能让你保持投入。在软件中，我的规则是：始终有可工作的代码。如果你正在写一小时内可以测试的东西，那么你有立即获得奖励的前景来激励你。在艺术领域也是如此，特别是在油画中。大多数画家从模糊的草图开始，然后逐步完善。如果你这样工作，那么原则上你永远不必在一天结束时留下看起来确实未完成的东西。确实，画家之间甚至有句谚语：&amp;ldquo;一幅画永远不会完成，你只是停止在上面工作。&amp;ldquo;这个想法对任何做过软件的人来说都很熟悉。&lt;/p&gt;
&lt;p&gt;士气是难以设计给不够复杂用户的另一个原因。很难对自己不喜欢的东西保持兴趣。要做出好东西，你必须想&amp;quot;哇，这真的很棒&amp;rdquo;，而不是&amp;quot;这是什么垃圾；那些傻瓜会喜欢它&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;设计意味着为人类制造东西。但不仅仅是用户是人。设计师也是人。&lt;/p&gt;
&lt;p&gt;注意这段时间我一直在谈论&amp;quot;设计师&amp;rdquo;。设计通常必须由单个人控制才能做好。然而，似乎几个人可以合作进行一个研究项目。这在我看来是研究和设计之间最有趣的区别之一。&lt;/p&gt;
&lt;p&gt;艺术领域有著名合作的例子，但它们大多数似乎是分子结合而不是核融合的情况。在歌剧中，通常由一个人写剧本，另一个人写音乐。在文艺复兴时期，来自北欧的工匠经常被雇佣来做意大利绘画背景中的风景。但这些不是真正的合作。它们更像是罗伯特·弗罗斯特&amp;quot;好篱笆造就好邻居&amp;quot;的例子。你可以把好的设计实例粘在一起，但在每个单独的项目中，一个人必须处于控制地位。&lt;/p&gt;
&lt;p&gt;我不是说好的设计要求一个人思考所有事情。没有什么比一个你信任其判断的人的建议更有价值了。但谈话结束后，关于做什么的决定必须由一个人来做。&lt;/p&gt;
&lt;p&gt;为什么研究可以由合作者完成而设计不能？这是一个有趣的问题。我不知道答案。也许，如果设计和研究汇合，最好的研究也是好的设计，而且实际上不能由合作者完成。许多最著名的科学家似乎都是独自工作的。但我了解得不够多，无法说这里是否有模式。这可能仅仅是因为许多著名科学家工作时合作不那么普遍。&lt;/p&gt;
&lt;p&gt;无论科学领域的情况如何，真正的合作在艺术领域似乎极为罕见。委员会设计是坏设计的同义词。为什么会这样？有什么方法可以克服这个限制吗？&lt;/p&gt;
&lt;p&gt;我倾向于认为没有——好的设计需要一个独裁者。一个原因是好的设计必须是一体的。设计不仅是为人类，而是为单个的人。如果一个设计代表的思想适合一个人的头脑，那么这个思想也会适合用户的头脑。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.aoky.net/articles/paul_graham/design_and_research_japanese.htm"&gt;日语翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://linguista.cn/person/paul_graham/essays_zh/taste/"&gt;制造者的品味&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cs.kent.ac.uk/people/staff/srk21/research/papers/graham/design_and_research_romanian.pdf"&gt;罗马尼亚语翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.barrahome.org/blog/articulos/diseno_e_investigacion"&gt;西班牙语翻译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>书呆子的复仇</title><link>https://linguista.cn/person/paul_graham/essays_zh/icad/</link><pubDate>Wed, 01 May 2002 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/icad/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/icad/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/icad.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/icad.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/icad.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="书呆子的复仇"&gt;书呆子的复仇&lt;/h1&gt;
&lt;p&gt;想要创业？获得Y Combinator的投资。&lt;/p&gt;
&lt;p&gt;2002年5月&lt;/p&gt;
&lt;p&gt;&amp;ldquo;我们当时在追逐C++程序员。我们成功地将他们中的许多人拖到了Lisp的路上。&amp;rdquo;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guy Steele，Java规范合著者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件行业中，一直存在着一场持续的斗争，一方是尖脑袋的学者，另一方是同样强大的力量——尖头发的老板。大家都知道尖头发的老板是谁，对吧？我认为技术界的大多数人不仅认识这个卡通人物，而且知道他们公司中这个人物的原型是谁。&lt;/p&gt;
&lt;p&gt;尖头发的老板奇迹般地结合了两个各自常见但很少同时出现的品质：(a)他对技术一无所知，(b)他对技术有非常强烈的看法。&lt;/p&gt;
&lt;p&gt;假设，例如，你需要编写一个软件。尖头发的老板对这个软件应该如何工作一无所知，也无法区分一种编程语言和另一种，但他知道你应该用什么语言来编写它。完全正确。他认为你应该用Java来编写。&lt;/p&gt;
&lt;p&gt;他为什么这么认为？让我们来看看尖头发的老板的大脑里面在想什么。他在想的大概是这样的。Java是一个标准。我知道它一定是标准，因为我总是在媒体上看到它。既然它是标准，我使用它就不会惹上麻烦。这也意味着总会有很多Java程序员，所以如果现在为我工作的程序员辞职了——为我工作的程序员总是神秘地辞职——我可以很容易地替换他们。&lt;/p&gt;
&lt;p&gt;嗯，这听起来并不那么不合理。但这一切都基于一个未言明的假设，而这个假设结果是错误的。尖头发的老板认为所有编程语言都差不多是等价的。如果这是真的，那他完全正确。如果所有语言都等价，当然，使用其他人都在使用的语言。&lt;/p&gt;
&lt;p&gt;但并非所有语言都是等价的，我想我甚至不需要深入它们之间的差异就能向你证明这一点。如果你在1992年问尖头发的老板软件应该用什么语言编写，他会像今天一样毫不犹豫地回答。软件应该用C++编写。但如果所有语言都等价，为什么尖头发的老板的意见会改变？事实上，Java的开发者为什么要费心创建一种新语言？&lt;/p&gt;
&lt;p&gt;据推测，如果你创建一种新语言，那是因为你认为它在某些方面比人们已有的语言更好。事实上，Gosling在第一份Java白皮书中明确表示，Java被设计用来解决C++的一些问题。所以事情就是这样：语言并不都是等价的。如果你顺着尖头发的老板的大脑思路追踪到Java，然后再回溯Java的历史到它的起源，你最终会得到一个与你开始时的假设相矛盾的想法。&lt;/p&gt;
&lt;p&gt;那么，谁是对的？James Gosling，还是尖头发的老板？毫不奇怪，Gosling是对的。某些语言对于某些问题来说比其他语言更好。你知道，这引发了一些有趣的问题。Java被设计为在特定问题上比C++更好。什么问题？什么时候Java更好，什么时候C++更好？是否存在某些情况下其他语言比两者都更好？&lt;/p&gt;
&lt;p&gt;一旦你开始考虑这个问题，你就打开了一个真正的潘多拉盒子。如果尖头发的老板不得不以全部复杂性来思考这个问题，他的大脑会爆炸。只要他认为所有语言都等价，他所要做的就是选择一个似乎最有势头的语言，既然这更多是时尚问题而不是技术问题，即使他也可能得到正确的答案。但如果语言各不相同，他突然必须同时解两个方程，试图在他一无所知的两件事之间找到最佳平衡：解决他需要解决的问题的二十种左右主要语言的相对适用性，以及为每种语言找到程序员、库等的可能性。如果门后是这样的东西，尖头发的老板不想打开它也就不足为奇了。&lt;/p&gt;
&lt;p&gt;认为所有编程语言都等价的缺点是这不是真的。但优点是它让你的生活简单得多。我认为这是这个想法如此广泛传播的主要原因。这是一个令人舒适的想法。&lt;/p&gt;
&lt;p&gt;我们知道Java一定相当不错，因为它是酷的、新的编程语言。或者真是如此吗？如果你从远处看编程语言的世界，看起来Java是最新的事物。（从足够远的地方看，你只能看到Sun支付的大型闪烁广告牌。）但如果你近距离观察这个世界，你会发现酷的程度是不同的。在黑客亚文化中，有一种叫做Perl的语言被认为比Java酷得多。例如，Slashdot就是用Perl生成的。我想你不会发现那些家伙使用Java Server Pages。但还有另一种更新的语言叫做Python，它的用户倾向于看不起Perl，还有更多的语言在等待。&lt;/p&gt;
&lt;p&gt;如果你按顺序看这些语言，Java、Perl、Python，你会注意到一个有趣的模式。至少，如果你是Lisp黑客，你会注意到这种模式。每一种都比前一种更像Lisp。Python甚至复制了许多Lisp黑客认为是错误的特性。你可以将简单的Lisp程序逐行翻译成Python。现在是2002年，编程语言几乎赶上了1958年。&lt;/p&gt;
&lt;h2 id="追上数学"&gt;追上数学&lt;/h2&gt;
&lt;p&gt;我的意思是，Lisp是John McCarthy在1958年首次发现的，而流行的编程语言现在才赶上他当时发展的想法。&lt;/p&gt;
&lt;p&gt;现在，这怎么可能是真的？计算机技术不是变化很快的东西吗？我的意思是，在1958年，计算机是冰箱大小的庞然大物，处理能力相当于手表。怎么可能有那么古老的技术仍然相关，更不用说比最新的发展更优越？&lt;/p&gt;
&lt;p&gt;我来告诉你原因。这是因为Lisp并不是真正被设计为一种编程语言，至少不是我们今天意义上的编程语言。我们所说的编程语言是我们用来告诉计算机做什么的东西。McCarthy最终确实打算发展这种意义上的编程语言，但我们实际得到的Lisp是基于他作为理论练习所做的另一件事——努力定义一个比图灵机更方便的替代方案。正如McCarthy后来所说，&lt;/p&gt;
&lt;p&gt;展示Lisp比图灵机更整洁的另一种方法是编写一个通用的Lisp函数，并证明它比通用图灵机的描述更简洁、更易理解。这就是Lisp函数eval&amp;hellip;&amp;hellip;它计算Lisp表达式的值&amp;hellip;&amp;hellip;编写eval需要发明一种表示Lisp函数作为Lisp数据的符号，这种符号是为了论文的目的而设计的，并没有想到它会用来实际表达Lisp程序。&lt;/p&gt;
&lt;p&gt;接下来发生的事情是，在1958年末的某个时候，Steve Russell，McCarthy的一个研究生，看着这个eval的定义，意识到如果将它翻译成机器语言，结果将是一个Lisp解释器。&lt;/p&gt;
&lt;p&gt;这在当时是一个很大的惊喜。以下是McCarthy后来在采访中对此的评论：&lt;/p&gt;
&lt;p&gt;Steve Russell说，看，为什么我不来编程这个eval&amp;hellip;&amp;hellip;，我对他说，呵，呵，你把理论和实践混淆了，这个eval是为了阅读，不是为了计算的。但他还是继续做了。也就是说，他把我论文中的eval编译成[IBM] 704机器码，修复了一些错误，然后将其宣传为Lisp解释器，它确实是。在那时，Lisp基本上就有了今天的形式。&lt;/p&gt;
&lt;p&gt;所以，我想在几周内，McCarthy发现他的理论练习转变为实际的编程语言——而且是一种比他预期更强大的语言。&lt;/p&gt;
&lt;p&gt;所以，这个1950年代的语言没有过时的简短解释是它不是技术而是数学，而数学不会过时。将Lisp比较的正确对象不是1950年代的硬件，而是，比如说，快速排序算法，它发现于1960年，至今仍然是最快的通用排序算法。&lt;/p&gt;
&lt;p&gt;1950年代还有另一种语言幸存下来，Fortran，它代表了语言设计的相反方法。Lisp是一段意想不到地转变为编程语言的理论。Fortran是故意被开发为一种编程语言的，但我们现在认为是一种非常低级的语言。&lt;/p&gt;
&lt;p&gt;1956年开发的Fortran I语言与现在的Fortran是完全不同的动物。Fortran I基本上是带有数学的汇编语言。在某些方面它比最近的汇编语言功能更弱；例如，没有子程序，只有分支。现在的Fortran可以说更接近Lisp而不是Fortran I。&lt;/p&gt;
&lt;p&gt;Lisp和Fortran是两个独立进化树的树干，一个根植于数学，一个根植于机器架构。这两棵树从那时起一直在收敛。Lisp开始时很强大，在接下来的二十年里变得快速。所谓的主流语言开始时很快，在接下来的四十年里逐渐变得更强大，直到现在它们中最先进的相当接近Lisp。接近，但仍然缺少一些东西。&lt;/p&gt;
&lt;h2 id="使lisp不同的东西"&gt;使Lisp不同的东西&lt;/h2&gt;
&lt;p&gt;当Lisp首次被开发时，它体现了九个新想法。其中一些我们现在认为是理所当然的，其他只在更先进的语言中看到，有两个仍然是Lisp独有的。这九个想法按主流采用的顺序排列，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件语句&lt;/strong&gt;。条件语句是if-then-else结构。我们现在认为这是理所当然的，但Fortran I没有它们。它只有基于底层机器指令的条件goto。&lt;/p&gt;</description></item><item><title>Lisp的不同之处</title><link>https://linguista.cn/person/paul_graham/essays_zh/diff/</link><pubDate>Sat, 01 Dec 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/diff/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/diff/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/diff.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/diff.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/diff.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的不同之处"&gt;Lisp的不同之处&lt;/h1&gt;
&lt;p&gt;2001年12月（修订于2002年5月）&lt;/p&gt;
&lt;p&gt;（本文是回应LL1邮件列表上一些问题而产生的。现在已收录在《书呆子的复仇》中。）&lt;/p&gt;
&lt;p&gt;当McCarthy在1950年代末设计Lisp时，它是对现有语言的彻底突破，其中最重要的是Fortran。&lt;/p&gt;
&lt;p&gt;Lisp体现了九个新思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件语句。&lt;/strong&gt; 条件语句是if-then-else结构。现在我们认为这是理所当然的。它们是McCarthy在开发Lisp过程中发明的。（当时的Fortran只有条件goto，紧密基于底层硬件的分支指令。）McCarthy是Algol委员会的成员，他将条件语句引入Algol，随后传播到大多数其他语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数类型。&lt;/strong&gt; 在Lisp中，函数是一等对象——它们是一种数据类型，就像整数、字符串等，并且有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归。&lt;/strong&gt; 递归当然在Lisp之前作为数学概念存在，但Lisp是第一个支持递归的编程语言。（可以说这在使函数成为一等对象中是隐含的。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量的新概念。&lt;/strong&gt; 在Lisp中，所有变量实际上都是指针。具有类型的是值，而不是变量，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;由表达式组成的程序。&lt;/strong&gt; Lisp程序是表达式的树，每个表达式都返回一个值。（在某些Lisp中，表达式可以返回多个值。）这与Fortran和大多数后续语言形成对比，后者区分表达式和语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Fortran中有这种区别是很自然的，因为（在输入格式为打孔卡的语言中不足为奇）该语言是面向行的。你不能嵌套语句。因此，虽然你需要表达式来进行数学运算，但让其他任何东西返回值都没有意义，因为不可能有任何东西在等待它。&lt;/p&gt;
&lt;p&gt;随着块结构语言的出现，这个限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们的后代。&lt;/p&gt;
&lt;p&gt;当一种语言完全由表达式构成时，你可以任意组合表达式。你可以说（使用Arc语法）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(if foo (= x 1) (= x 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(= x (if foo 1 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="7"&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;符号类型。&lt;/strong&gt; 符号与字符串的不同在于你可以通过比较指针来测试相等性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用符号树表示代码的记号。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;整个语言始终可用。&lt;/strong&gt; 读取时间、编译时间和运行时间之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp用作扩展语言的基础，如在Emacs等程序中；在运行时读取使程序能够使用s表达式进行通信，这个想法最近被重新发明为XML。&lt;/p&gt;
&lt;p&gt;当Lisp首次发明时，所有这些想法都与当时的普通编程实践相去甚远，后者主要由1950年代末可用的硬件决定。&lt;/p&gt;
&lt;p&gt;随着时间的推移，体现在一系列流行语言中的默认语言逐渐向Lisp演变。1-5现在已经广泛传播。6开始出现在主流中。Python具有7的一种形式，尽管似乎没有任何语法支持它。8（与9一起）是使Lisp宏成为可能的特性，到目前为止仍然是Lisp独有的，也许是因为（a）它需要那些括号，或者同样糟糕的东西，（b）如果你添加这最后的力量增量，你不能再声称发明了一种新语言，而只是设计了一种新的Lisp方言 ;-)&lt;/p&gt;
&lt;p&gt;虽然对当今的程序员有用，但通过描述Lisp与其他语言采用的随机权宜之计的差异来描述它是很奇怪的。这可能不是McCarthy对它的看法。Lisp不是设计来修复Fortran中的错误；它更像是试图将计算公理化的副产品。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;</description></item><item><title>为什么 Arc 不是特别面向对象的</title><link>https://linguista.cn/person/paul_graham/essays_zh/noop/</link><pubDate>Mon, 01 Oct 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/noop/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/noop/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/noop.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/noop.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/noop.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="为什么-arc-不是特别面向对象的"&gt;为什么 Arc 不是特别面向对象的&lt;/h1&gt;
&lt;p&gt;目前有一种对面向对象编程的狂热，但我认识的一些最聪明的程序员是对此最不兴奋的人。&lt;/p&gt;
&lt;p&gt;我自己的感觉是，面向对象编程在某些情况下是一种有用的技术，但它不是必须渗透到你写的每个程序中的东西。你应该能够定义新类型，但不必将每个程序都表达为新类型的定义。&lt;/p&gt;
&lt;p&gt;我认为人们喜欢面向对象编程有五个原因，其中三个半是坏的：&lt;/p&gt;
&lt;p&gt;如果你有一个静态类型的语言，没有词法闭包或宏，面向对象编程是令人兴奋的。在某种程度上，它提供了一种绕过这些限制的方法。（见 Greenspun 第十规则。）&lt;/p&gt;
&lt;p&gt;面向对象编程在大公司很受欢迎，因为它适合他们编写软件的方式。在大公司，软件往往由大量（且经常变动的）平庸程序员团队编写。面向对象编程对这些程序员施加了一种纪律，防止任何一个人造成太大的损害。代价是产生的代码充满了协议和重复。这对大公司来说不是太高的价格，因为他们的软件无论如何都可能是臃肿和充满重复的。&lt;/p&gt;
&lt;p&gt;面向对象编程产生了很多看起来像工作的东西。在折叠纸的时代，有一种程序员只会在一页上放五到十行代码，前面是二十行精心格式化的注释。面向对象编程对这些来说就像可卡因：它让你将所有这些脚手架直接整合到源代码中。Lisp 黑客可能通过将符号推到列表上来处理的东西，变成了整个类的文件和方法。所以如果你想说服自己或其他人你正在做很多工作，这是一个好工具。&lt;/p&gt;
&lt;p&gt;如果语言本身是一个面向对象的程序，它可以被用户扩展。嗯，也许。或者也许你可以通过提供面向对象编程的子概念单点来做得更好。例如，重载本质上并不与类绑定。我们拭目以待。&lt;/p&gt;
&lt;p&gt;面向对象的抽象很好地映射到某些特定类型程序的领域，比如模拟和 CAD 系统。&lt;/p&gt;
&lt;p&gt;我个人从来不需要面向对象的抽象。Common Lisp 有一个极其强大的对象系统，我从未使用过一次。我做过很多事情（例如，制作充满闭包的哈希表），这些在较弱的语言中需要面向对象技术，但我从未不得不使用 CLOS。&lt;/p&gt;
&lt;p&gt;也许我只是很愚蠢，或者只在应用程序的有限子集上工作过。基于自己的编程经验设计语言是有危险的。但放入你从未需要的东西因为它被认为是个好主意似乎更危险。&lt;/p&gt;</description></item><item><title>Lisp的根源</title><link>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/rootsoflisp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/rootsoflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/rootsoflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/rootsoflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的根源"&gt;Lisp的根源&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（我写这篇文章是为了帮助自己准确理解McCarthy的发现。你不需要知道这些东西来用Lisp编程，但对于想要理解Lisp本质的人来说——无论是从起源还是语义核心的角度——这应该是有帮助的。Lisp拥有这样一个核心是其区别于其他语言的特征之一，也是为什么与其他语言不同，Lisp有方言的原因。）&lt;/p&gt;
&lt;p&gt;1960年，John McCarthy发表了一篇非凡的论文，他在编程领域做了类似于欧几里得对几何学所做的事情。他展示了，给定一些简单的操作符和函数表示法，如何构建一个完整的编程语言。他称这种语言为Lisp，即&amp;quot;列表处理&amp;quot;，因为他的一个关键想法是使用一种称为列表的简单数据结构来同时表示代码和数据。&lt;/p&gt;
&lt;p&gt;值得理解McCarthy的发现，不仅作为计算机史上的里程碑，而且作为我们时代编程发展方向的模型。在我看来，迄今为止有两个真正干净、一致的编程模型：C模型和Lisp模型。这两个模型似乎像是高地，之间是沼泽般的低地。随着计算机变得越来越强大，正在开发的新语言一直在稳步向Lisp模型移动。过去20年来，新编程语言的一个流行配方是采用C计算模型，然后零散地添加从Lisp模型中提取的部分，如运行时类型和垃圾收集。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将尝试用最简单的术语解释McCarthy的发现。重点不仅仅是了解某人40年前想出的一个有趣的理论结果，而是展示语言的发展方向。Lisp的不寻常之处——事实上，Lisp的定义性特征——是它可以用自身来编写。要理解McCarthy的意思，我们将追溯他的步骤，将他的数学表示法转换为运行的Common Lisp代码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注意：这似乎是一篇较长文章的介绍或摘要。全文可能作为PostScript文件提供，在原始来源中链接为&amp;quot;Complete Article (Postscript)&amp;quot;。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What Made Lisp Different&lt;/li&gt;
&lt;li&gt;The Code&lt;/li&gt;
&lt;li&gt;中文翻译&lt;/li&gt;
&lt;li&gt;日语翻译&lt;/li&gt;
&lt;li&gt;葡萄牙语翻译&lt;/li&gt;
&lt;li&gt;韩语翻译&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>关于语言设计的五个问题</title><link>https://linguista.cn/person/paul_graham/essays_zh/langdes/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/langdes/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/langdes/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/langdes.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/langdes.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/langdes.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="关于语言设计的五个问题"&gt;关于语言设计的五个问题&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;
&lt;h2 id="1-编程语言是为人设计的"&gt;1. 编程语言是为人设计的。&lt;/h2&gt;
&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;
&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;
&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;
&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;
&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;
&lt;h2 id="2-为自己和你的朋友设计"&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;
&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;
&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;
&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;
&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;
&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;
&lt;h2 id="3-给程序员尽可能多的控制权"&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;
&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;
&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;
&lt;h2 id="4-追求简洁"&gt;4. 追求简洁。&lt;/h2&gt;
&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;
&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;
&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;
&lt;h2 id="5-承认黑客的本质"&gt;5. 承认黑客的本质。&lt;/h2&gt;
&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;
&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;
&lt;h2 id="开放性问题"&gt;开放性问题&lt;/h2&gt;
&lt;h3 id="1-如何组织大型库"&gt;1. 如何组织大型库？&lt;/h3&gt;
&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;
&lt;h3 id="2-人们真的害怕前缀语法吗"&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;
&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;
&lt;h3 id="3-基于服务器的软件需要什么"&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;
&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;
&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;
&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;
&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;
&lt;h3 id="4-还有什么新的抽象有待发现"&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;
&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;</description></item><item><title>如何变得流行</title><link>https://linguista.cn/person/paul_graham/essays_zh/popular/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/popular/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/popular/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/popular.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/popular.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/popular.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="如何变得流行"&gt;如何变得流行&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（本文是作为一种新语言的商业计划书而写的。因此它缺少（因为想当然）一个好的编程语言最重要的特征：非常强大的抽象能力。）&lt;/p&gt;
&lt;p&gt;我有一个朋友曾经告诉一位著名的操作系统专家，他想设计一种真正好的编程语言。专家告诉他，这将是浪费时间，编程语言不会因为其优点而变得流行或不流行，所以无论他的语言有多好，都没人会使用。至少，这是他设计的语言所发生的情况。&lt;/p&gt;
&lt;p&gt;到底是什么让一种语言变得流行？流行的语言是否配得上它们的流行度？试图定义一个好的编程语言是否值得？你会怎么做？&lt;/p&gt;
&lt;p&gt;我认为这些问题的答案可以通过观察黑客并了解他们想要什么来找到。编程语言是为黑客而设计的，而编程语言作为编程语言（而不是，比如说，作为指称语义练习或编译器设计练习）是好的，当且仅当黑客喜欢它。&lt;/p&gt;
&lt;h2 id="1-流行的机制"&gt;1 流行的机制&lt;/h2&gt;
&lt;p&gt;当然，大多数人在选择编程语言时并不仅仅基于它们的优点。大多数程序员被告知要使用什么语言。然而我认为这些外部因素对编程语言流行度的影响并不像人们有时认为的那么大。我认为更大的问题是黑客对好的编程语言的想法与大多数语言设计者的想法不同。&lt;/p&gt;
&lt;p&gt;在这两者之间，黑客的意见才是重要的。编程语言不是定理。它们是工具，为人们设计的，必须像鞋子必须为人类的脚设计一样，适合人类的优点和缺点。如果鞋子穿上时夹脚，那它就是一双坏鞋，无论它作为雕塑品多么优雅。&lt;/p&gt;
&lt;p&gt;可能是大多数程序员无法区分好语言和坏语言。但这与其他工具没有什么不同。这并不意味着尝试设计好语言是浪费时间。专家黑客在看到好语言时能够识别出来，他们会使用它。诚然，专家黑客是极少数，但这个极少数群体编写了所有好的软件，他们的影响力使得其他程序员倾向于使用他们使用的任何语言。通常，这不仅仅是影响，而是命令：专家黑客通常就是那些作为老板或导师告诉其他程序员使用什么语言的人。&lt;/p&gt;
&lt;p&gt;专家黑客的意见并不是决定编程语言相对流行度的唯一力量——遗留软件（Cobol）和炒作（Ada、Java）也起作用——但我认为它是长期内最强大的力量。考虑到初始的关键质量和足够的时间，编程语言可能会变得与其应得的流行度相当。而流行度进一步将好语言与坏语言分开，因为来自真实用户的反馈总是导致改进。看看任何流行语言在其生命周期中发生了多大变化。Perl和Fortran是极端的例子，但即使是Lisp也发生了很大变化。例如，Lisp 1.5没有宏；这些是后来发展的，在麻省理工学院的黑客花了几年时间使用Lisp编写真实程序之后。[1]&lt;/p&gt;
&lt;p&gt;所以无论一种语言是否必须好才能流行，我认为一种语言必须流行才能好。它必须保持流行才能保持好。编程语言的工艺水平不会停滞不前。然而我们今天拥有的Lisp几乎与麻省理工学院在1980年代中期的Lisp相同，因为那是Lisp最后一次拥有足够大和要求高的用户群的时候。&lt;/p&gt;
&lt;p&gt;当然，黑客在使用语言之前必须了解它。他们如何听到？从其他黑客那里。但必须有一些初始的黑客群体使用该语言，其他人才能听到。我想知道这个群体必须多大；多少用户构成关键质量？我随口一说，二十个。如果一种语言有二十个独立的用户，意味着二十个用户自己决定使用它，我会认为它是真实的。&lt;/p&gt;
&lt;p&gt;达到那里并不容易。如果从零到二十比从二十到一千更难，我不会感到惊讶。获得那初始二十个用户的最好方法可能是使用特洛伊木马：给人们一个他们想要的应用程序，而这个应用程序恰好是用新语言编写的。&lt;/p&gt;
&lt;h2 id="2-外部因素"&gt;2 外部因素&lt;/h2&gt;
&lt;p&gt;让我们首先承认一个确实影响编程语言流行度的外部因素。要变得流行，编程语言必须是流行系统的脚本语言。Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来Perl也是。Tcl是Tk的脚本语言。Java和Javascript旨在成为Web浏览器的脚本语言。&lt;/p&gt;
&lt;p&gt;Lisp不是一个大规模流行的语言，因为它不是大规模流行系统的脚本语言。它保留的流行度可以追溯到1960年代和1970年代，当时它是麻省理工学院的脚本语言。当时的许多伟大程序员都在某个时期与麻省理工学院有关联。在1970年代初期，在C之前，麻省理工学院的Lisp方言MacLisp是严肃黑客想要使用的唯一编程语言之一。&lt;/p&gt;
&lt;p&gt;今天，Lisp是两个适度流行系统的脚本语言，Emacs和Autocad，因此我怀疑今天大部分Lisp编程都是在Emacs Lisp或AutoLisp中完成的。&lt;/p&gt;
&lt;p&gt;编程语言不是孤立存在的。Hack是一个及物动词——黑客通常在hack某物——在实践中，语言是相对于它们用来hack的任何东西来评判的。所以如果你想设计一种流行的语言，你要么必须提供比语言更多的东西，要么你必须设计你的语言来取代某个现有系统的脚本语言。&lt;/p&gt;
&lt;p&gt;Common Lisp不受欢迎的部分原因是因为它是一个孤儿。它确实伴随着一个要hack的系统：Lisp Machine。但Lisp Machines（以及并行计算机）在1980年代被通用处理器日益增长的力量压垮了。如果Common Lisp是Unix的好脚本语言，它可能会保持流行。唉，它是一个非常糟糕的脚本语言。&lt;/p&gt;
&lt;p&gt;描述这种情况的一种方法是说语言不是根据其自身的优点来评判的。另一种观点是，编程语言除非也是某物的脚本语言，否则就不是真正的编程语言。如果这让人感到意外，这似乎不公平。我认为这并不比期望编程语言有实现更不公平。这只是编程语言的一部分。&lt;/p&gt;
&lt;p&gt;当然，编程语言需要好的实现，而且这必须是免费的。公司会为软件付费，但个人黑客不会，而你需要吸引的是黑客。&lt;/p&gt;
&lt;p&gt;语言也需要有一本关于它的书。这本书应该是薄的、写得好的，充满了好的例子。K&amp;amp;R是这里的理想。目前我几乎会说一种语言必须有一本O&amp;rsquo;Reilly出版的书。这正成为对黑客重要性的测试。&lt;/p&gt;
&lt;p&gt;也应该有在线文档。事实上，书可以作为在线文档开始。但我不认为物理书已经过时了。它们的格式方便，出版商施加的事实审查是一种有用的、虽然不完美的过滤器。书店是学习新语言的最重要地方之一。&lt;/p&gt;
&lt;h2 id="3-简洁"&gt;3 简洁&lt;/h2&gt;
&lt;p&gt;假设你能提供任何语言需要的三个东西——一个免费的实现、一本书、以及要hack的东西——你如何制造一种黑客会喜欢的语言？&lt;/p&gt;
&lt;p&gt;黑客喜欢的一件事是简洁。黑客是懒惰的，与数学家和现代主义建筑师是懒惰的方式相同：他们讨厌任何多余的东西。说一个即将编写程序的黑客基于他必须键入的字符总数来选择使用什么语言，至少是潜意识的，这离真相不远。如果这不是黑客思考的精确方式，语言设计者最好表现得好像是这样。&lt;/p&gt;
&lt;p&gt;试图用冗长的表达来宠用户，这些表达旨在类似英语，是错误的。Cobol因此缺陷而臭名昭著。黑客会认为被要求写&lt;/p&gt;
&lt;p&gt;add x to y giving z&lt;/p&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;p&gt;z = x+y&lt;/p&gt;</description></item><item><title>Java的外衣</title><link>https://linguista.cn/person/paul_graham/essays_zh/javacover/</link><pubDate>Sun, 01 Apr 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/javacover/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/javacover/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/javacover.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/javacover.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/javacover.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="java的外衣"&gt;Java的外衣&lt;/h1&gt;
&lt;p&gt;2001年4月&lt;/p&gt;
&lt;p&gt;这篇文章源于我与几位程序员关于Java为何气味可疑的对话。这不是对Java的批判！这是黑客雷达的一个案例研究。&lt;/p&gt;
&lt;p&gt;随着时间的推移，黑客对好（和坏）技术培养出了一种嗅觉。我想试着写下是什么让Java对我来说似乎可疑，这可能会很有趣。&lt;/p&gt;
&lt;p&gt;一些读过这篇文章的人认为这是试图以前所未有的方式写一些有趣的事情。其他人说我将因为看起来写我不理解的东西而陷入麻烦。所以，以防万一有任何好处，让我澄清我在这里不是在写Java（我从未使用过），而是在写黑客雷达（我对此思考很多）。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;不能凭封面判断一本书&amp;quot;这句格言起源于书籍用普通纸板封面出售的时代，由每个购买者根据自己的品味装订。在那个时代，你不能凭封面判断一本书。但出版业从那时起进步了：现在的出版商努力使封面成为你可以判断一本书的依据。&lt;/p&gt;
&lt;p&gt;我花了很多时间在书店，我觉得我现在已经学会理解出版商想要告诉我关于一本书的一切，可能还有更多。我没有在书店度过的时间主要花在电脑前，我觉得我在某种程度上已经学会了通过封面来判断技术。这可能只是运气，但我已经让自己避免了一些最终被证明是真正糟糕的技术。&lt;/p&gt;
&lt;p&gt;到目前为止，Java对我来说似乎很糟糕。我从未写过Java程序，从未看过关于它的参考书，但我有一个预感，它不会是一种非常成功的语言。我可能被证明是错的；对技术做出预测是危险的事情。但作为某种时间胶囊，就其价值而言，这就是为什么我不喜欢Java的外观：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它被如此热情地炒作。真正的标准不需要被推广。没有人需要推广C、Unix或HTML。真正的标准在大多数人听到它之前就已经建立了。在黑客雷达屏幕上，Perl和Java一样大，或者更大，仅仅是凭借自身的优点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的目标很低。在最初的Java白皮书中，Gosling明确表示Java的设计对习惯C的程序员来说不会太困难。它被设计成另一个C++：C加上一些从更高级语言中借来的想法。就像情景喜剧、垃圾食品或包价旅游的创造者一样，Java的设计者有意识地为不如他们聪明的人设计产品。历史上，为他人使用而设计的语言都很糟糕：Cobol、PL/I、Pascal、Ada、C++。好的语言是那些为自己的设计者设计的：C、Perl、Smalltalk、Lisp。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有不可告人的动机。有人说过，如果人们只在有话要说时才写书，而不是因为想写书，世界会变得更美好。同样，我们一直听到Java的原因不是因为它对编程语言有什么要说的。我们听到Java作为Sun公司削弱微软计划的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有人喜欢它。C、Perl、Python、Smalltalk和Lisp程序员都喜欢他们的语言。我从未听任何人说过他们喜欢Java。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人们被迫使用它。我认识的许多使用Java的人使用它是因为他们觉得必须这样做。要么是他们觉得为了获得资助必须这样做，要么是他们认为客户会想要，要么是管理层告诉他们要这样做。这些都是聪明人；如果技术好，他们会自愿使用它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有太多的厨师。最好的编程语言是由小团体开发的。Java似乎是由一个委员会管理的。如果它最终成为一种好语言，这将是历史上委员会第一次设计出好语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是官僚主义的。据我对Java的一点点了解，似乎有很多做事的协议。真正的好语言不是那样的。它们让你做你想做的事，然后让路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是伪时髦的。Sun现在假装Java是一种像Perl或Python那样的草根、开源语言努力。这个恰好由一家大公司控制。所以这种语言很可能具有与大公司生产的任何东西相同的单调笨重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是为大型组织设计的。大型组织的目标与黑客不同。他们想要适合大型平庸程序员团队使用的语言——具有像U-Haul卡车中的限速器那样的功能，防止傻瓜造成太大损害。黑客不喜欢对他们居高临下的语言。黑客只想要力量。历史上，为大型组织设计的语言（PL/I、Ada）都失败了，而黑客语言（C、Perl）获胜了。原因：今天的青少年黑客是明天的CTO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误的人喜欢它。我最钦佩的程序员整体上没有被Java迷住。谁喜欢Java？西装革履的人，不知道一种语言与另一种的区别，但知道他们在媒体上不断听到Java；大公司的程序员，惊讶地发现还有比C++更好的东西；以及即插即用的本科生，准备好喜欢任何可能让他们找到工作的东西（这会考试吗？）。这些人的意见随风而变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的爸爸陷入困境。Sun的商业模式正受到两方面的侵蚀。与台式机相同类型的廉价Intel处理器现在对服务器来说已经足够快了。而且FreeBSD似乎至少与Solaris一样适合作为服务器操作系统。Sun的广告暗示你需要Sun服务器用于工业级应用程序。如果这是真的，Yahoo会第一个排队购买Sun；但当我在那里工作时，服务器都是运行FreeBSD的Intel盒子。这对Sun的未来是个坏兆头。如果Sun遇到麻烦，他们可能会把Java拖下水。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;国防部喜欢它。国防部鼓励开发者使用Java。这在我看来是最 damning 的迹象。国防部的国防工作做得很好（虽然昂贵），但他们喜欢计划、程序和协议。他们的文化与黑客文化相反；在软件问题上他们往往会下错注。国防部最后一次真正喜欢一种编程语言是Ada。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请记住，这不是对Java的批判，而是对其外衣的批判。我对Java的了解还不足以喜欢或不喜欢它。这只是为什么我不觉得急于学习它的解释。&lt;/p&gt;
&lt;p&gt;在尝试用一种语言编写程序之前就将其 dismissed 可能看起来 cavalier。但这是所有程序员都必须做的事情。外面的技术太多了，无法全部学习。你必须学会通过外部迹象来判断哪些值得你花时间。我同样 cavalier 地 dismissed 了Cobol、Ada、Visual Basic、IBM AS400、VRML、ISO 9000、SET协议、VMS、Novell Netware和CORBA等。它们只是气味不对。&lt;/p&gt;
&lt;p&gt;在Java的情况下我可能错了。可能一种由一家大公司推广以削弱另一家大公司、由委员会为&amp;quot;主流&amp;quot;受众设计、被炒作到天际、国防部喜欢的语言，碰巧是一种我会喜欢编程的干净、美丽、强大的语言。可能，但这似乎非常不可能。&lt;/p&gt;
&lt;p&gt;Trevor Re: Java&amp;rsquo;s Cover | Berners-Lee Re: Java | Being Popular | Sun Internal Memo | 2005: BusinessWeek Agrees&lt;/p&gt;</description></item></channel></rss>