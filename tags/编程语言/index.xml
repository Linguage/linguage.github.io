<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程语言 on Linguista</title>
    <link>https://linguage.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
    <description>Recent content in 编程语言 on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://linguage.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java的外衣</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/javacover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/javacover/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/javacover/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;java的外衣&#34;&gt;Java的外衣&lt;/h1&gt;&#xA;&lt;p&gt;2001年4月&lt;/p&gt;&#xA;&lt;p&gt;这篇文章源于我与几位程序员关于Java为何气味可疑的对话。这不是对Java的批判！这是黑客雷达的一个案例研究。&lt;/p&gt;&#xA;&lt;p&gt;随着时间的推移，黑客对好（和坏）技术培养出了一种嗅觉。我想试着写下是什么让Java对我来说似乎可疑，这可能会很有趣。&lt;/p&gt;&#xA;&lt;p&gt;一些读过这篇文章的人认为这是试图以前所未有的方式写一些有趣的事情。其他人说我将因为看起来写我不理解的东西而陷入麻烦。所以，以防万一有任何好处，让我澄清我在这里不是在写Java（我从未使用过），而是在写黑客雷达（我对此思考很多）。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;不能凭封面判断一本书&amp;quot;这句格言起源于书籍用普通纸板封面出售的时代，由每个购买者根据自己的品味装订。在那个时代，你不能凭封面判断一本书。但出版业从那时起进步了：现在的出版商努力使封面成为你可以判断一本书的依据。&lt;/p&gt;&#xA;&lt;p&gt;我花了很多时间在书店，我觉得我现在已经学会理解出版商想要告诉我关于一本书的一切，可能还有更多。我没有在书店度过的时间主要花在电脑前，我觉得我在某种程度上已经学会了通过封面来判断技术。这可能只是运气，但我已经让自己避免了一些最终被证明是真正糟糕的技术。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，Java对我来说似乎很糟糕。我从未写过Java程序，从未看过关于它的参考书，但我有一个预感，它不会是一种非常成功的语言。我可能被证明是错的；对技术做出预测是危险的事情。但作为某种时间胶囊，就其价值而言，这就是为什么我不喜欢Java的外观：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它被如此热情地炒作。真正的标准不需要被推广。没有人需要推广C、Unix或HTML。真正的标准在大多数人听到它之前就已经建立了。在黑客雷达屏幕上，Perl和Java一样大，或者更大，仅仅是凭借自身的优点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它的目标很低。在最初的Java白皮书中，Gosling明确表示Java的设计对习惯C的程序员来说不会太困难。它被设计成另一个C++：C加上一些从更高级语言中借来的想法。就像情景喜剧、垃圾食品或包价旅游的创造者一样，Java的设计者有意识地为不如他们聪明的人设计产品。历史上，为他人使用而设计的语言都很糟糕：Cobol、PL/I、Pascal、Ada、C++。好的语言是那些为自己的设计者设计的：C、Perl、Smalltalk、Lisp。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它有不可告人的动机。有人说过，如果人们只在有话要说时才写书，而不是因为想写书，世界会变得更美好。同样，我们一直听到Java的原因不是因为它对编程语言有什么要说的。我们听到Java作为Sun公司削弱微软计划的一部分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;没有人喜欢它。C、Perl、Python、Smalltalk和Lisp程序员都喜欢他们的语言。我从未听任何人说过他们喜欢Java。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;人们被迫使用它。我认识的许多使用Java的人使用它是因为他们觉得必须这样做。要么是他们觉得为了获得资助必须这样做，要么是他们认为客户会想要，要么是管理层告诉他们要这样做。这些都是聪明人；如果技术好，他们会自愿使用它。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它有太多的厨师。最好的编程语言是由小团体开发的。Java似乎是由一个委员会管理的。如果它最终成为一种好语言，这将是历史上委员会第一次设计出好语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是官僚主义的。据我对Java的一点点了解，似乎有很多做事的协议。真正的好语言不是那样的。它们让你做你想做的事，然后让路。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是伪时髦的。Sun现在假装Java是一种像Perl或Python那样的草根、开源语言努力。这个恰好由一家大公司控制。所以这种语言很可能具有与大公司生产的任何东西相同的单调笨重。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是为大型组织设计的。大型组织的目标与黑客不同。他们想要适合大型平庸程序员团队使用的语言——具有像U-Haul卡车中的限速器那样的功能，防止傻瓜造成太大损害。黑客不喜欢对他们居高临下的语言。黑客只想要力量。历史上，为大型组织设计的语言（PL/I、Ada）都失败了，而黑客语言（C、Perl）获胜了。原因：今天的青少年黑客是明天的CTO。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;错误的人喜欢它。我最钦佩的程序员整体上没有被Java迷住。谁喜欢Java？西装革履的人，不知道一种语言与另一种的区别，但知道他们在媒体上不断听到Java；大公司的程序员，惊讶地发现还有比C++更好的东西；以及即插即用的本科生，准备好喜欢任何可能让他们找到工作的东西（这会考试吗？）。这些人的意见随风而变。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它的爸爸陷入困境。Sun的商业模式正受到两方面的侵蚀。与台式机相同类型的廉价Intel处理器现在对服务器来说已经足够快了。而且FreeBSD似乎至少与Solaris一样适合作为服务器操作系统。Sun的广告暗示你需要Sun服务器用于工业级应用程序。如果这是真的，Yahoo会第一个排队购买Sun；但当我在那里工作时，服务器都是运行FreeBSD的Intel盒子。这对Sun的未来是个坏兆头。如果Sun遇到麻烦，他们可能会把Java拖下水。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;国防部喜欢它。国防部鼓励开发者使用Java。这在我看来是最 damning 的迹象。国防部的国防工作做得很好（虽然昂贵），但他们喜欢计划、程序和协议。他们的文化与黑客文化相反；在软件问题上他们往往会下错注。国防部最后一次真正喜欢一种编程语言是Ada。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;请记住，这不是对Java的批判，而是对其外衣的批判。我对Java的了解还不足以喜欢或不喜欢它。这只是为什么我不觉得急于学习它的解释。&lt;/p&gt;&#xA;&lt;p&gt;在尝试用一种语言编写程序之前就将其 dismissed 可能看起来 cavalier。但这是所有程序员都必须做的事情。外面的技术太多了，无法全部学习。你必须学会通过外部迹象来判断哪些值得你花时间。我同样 cavalier 地 dismissed 了Cobol、Ada、Visual Basic、IBM AS400、VRML、ISO 9000、SET协议、VMS、Novell Netware和CORBA等。它们只是气味不对。&lt;/p&gt;&#xA;&lt;p&gt;在Java的情况下我可能错了。可能一种由一家大公司推广以削弱另一家大公司、由委员会为&amp;quot;主流&amp;quot;受众设计、被炒作到天际、国防部喜欢的语言，碰巧是一种我会喜欢编程的干净、美丽、强大的语言。可能，但这似乎非常不可能。&lt;/p&gt;&#xA;&lt;p&gt;Trevor Re: Java&amp;rsquo;s Cover | Berners-Lee Re: Java | Being Popular | Sun Internal Memo | 2005: BusinessWeek Agrees&lt;/p&gt;&#xA;&lt;p&gt;日语翻译&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lisp的不同之处</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/diff/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/diff/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/diff/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;lisp的不同之处&#34;&gt;Lisp的不同之处&lt;/h1&gt;&#xA;&lt;p&gt;2001年12月（修订于2002年5月）&lt;/p&gt;&#xA;&lt;p&gt;（本文是回应LL1邮件列表上一些问题而产生的。现在已收录在《书呆子的复仇》中。）&lt;/p&gt;&#xA;&lt;p&gt;当McCarthy在1950年代末设计Lisp时，它是对现有语言的彻底突破，其中最重要的是Fortran。&lt;/p&gt;&#xA;&lt;p&gt;Lisp体现了九个新思想：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件语句。&lt;/strong&gt; 条件语句是if-then-else结构。现在我们认为这是理所当然的。它们是McCarthy在开发Lisp过程中发明的。（当时的Fortran只有条件goto，紧密基于底层硬件的分支指令。）McCarthy是Algol委员会的成员，他将条件语句引入Algol，随后传播到大多数其他语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;函数类型。&lt;/strong&gt; 在Lisp中，函数是一等对象——它们是一种数据类型，就像整数、字符串等，并且有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;递归。&lt;/strong&gt; 递归当然在Lisp之前作为数学概念存在，但Lisp是第一个支持递归的编程语言。（可以说这在使函数成为一等对象中是隐含的。）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;变量的新概念。&lt;/strong&gt; 在Lisp中，所有变量实际上都是指针。具有类型的是值，而不是变量，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;垃圾回收。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;由表达式组成的程序。&lt;/strong&gt; Lisp程序是表达式的树，每个表达式都返回一个值。（在某些Lisp中，表达式可以返回多个值。）这与Fortran和大多数后续语言形成对比，后者区分表达式和语句。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在Fortran中有这种区别是很自然的，因为（在输入格式为打孔卡的语言中不足为奇）该语言是面向行的。你不能嵌套语句。因此，虽然你需要表达式来进行数学运算，但让其他任何东西返回值都没有意义，因为不可能有任何东西在等待它。&lt;/p&gt;&#xA;&lt;p&gt;随着块结构语言的出现，这个限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们的后代。&lt;/p&gt;&#xA;&lt;p&gt;当一种语言完全由表达式构成时，你可以任意组合表达式。你可以说（使用Arc语法）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(if foo (= x 1) (= x 2))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(= x (if foo 1 2))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;符号类型。&lt;/strong&gt; 符号与字符串的不同在于你可以通过比较指针来测试相等性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;使用符号树表示代码的记号。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;整个语言始终可用。&lt;/strong&gt; 读取时间、编译时间和运行时间之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp用作扩展语言的基础，如在Emacs等程序中；在运行时读取使程序能够使用s表达式进行通信，这个想法最近被重新发明为XML。&lt;/p&gt;&#xA;&lt;p&gt;当Lisp首次发明时，所有这些想法都与当时的普通编程实践相去甚远，后者主要由1950年代末可用的硬件决定。&lt;/p&gt;&#xA;&lt;p&gt;随着时间的推移，体现在一系列流行语言中的默认语言逐渐向Lisp演变。1-5现在已经广泛传播。6开始出现在主流中。Python具有7的一种形式，尽管似乎没有任何语法支持它。8（与9一起）是使Lisp宏成为可能的特性，到目前为止仍然是Lisp独有的，也许是因为（a）它需要那些括号，或者同样糟糕的东西，（b）如果你添加这最后的力量增量，你不能再声称发明了一种新语言，而只是设计了一种新的Lisp方言 ;-)&lt;/p&gt;&#xA;&lt;p&gt;虽然对当今的程序员有用，但通过描述Lisp与其他语言采用的随机权宜之计的差异来描述它是很奇怪的。这可能不是McCarthy对它的看法。Lisp不是设计来修复Fortran中的错误；它更像是试图将计算公理化的副产品。&lt;/p&gt;&#xA;&lt;p&gt;相关链接：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.aoky.net/articles/paul_graham/what_made_lisp_different_japanese.htm&#34;&gt;日语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Lisp的根源</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/rootsoflisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/rootsoflisp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/rootsoflisp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;lisp的根源&#34;&gt;Lisp的根源&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（我写这篇文章是为了帮助自己准确理解McCarthy的发现。你不需要知道这些东西来用Lisp编程，但对于想要理解Lisp本质的人来说——无论是从起源还是语义核心的角度——这应该是有帮助的。Lisp拥有这样一个核心是其区别于其他语言的特征之一，也是为什么与其他语言不同，Lisp有方言的原因。）&lt;/p&gt;&#xA;&lt;p&gt;1960年，John McCarthy发表了一篇非凡的论文，他在编程领域做了类似于欧几里得对几何学所做的事情。他展示了，给定一些简单的操作符和函数表示法，如何构建一个完整的编程语言。他称这种语言为Lisp，即&amp;quot;列表处理&amp;quot;，因为他的一个关键想法是使用一种称为列表的简单数据结构来同时表示代码和数据。&lt;/p&gt;&#xA;&lt;p&gt;值得理解McCarthy的发现，不仅作为计算机史上的里程碑，而且作为我们时代编程发展方向的模型。在我看来，迄今为止有两个真正干净、一致的编程模型：C模型和Lisp模型。这两个模型似乎像是高地，之间是沼泽般的低地。随着计算机变得越来越强大，正在开发的新语言一直在稳步向Lisp模型移动。过去20年来，新编程语言的一个流行配方是采用C计算模型，然后零散地添加从Lisp模型中提取的部分，如运行时类型和垃圾收集。&lt;/p&gt;&#xA;&lt;p&gt;在这篇文章中，我将尝试用最简单的术语解释McCarthy的发现。重点不仅仅是了解某人40年前想出的一个有趣的理论结果，而是展示语言的发展方向。Lisp的不寻常之处——事实上，Lisp的定义性特征——是它可以用自身来编写。要理解McCarthy的意思，我们将追溯他的步骤，将他的数学表示法转换为运行的Common Lisp代码。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;注意：这似乎是一篇较长文章的介绍或摘要。全文可能作为PostScript文件提供，在原始来源中链接为&amp;quot;Complete Article (Postscript)&amp;quot;。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What Made Lisp Different&lt;/li&gt;&#xA;&lt;li&gt;The Code&lt;/li&gt;&#xA;&lt;li&gt;中文翻译&lt;/li&gt;&#xA;&lt;li&gt;日语翻译&lt;/li&gt;&#xA;&lt;li&gt;葡萄牙语翻译&lt;/li&gt;&#xA;&lt;li&gt;韩语翻译&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>为什么 Arc 不是特别面向对象的</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/noop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/noop/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/noop/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;为什么-arc-不是特别面向对象的&#34;&gt;为什么 Arc 不是特别面向对象的&lt;/h1&gt;&#xA;&lt;p&gt;目前有一种对面向对象编程的狂热，但我认识的一些最聪明的程序员是对此最不兴奋的人。&lt;/p&gt;&#xA;&lt;p&gt;我自己的感觉是，面向对象编程在某些情况下是一种有用的技术，但它不是必须渗透到你写的每个程序中的东西。你应该能够定义新类型，但不必将每个程序都表达为新类型的定义。&lt;/p&gt;&#xA;&lt;p&gt;我认为人们喜欢面向对象编程有五个原因，其中三个半是坏的：&lt;/p&gt;&#xA;&lt;p&gt;如果你有一个静态类型的语言，没有词法闭包或宏，面向对象编程是令人兴奋的。在某种程度上，它提供了一种绕过这些限制的方法。（见 Greenspun 第十规则。）&lt;/p&gt;&#xA;&lt;p&gt;面向对象编程在大公司很受欢迎，因为它适合他们编写软件的方式。在大公司，软件往往由大量（且经常变动的）平庸程序员团队编写。面向对象编程对这些程序员施加了一种纪律，防止任何一个人造成太大的损害。代价是产生的代码充满了协议和重复。这对大公司来说不是太高的价格，因为他们的软件无论如何都可能是臃肿和充满重复的。&lt;/p&gt;&#xA;&lt;p&gt;面向对象编程产生了很多看起来像工作的东西。在折叠纸的时代，有一种程序员只会在一页上放五到十行代码，前面是二十行精心格式化的注释。面向对象编程对这些来说就像可卡因：它让你将所有这些脚手架直接整合到源代码中。Lisp 黑客可能通过将符号推到列表上来处理的东西，变成了整个类的文件和方法。所以如果你想说服自己或其他人你正在做很多工作，这是一个好工具。&lt;/p&gt;&#xA;&lt;p&gt;如果语言本身是一个面向对象的程序，它可以被用户扩展。嗯，也许。或者也许你可以通过提供面向对象编程的子概念单点来做得更好。例如，重载本质上并不与类绑定。我们拭目以待。&lt;/p&gt;&#xA;&lt;p&gt;面向对象的抽象很好地映射到某些特定类型程序的领域，比如模拟和 CAD 系统。&lt;/p&gt;&#xA;&lt;p&gt;我个人从来不需要面向对象的抽象。Common Lisp 有一个极其强大的对象系统，我从未使用过一次。我做过很多事情（例如，制作充满闭包的哈希表），这些在较弱的语言中需要面向对象技术，但我从未不得不使用 CLOS。&lt;/p&gt;&#xA;&lt;p&gt;也许我只是很愚蠢，或者只在应用程序的有限子集上工作过。基于自己的编程经验设计语言是有危险的。但放入你从未需要的东西因为它被认为是个好主意似乎更危险。&lt;/p&gt;</description>
    </item>
    <item>
      <title>书呆子的复仇</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/icad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/icad/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/icad/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;书呆子的复仇&#34;&gt;书呆子的复仇&lt;/h1&gt;&#xA;&lt;p&gt;想要创业？获得Y Combinator的投资。&lt;/p&gt;&#xA;&lt;p&gt;2002年5月&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;我们当时在追逐C++程序员。我们成功地将他们中的许多人拖到了Lisp的路上。&amp;rdquo;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Guy Steele，Java规范合著者&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在软件行业中，一直存在着一场持续的斗争，一方是尖脑袋的学者，另一方是同样强大的力量——尖头发的老板。大家都知道尖头发的老板是谁，对吧？我认为技术界的大多数人不仅认识这个卡通人物，而且知道他们公司中这个人物的原型是谁。&lt;/p&gt;&#xA;&lt;p&gt;尖头发的老板奇迹般地结合了两个各自常见但很少同时出现的品质：(a)他对技术一无所知，(b)他对技术有非常强烈的看法。&lt;/p&gt;&#xA;&lt;p&gt;假设，例如，你需要编写一个软件。尖头发的老板对这个软件应该如何工作一无所知，也无法区分一种编程语言和另一种，但他知道你应该用什么语言来编写它。完全正确。他认为你应该用Java来编写。&lt;/p&gt;&#xA;&lt;p&gt;他为什么这么认为？让我们来看看尖头发的老板的大脑里面在想什么。他在想的大概是这样的。Java是一个标准。我知道它一定是标准，因为我总是在媒体上看到它。既然它是标准，我使用它就不会惹上麻烦。这也意味着总会有很多Java程序员，所以如果现在为我工作的程序员辞职了——为我工作的程序员总是神秘地辞职——我可以很容易地替换他们。&lt;/p&gt;&#xA;&lt;p&gt;嗯，这听起来并不那么不合理。但这一切都基于一个未言明的假设，而这个假设结果是错误的。尖头发的老板认为所有编程语言都差不多是等价的。如果这是真的，那他完全正确。如果所有语言都等价，当然，使用其他人都在使用的语言。&lt;/p&gt;&#xA;&lt;p&gt;但并非所有语言都是等价的，我想我甚至不需要深入它们之间的差异就能向你证明这一点。如果你在1992年问尖头发的老板软件应该用什么语言编写，他会像今天一样毫不犹豫地回答。软件应该用C++编写。但如果所有语言都等价，为什么尖头发的老板的意见会改变？事实上，Java的开发者为什么要费心创建一种新语言？&lt;/p&gt;&#xA;&lt;p&gt;据推测，如果你创建一种新语言，那是因为你认为它在某些方面比人们已有的语言更好。事实上，Gosling在第一份Java白皮书中明确表示，Java被设计用来解决C++的一些问题。所以事情就是这样：语言并不都是等价的。如果你顺着尖头发的老板的大脑思路追踪到Java，然后再回溯Java的历史到它的起源，你最终会得到一个与你开始时的假设相矛盾的想法。&lt;/p&gt;&#xA;&lt;p&gt;那么，谁是对的？James Gosling，还是尖头发的老板？毫不奇怪，Gosling是对的。某些语言对于某些问题来说比其他语言更好。你知道，这引发了一些有趣的问题。Java被设计为在特定问题上比C++更好。什么问题？什么时候Java更好，什么时候C++更好？是否存在某些情况下其他语言比两者都更好？&lt;/p&gt;&#xA;&lt;p&gt;一旦你开始考虑这个问题，你就打开了一个真正的潘多拉盒子。如果尖头发的老板不得不以全部复杂性来思考这个问题，他的大脑会爆炸。只要他认为所有语言都等价，他所要做的就是选择一个似乎最有势头的语言，既然这更多是时尚问题而不是技术问题，即使他也可能得到正确的答案。但如果语言各不相同，他突然必须同时解两个方程，试图在他一无所知的两件事之间找到最佳平衡：解决他需要解决的问题的二十种左右主要语言的相对适用性，以及为每种语言找到程序员、库等的可能性。如果门后是这样的东西，尖头发的老板不想打开它也就不足为奇了。&lt;/p&gt;&#xA;&lt;p&gt;认为所有编程语言都等价的缺点是这不是真的。但优点是它让你的生活简单得多。我认为这是这个想法如此广泛传播的主要原因。这是一个令人舒适的想法。&lt;/p&gt;&#xA;&lt;p&gt;我们知道Java一定相当不错，因为它是酷的、新的编程语言。或者真是如此吗？如果你从远处看编程语言的世界，看起来Java是最新的事物。（从足够远的地方看，你只能看到Sun支付的大型闪烁广告牌。）但如果你近距离观察这个世界，你会发现酷的程度是不同的。在黑客亚文化中，有一种叫做Perl的语言被认为比Java酷得多。例如，Slashdot就是用Perl生成的。我想你不会发现那些家伙使用Java Server Pages。但还有另一种更新的语言叫做Python，它的用户倾向于看不起Perl，还有更多的语言在等待。&lt;/p&gt;&#xA;&lt;p&gt;如果你按顺序看这些语言，Java、Perl、Python，你会注意到一个有趣的模式。至少，如果你是Lisp黑客，你会注意到这种模式。每一种都比前一种更像Lisp。Python甚至复制了许多Lisp黑客认为是错误的特性。你可以将简单的Lisp程序逐行翻译成Python。现在是2002年，编程语言几乎赶上了1958年。&lt;/p&gt;&#xA;&lt;h2 id=&#34;追上数学&#34;&gt;追上数学&lt;/h2&gt;&#xA;&lt;p&gt;我的意思是，Lisp是John McCarthy在1958年首次发现的，而流行的编程语言现在才赶上他当时发展的想法。&lt;/p&gt;&#xA;&lt;p&gt;现在，这怎么可能是真的？计算机技术不是变化很快的东西吗？我的意思是，在1958年，计算机是冰箱大小的庞然大物，处理能力相当于手表。怎么可能有那么古老的技术仍然相关，更不用说比最新的发展更优越？&lt;/p&gt;&#xA;&lt;p&gt;我来告诉你原因。这是因为Lisp并不是真正被设计为一种编程语言，至少不是我们今天意义上的编程语言。我们所说的编程语言是我们用来告诉计算机做什么的东西。McCarthy最终确实打算发展这种意义上的编程语言，但我们实际得到的Lisp是基于他作为理论练习所做的另一件事——努力定义一个比图灵机更方便的替代方案。正如McCarthy后来所说，&lt;/p&gt;&#xA;&lt;p&gt;展示Lisp比图灵机更整洁的另一种方法是编写一个通用的Lisp函数，并证明它比通用图灵机的描述更简洁、更易理解。这就是Lisp函数eval&amp;hellip;&amp;hellip;它计算Lisp表达式的值&amp;hellip;&amp;hellip;编写eval需要发明一种表示Lisp函数作为Lisp数据的符号，这种符号是为了论文的目的而设计的，并没有想到它会用来实际表达Lisp程序。&lt;/p&gt;&#xA;&lt;p&gt;接下来发生的事情是，在1958年末的某个时候，Steve Russell，McCarthy的一个研究生，看着这个eval的定义，意识到如果将它翻译成机器语言，结果将是一个Lisp解释器。&lt;/p&gt;&#xA;&lt;p&gt;这在当时是一个很大的惊喜。以下是McCarthy后来在采访中对此的评论：&lt;/p&gt;&#xA;&lt;p&gt;Steve Russell说，看，为什么我不来编程这个eval&amp;hellip;&amp;hellip;，我对他说，呵，呵，你把理论和实践混淆了，这个eval是为了阅读，不是为了计算的。但他还是继续做了。也就是说，他把我论文中的eval编译成[IBM] 704机器码，修复了一些错误，然后将其宣传为Lisp解释器，它确实是。在那时，Lisp基本上就有了今天的形式。&lt;/p&gt;&#xA;&lt;p&gt;所以，我想在几周内，McCarthy发现他的理论练习转变为实际的编程语言——而且是一种比他预期更强大的语言。&lt;/p&gt;&#xA;&lt;p&gt;所以，这个1950年代的语言没有过时的简短解释是它不是技术而是数学，而数学不会过时。将Lisp比较的正确对象不是1950年代的硬件，而是，比如说，快速排序算法，它发现于1960年，至今仍然是最快的通用排序算法。&lt;/p&gt;&#xA;&lt;p&gt;1950年代还有另一种语言幸存下来，Fortran，它代表了语言设计的相反方法。Lisp是一段意想不到地转变为编程语言的理论。Fortran是故意被开发为一种编程语言的，但我们现在认为是一种非常低级的语言。&lt;/p&gt;&#xA;&lt;p&gt;1956年开发的Fortran I语言与现在的Fortran是完全不同的动物。Fortran I基本上是带有数学的汇编语言。在某些方面它比最近的汇编语言功能更弱；例如，没有子程序，只有分支。现在的Fortran可以说更接近Lisp而不是Fortran I。&lt;/p&gt;&#xA;&lt;p&gt;Lisp和Fortran是两个独立进化树的树干，一个根植于数学，一个根植于机器架构。这两棵树从那时起一直在收敛。Lisp开始时很强大，在接下来的二十年里变得快速。所谓的主流语言开始时很快，在接下来的四十年里逐渐变得更强大，直到现在它们中最先进的相当接近Lisp。接近，但仍然缺少一些东西。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使lisp不同的东西&#34;&gt;使Lisp不同的东西&lt;/h2&gt;&#xA;&lt;p&gt;当Lisp首次被开发时，它体现了九个新想法。其中一些我们现在认为是理所当然的，其他只在更先进的语言中看到，有两个仍然是Lisp独有的。这九个想法按主流采用的顺序排列，&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件语句&lt;/strong&gt;。条件语句是if-then-else结构。我们现在认为这是理所当然的，但Fortran I没有它们。它只有基于底层机器指令的条件goto。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;函数类型&lt;/strong&gt;。在Lisp中，函数是一种像整数或字符串一样的数据类型。它们有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;。Lisp是第一种支持递归的编程语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;动态类型&lt;/strong&gt;。在Lisp中，所有变量实际上都是指针。值才有类型，变量没有，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;由表达式组成的程序&lt;/strong&gt;。Lisp程序是表达式的树，每个表达式都返回一个值。这与Fortran和大多数后续语言形成对比，它们区分表达式和语句。&lt;/p&gt;&#xA;&lt;p&gt;在Fortran I中很自然要有这种区别，因为你不能嵌套语句。所以虽然你需要表达式来进行数学运算，但没有必要让其他任何东西返回值，因为不可能有任何东西在等待它。&lt;/p&gt;&#xA;&lt;p&gt;随着块结构语言的出现，这种限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们两者的后代。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;符号类型&lt;/strong&gt;。符号实际上是指向存储在哈希表中的字符串的指针。所以你可以通过比较指针来测试相等性，而不是比较每个字符。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;使用符号和常量树的代码表示法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;整个语言一直存在&lt;/strong&gt;。读取时、编译时和运行时之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;&#xA;&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp在Emacs等程序中用作扩展语言的基础；在运行时读取使程序能够使用s表达式进行通信，这是一个最近重新发明的想法，称为XML。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当Lisp首次出现时，这些想法与普通的编程实践相距甚远，这在很大程度上是由1950年代后期可用的硬件决定的。随着时间的推移，默认语言，体现在一系列流行语言中，逐渐向Lisp发展。想法1-5现在已经广泛传播。数字6开始出现在主流中。Python有7的形式，尽管似乎没有任何语法。&lt;/p&gt;&#xA;&lt;p&gt;至于数字8，这可能是最有趣的。想法8和9只是偶然成为Lisp的一部分，因为Steve Russell实现了McCarthy从未打算实现的东西。然而，这些想法结果要对Lisp的奇怪外观和其最独特的特征负责。Lisp看起来奇怪不是因为它有奇怪的语法，而是因为它没有语法；你直接在解析树中表达程序，当其他语言被解析时，这些解析树是在幕后构建的，而这些树是由列表组成的，列表是Lisp数据结构。&lt;/p&gt;&#xA;&lt;p&gt;用其自身的数据结构表达语言结果证明是一个非常强大的特性。想法8和9一起意味着你可以编写编写程序的程序。这可能听起来像是一个奇怪的想法，但在Lisp中这是日常的事情。最常见的方法是使用叫做宏的东西。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;宏&amp;quot;这个术语在Lisp中的含义与其他语言中的含义不同。Lisp宏可以是从缩写到新语言编译器的任何东西。如果你想真正理解Lisp，或者只是扩展你的编程视野，我会学习更多关于宏的知识。&lt;/p&gt;&#xA;&lt;p&gt;据我所知，Lisp意义上的宏仍然是Lisp独有的。这部分是因为为了拥有宏，你可能必须使你的语言看起来像Lisp一样奇怪。也可能是因为如果你确实添加了这最后的力量增量，你不能再声称你发明了一种新语言，只是一种新的Lisp方言。&lt;/p&gt;&#xA;&lt;p&gt;我提到这主要是作为一个笑话，但这是相当真实的。如果你定义一种具有car、cdr、cons、quote、cond、atom、eq和函数列表表示法的语言，那么你可以从中构建出所有其余的Lisp。这实际上是Lisp的定义品质：McCarthy给予Lisp现在的形状就是为了使这一点成为可能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;语言重要的地方&#34;&gt;语言重要的地方&lt;/h2&gt;&#xA;&lt;p&gt;所以假设Lisp确实代表了主流语言渐近接近的一种极限——这是否意味着你实际上应该使用它来编写软件？使用不太强大的语言你会失去多少？有时候，不处于创新的最前沿不是更明智吗？受欢迎度在某种程度上不是其自身的证明吗？例如，尖头发的老板想要使用一种他可以轻松雇到程序员的语言，难道不对吗？&lt;/p&gt;&#xA;&lt;p&gt;当然，有些项目编程语言的选择并不重要。通常，应用程序要求越高，使用强大语言获得的优势就越大。但很多项目根本不要求高。大多数编程可能包括编写小的粘合程序，对于小的粘合程序，你可以使用任何你已经熟悉的语言，并且对于你需要做的事情有好的库。如果你只需要将数据从一个Windows应用程序馈送到另一个，当然，使用Visual Basic。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于语言设计的五个问题</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/langdes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/langdes/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/langdes/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;关于语言设计的五个问题&#34;&gt;关于语言设计的五个问题&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-编程语言是为人设计的&#34;&gt;1. 编程语言是为人设计的。&lt;/h2&gt;&#xA;&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;&#xA;&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;&#xA;&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;&#xA;&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;&#xA;&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-为自己和你的朋友设计&#34;&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;&#xA;&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;&#xA;&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;&#xA;&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;&#xA;&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;&#xA;&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-给程序员尽可能多的控制权&#34;&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;&#xA;&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;&#xA;&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-追求简洁&#34;&gt;4. 追求简洁。&lt;/h2&gt;&#xA;&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;&#xA;&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;&#xA;&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;5-承认黑客的本质&#34;&gt;5. 承认黑客的本质。&lt;/h2&gt;&#xA;&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开放性问题&#34;&gt;开放性问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-如何组织大型库&#34;&gt;1. 如何组织大型库？&lt;/h3&gt;&#xA;&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-人们真的害怕前缀语法吗&#34;&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;&#xA;&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-基于服务器的软件需要什么&#34;&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;&#xA;&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;&#xA;&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;&#xA;&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;&#xA;&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-还有什么新的抽象有待发现&#34;&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;&#xA;&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;&#xA;&lt;h2 id=&#34;预测&#34;&gt;预测&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-你可以使用任何你想要的语言&#34;&gt;1. 你可以使用任何你想要的语言。&lt;/h3&gt;&#xA;&lt;p&gt;编写应用程序过去意味着编写桌面软件。在桌面软件中，有很大的偏向于使用与操作系统相同的语言编写应用程序。所以十年前，编写软件几乎意味着用C编写软件。最终形成了一个传统：应用程序不能用不寻常的语言编写。而这个传统有很长时间发展，以至于像经理和风险投资家这样的非技术人员也学会了它。&lt;/p&gt;&#xA;&lt;p&gt;基于服务器的软件彻底打破了这一模式。使用基于服务器的软件，你可以使用任何你想要的语言。几乎没有人理解这一点（特别是经理和风险投资家）。一些黑客理解它，这就是为什么我们甚至听到像Perl和Python这样的新的独立语言。我们听到Perl和Python不是因为人们用它们编写Windows应用程序。&lt;/p&gt;&#xA;&lt;p&gt;作为对设计编程语言感兴趣的人，这对我们意味着我们的工作现在可能有真正的受众。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-速度来自分析器&#34;&gt;2. 速度来自分析器。&lt;/h3&gt;&#xA;&lt;p&gt;语言设计师，或者至少语言实现者，喜欢编写生成快速代码的编译器。但我不认为这是使语言对用户来说快速的原因。Knuth很久以前就指出，速度只在几个关键瓶颈中重要。任何尝试过的人都知道你无法猜测这些瓶颈在哪里。分析器是答案。&lt;/p&gt;&#xA;&lt;p&gt;语言设计师在解决错误的问题。用户不需要基准测试运行得快。他们需要的是一种能够显示他们自己程序的哪些部分需要重写的语言。这就是实践中速度的来源。所以也许如果语言实现者把他们本来会花在编译器优化上的一半时间用来编写一个好的分析器，这会是一个净收益。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-你需要一个应用程序来推动语言的设计&#34;&gt;3. 你需要一个应用程序来推动语言的设计。&lt;/h3&gt;&#xA;&lt;p&gt;这可能不是一个绝对的规则，但似乎最好的语言都是与它们被用来编写的某个应用程序一起演化的。C是由需要它进行系统编程的人编写的。Lisp的开发部分是为了进行符号微分，McCarthy如此急于开始，甚至在1960年第一篇关于Lisp的论文中就在编写微分程序。&lt;/p&gt;&#xA;&lt;p&gt;如果你的应用程序解决一些新问题，那就特别好。这将倾向于推动你的语言拥有程序员需要的新特性。我个人对编写一种适合编写基于服务器的应用程序的语言感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;[在小组讨论中，Guy Steele也提出了这一点，并补充建议应用程序不应该包括为你语言编写编译器，除非你的语言碰巧是用于编写编译器的。]&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-语言必须适合编写一次性程序&#34;&gt;4. 语言必须适合编写一次性程序。&lt;/h3&gt;&#xA;&lt;p&gt;你知道什么是一次性程序：你为某些有限任务快速编写的东西。我认为如果你环顾四周，你会发现很多大的、严肃的程序开始时是一次性程序。如果大多数程序开始时是一次性程序，我不会感到惊讶。所以如果你想制造一种适合一般软件编写的好语言，它必须适合编写一次性程序，因为这是大多数软件的幼虫阶段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-语法与语义相连&#34;&gt;5. 语法与语义相连。&lt;/h3&gt;&#xA;&lt;p&gt;传统上认为语法和语义是完全分开的。这听起来很震惊，但它们可能不是。我认为你语言中想要的东西可能与你如何表达它有关。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何变得流行</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/popular/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/popular/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/popular/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;如何变得流行&#34;&gt;如何变得流行&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（本文是作为一种新语言的商业计划书而写的。因此它缺少（因为想当然）一个好的编程语言最重要的特征：非常强大的抽象能力。）&lt;/p&gt;&#xA;&lt;p&gt;我有一个朋友曾经告诉一位著名的操作系统专家，他想设计一种真正好的编程语言。专家告诉他，这将是浪费时间，编程语言不会因为其优点而变得流行或不流行，所以无论他的语言有多好，都没人会使用。至少，这是他设计的语言所发生的情况。&lt;/p&gt;&#xA;&lt;p&gt;到底是什么让一种语言变得流行？流行的语言是否配得上它们的流行度？试图定义一个好的编程语言是否值得？你会怎么做？&lt;/p&gt;&#xA;&lt;p&gt;我认为这些问题的答案可以通过观察黑客并了解他们想要什么来找到。编程语言是为黑客而设计的，而编程语言作为编程语言（而不是，比如说，作为指称语义练习或编译器设计练习）是好的，当且仅当黑客喜欢它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-流行的机制&#34;&gt;1 流行的机制&lt;/h2&gt;&#xA;&lt;p&gt;当然，大多数人在选择编程语言时并不仅仅基于它们的优点。大多数程序员被告知要使用什么语言。然而我认为这些外部因素对编程语言流行度的影响并不像人们有时认为的那么大。我认为更大的问题是黑客对好的编程语言的想法与大多数语言设计者的想法不同。&lt;/p&gt;&#xA;&lt;p&gt;在这两者之间，黑客的意见才是重要的。编程语言不是定理。它们是工具，为人们设计的，必须像鞋子必须为人类的脚设计一样，适合人类的优点和缺点。如果鞋子穿上时夹脚，那它就是一双坏鞋，无论它作为雕塑品多么优雅。&lt;/p&gt;&#xA;&lt;p&gt;可能是大多数程序员无法区分好语言和坏语言。但这与其他工具没有什么不同。这并不意味着尝试设计好语言是浪费时间。专家黑客在看到好语言时能够识别出来，他们会使用它。诚然，专家黑客是极少数，但这个极少数群体编写了所有好的软件，他们的影响力使得其他程序员倾向于使用他们使用的任何语言。通常，这不仅仅是影响，而是命令：专家黑客通常就是那些作为老板或导师告诉其他程序员使用什么语言的人。&lt;/p&gt;&#xA;&lt;p&gt;专家黑客的意见并不是决定编程语言相对流行度的唯一力量——遗留软件（Cobol）和炒作（Ada、Java）也起作用——但我认为它是长期内最强大的力量。考虑到初始的关键质量和足够的时间，编程语言可能会变得与其应得的流行度相当。而流行度进一步将好语言与坏语言分开，因为来自真实用户的反馈总是导致改进。看看任何流行语言在其生命周期中发生了多大变化。Perl和Fortran是极端的例子，但即使是Lisp也发生了很大变化。例如，Lisp 1.5没有宏；这些是后来发展的，在麻省理工学院的黑客花了几年时间使用Lisp编写真实程序之后。[1]&lt;/p&gt;&#xA;&lt;p&gt;所以无论一种语言是否必须好才能流行，我认为一种语言必须流行才能好。它必须保持流行才能保持好。编程语言的工艺水平不会停滞不前。然而我们今天拥有的Lisp几乎与麻省理工学院在1980年代中期的Lisp相同，因为那是Lisp最后一次拥有足够大和要求高的用户群的时候。&lt;/p&gt;&#xA;&lt;p&gt;当然，黑客在使用语言之前必须了解它。他们如何听到？从其他黑客那里。但必须有一些初始的黑客群体使用该语言，其他人才能听到。我想知道这个群体必须多大；多少用户构成关键质量？我随口一说，二十个。如果一种语言有二十个独立的用户，意味着二十个用户自己决定使用它，我会认为它是真实的。&lt;/p&gt;&#xA;&lt;p&gt;达到那里并不容易。如果从零到二十比从二十到一千更难，我不会感到惊讶。获得那初始二十个用户的最好方法可能是使用特洛伊木马：给人们一个他们想要的应用程序，而这个应用程序恰好是用新语言编写的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-外部因素&#34;&gt;2 外部因素&lt;/h2&gt;&#xA;&lt;p&gt;让我们首先承认一个确实影响编程语言流行度的外部因素。要变得流行，编程语言必须是流行系统的脚本语言。Fortran和Cobol是早期IBM大型机的脚本语言。C是Unix的脚本语言，后来Perl也是。Tcl是Tk的脚本语言。Java和Javascript旨在成为Web浏览器的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;Lisp不是一个大规模流行的语言，因为它不是大规模流行系统的脚本语言。它保留的流行度可以追溯到1960年代和1970年代，当时它是麻省理工学院的脚本语言。当时的许多伟大程序员都在某个时期与麻省理工学院有关联。在1970年代初期，在C之前，麻省理工学院的Lisp方言MacLisp是严肃黑客想要使用的唯一编程语言之一。&lt;/p&gt;&#xA;&lt;p&gt;今天，Lisp是两个适度流行系统的脚本语言，Emacs和Autocad，因此我怀疑今天大部分Lisp编程都是在Emacs Lisp或AutoLisp中完成的。&lt;/p&gt;&#xA;&lt;p&gt;编程语言不是孤立存在的。Hack是一个及物动词——黑客通常在hack某物——在实践中，语言是相对于它们用来hack的任何东西来评判的。所以如果你想设计一种流行的语言，你要么必须提供比语言更多的东西，要么你必须设计你的语言来取代某个现有系统的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;Common Lisp不受欢迎的部分原因是因为它是一个孤儿。它确实伴随着一个要hack的系统：Lisp Machine。但Lisp Machines（以及并行计算机）在1980年代被通用处理器日益增长的力量压垮了。如果Common Lisp是Unix的好脚本语言，它可能会保持流行。唉，它是一个非常糟糕的脚本语言。&lt;/p&gt;&#xA;&lt;p&gt;描述这种情况的一种方法是说语言不是根据其自身的优点来评判的。另一种观点是，编程语言除非也是某物的脚本语言，否则就不是真正的编程语言。如果这让人感到意外，这似乎不公平。我认为这并不比期望编程语言有实现更不公平。这只是编程语言的一部分。&lt;/p&gt;&#xA;&lt;p&gt;当然，编程语言需要好的实现，而且这必须是免费的。公司会为软件付费，但个人黑客不会，而你需要吸引的是黑客。&lt;/p&gt;&#xA;&lt;p&gt;语言也需要有一本关于它的书。这本书应该是薄的、写得好的，充满了好的例子。K&amp;amp;R是这里的理想。目前我几乎会说一种语言必须有一本O&amp;rsquo;Reilly出版的书。这正成为对黑客重要性的测试。&lt;/p&gt;&#xA;&lt;p&gt;也应该有在线文档。事实上，书可以作为在线文档开始。但我不认为物理书已经过时了。它们的格式方便，出版商施加的事实审查是一种有用的、虽然不完美的过滤器。书店是学习新语言的最重要地方之一。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-简洁&#34;&gt;3 简洁&lt;/h2&gt;&#xA;&lt;p&gt;假设你能提供任何语言需要的三个东西——一个免费的实现、一本书、以及要hack的东西——你如何制造一种黑客会喜欢的语言？&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢的一件事是简洁。黑客是懒惰的，与数学家和现代主义建筑师是懒惰的方式相同：他们讨厌任何多余的东西。说一个即将编写程序的黑客基于他必须键入的字符总数来选择使用什么语言，至少是潜意识的，这离真相不远。如果这不是黑客思考的精确方式，语言设计者最好表现得好像是这样。&lt;/p&gt;&#xA;&lt;p&gt;试图用冗长的表达来宠用户，这些表达旨在类似英语，是错误的。Cobol因此缺陷而臭名昭著。黑客会认为被要求写&lt;/p&gt;&#xA;&lt;p&gt;add x to y giving z&lt;/p&gt;&#xA;&lt;p&gt;而不是&lt;/p&gt;&#xA;&lt;p&gt;z = x+y&lt;/p&gt;&#xA;&lt;p&gt;是介于对他智力的侮辱和对上帝的罪之间。&lt;/p&gt;&#xA;&lt;p&gt;有时有人说Lisp应该使用first和rest而不是car和cdr，因为这将使程序更容易阅读。可能是最初的几个小时。但黑客可以很快学会car意味着列表的第一个元素，cdr意味着其余的。使用first和rest意味着多50%的输入。而且它们的长度也不同，这意味着参数在调用时不会对齐，而car和cdr经常在连续行中这样使用。我发现代码在页面上的对齐方式非常重要。当Lisp代码以可变宽度字体设置时，我几乎无法阅读，朋友们说这对其他语言也是如此。&lt;/p&gt;&#xA;&lt;p&gt;简洁是强类型语言失败的一个地方。在所有其他条件相同的情况下，没有人想以一堆声明开始程序。任何可以隐含的东西，都应该是。&lt;/p&gt;&#xA;&lt;p&gt;单个标记也应该简短。Perl和Common Lisp在这个问题上占据相反的极端。Perl程序几乎可以神秘地密集，而内置Common Lisp操作符的名称则可笑地长。Common Lisp的设计者可能期望用户有文本编辑器为他们键入这些长名称。但长名称的成本不仅仅是键入它的成本。还有阅读它的成本，以及它在屏幕上占用空间的成本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-可hack性&#34;&gt;4 可Hack性&lt;/h2&gt;&#xA;&lt;p&gt;对黑客来说，有一件事比简洁更重要：能够做你想做的事。在编程语言的历史中，令人惊讶的是，大量的努力都用于防止程序员做被认为不合适的事情。这是一个危险傲慢的计划。语言设计师如何知道程序员将要需要做什么？我认为语言设计师最好将他们的目标用户视为天才，他们将需要做设计师从未预料到的事情，而不是需要保护自己免受自己的伤害的笨蛋。笨蛋无论如何都会伤到自己的脚。你可能阻止他引用另一个包中的变量，但你无法阻止他编写一个设计不良的程序来解决错误的问题，并且永远花时间做这件事。&lt;/p&gt;&#xA;&lt;p&gt;好的程序员经常想做危险和不雅的事情。我所说的不雅是指超越语言试图呈现的任何语义门面的东西：例如，获取某些高级抽象的内部表示。黑客喜欢hack，而hack意味着进入事物内部并重新猜测原始设计师。&lt;/p&gt;&#xA;&lt;p&gt;让自己被重新猜测。当你制造任何工具时，人们以你未曾打算的方式使用它，这对于高度复杂的工具如编程语言尤其如此。许多黑客想要以你从未想象过的方式调整你的语义模型。我说，让他们吧；在不危害运行时系统如垃圾收集器的情况下，给予程序员尽可能多的内部东西访问权限。&lt;/p&gt;&#xA;&lt;p&gt;在Common Lisp中，我经常想要迭代结构的字段——例如，梳理对已删除对象的引用，或找到未初始化的字段。我知道结构在底层只是向量。然而我无法编写一个可以在任何结构上调用的通用函数。我只能通过名称访问字段，因为这就是结构应该意味着的意思。&lt;/p&gt;&#xA;&lt;p&gt;黑客可能只想在一个大程序中一两次颠覆事物的预期模型。但能够这样做会产生多大的不同。这可能不仅仅是解决问题的问题。这里也有一种乐趣。黑客分享外科医生秘密的探索内脏的乐趣，青少年秘密的挤痘痘的乐趣。[2] 至少对于男孩来说，某些类型的恐怖是迷人的。Maxim杂志每年出版一卷照片，包含美女写真和可怕事故的混合。他们了解他们的观众。&lt;/p&gt;&#xA;&lt;p&gt;从历史上看，Lisp在让黑客为所欲为方面一直很好。Common Lisp的政治正确性是一种异常。早期的Lisp让你可以接触到一切。幸运的是，这种精神的大部分在宏中得以保留。能够对源代码进行任意转换，这是一件多么美妙的事情。&lt;/p&gt;&#xA;&lt;p&gt;经典的宏是真正的黑客工具——简单、强大和危险。理解它们的作用是如此简单：你调用一个函数在宏的参数上，无论它返回什么都被插入到宏调用的地方。卫生宏体现了相反的原则。它们试图保护你理解它们在做什么。我从未听过卫生宏用一句话解释过。它们是决定程序员被允许想要什么危险的经典例子。卫生宏旨在保护我免受变量捕获等问题的影响，但变量捕获正是在某些宏中我想要的东西。&lt;/p&gt;&#xA;&lt;p&gt;真正好的语言应该是既干净又肮脏的：干净地设计，具有少量良好理解和高度正交的操作符核心，但肮脏在它让黑客为所欲为的意义上。C就是这样。早期的Lisp也是。真正的黑客语言总是有一种稍微放荡不羁的特征。&lt;/p&gt;&#xA;&lt;p&gt;好的编程语言应该有让那些使用&amp;quot;软件工程&amp;quot;短语的人摇头不赞成的特征。在连续体的另一端是像Ada和Pascal这样的语言，它们是适合教学的礼仪模型，但不适合其他用途。&lt;/p&gt;&#xA;&lt;h2 id=&#34;5-一次性程序&#34;&gt;5 一次性程序&lt;/h2&gt;&#xA;&lt;p&gt;为了吸引黑客，语言必须擅长编写他们想要编写的程序类型。这意味着，也许令人惊讶的是，它必须擅长编写一次性程序。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如果Lisp这么好</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/iflisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/iflisp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/iflisp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;如果lisp这么好&#34;&gt;如果Lisp这么好&lt;/h1&gt;&#xA;&lt;p&gt;2003年5月&lt;/p&gt;&#xA;&lt;p&gt;如果Lisp这么好，为什么没有更多人使用它？我最近在一次演讲中被听众中的一个学生问到了这个问题。而且不是第一次了。&lt;/p&gt;&#xA;&lt;p&gt;在语言方面，就像在许多事情中一样，流行度和质量之间没有太大关联。为什么约翰·格里沙姆（《诉讼之王》销售排名第44）比简·奥斯汀（《傲慢与偏见》销售排名第6191）卖得更好？即使是格里沙姆会声称这是因为他是更好的作家吗？&lt;/p&gt;&#xA;&lt;p&gt;这是《傲慢与偏见》的第一句话：&amp;ldquo;凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;举世公认的真理？&amp;rdquo; 对于一个爱情故事的第一句话来说，这些词太长了。&lt;/p&gt;&#xA;&lt;p&gt;就像简·奥斯汀的作品一样，Lisp看起来很难。它的语法，或者说缺乏语法，使它看起来完全不同于大多数人习惯的语言。在学习Lisp之前，我也害怕它。我最近发现了一本1983年的笔记本，我在上面写道：&amp;ldquo;我想我应该学习Lisp，但它看起来太陌生了。&amp;ldquo;幸运的是，我当时19岁，对学习新东西没有太多抵触。我非常无知，学习几乎任何东西都意味着学习新事物。&lt;/p&gt;&#xA;&lt;p&gt;被Lisp吓到的人们编造了其他不使用它的理由。当C是默认语言时，标准的借口是Lisp太慢。现在Lisp方言是可用语言中较快的之一，这个借口已经消失了。现在的标准借口是公开循环的：其他语言更流行。&lt;/p&gt;&#xA;&lt;p&gt;（小心这种推理。它会让你得到Windows。）&lt;/p&gt;&#xA;&lt;p&gt;流行度总是自我延续的，但在编程语言中尤其如此。为流行语言编写的库更多，这使它们更流行。程序经常必须与现有程序一起工作，如果它们用相同的语言编写，这会更容易，所以语言像病毒一样从程序传播到程序。管理者更喜欢流行的语言，因为它们给他们更多对开发者的控制力，开发者可以更容易被替换。&lt;/p&gt;&#xA;&lt;p&gt;确实，如果编程语言都或多或少等价，那么使用除最流行语言之外的任何语言都没有什么理由。但它们并不都等价，差远了。这就是为什么不那么流行的语言，像简·奥斯汀的小说，继续存在的原因。当其他人在阅读最新的约翰·格里沙姆小说时，总会有一小部分人在阅读简·奥斯汀。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;日语翻译 | 罗马尼亚语翻译 | 西班牙语翻译&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>怪异语言</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/weird/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/weird/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/weird/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;怪异语言&#34;&gt;怪异语言&lt;/h1&gt;&#xA;&lt;p&gt;2021年8月&lt;/p&gt;&#xA;&lt;p&gt;当人们说根据他们的经验所有编程语言基本上等价时，他们做出的不是关于语言的陈述，而是关于他们做过的编程类型的陈述。&lt;/p&gt;&#xA;&lt;p&gt;99.5%的编程包括将库函数调用粘合在一起。所有流行的语言在这方面都同样好。所以一个人可以很容易地花费整个职业生涯在流行编程语言的交集中操作。&lt;/p&gt;&#xA;&lt;p&gt;但另外0.5%的编程不成比例地有趣。如果你想了解它由什么组成，怪异语言的怪异性是一个很好的线索。&lt;/p&gt;&#xA;&lt;p&gt;怪异语言不是偶然怪异的。至少好的不是。好的怪异语言的怪异性通常暗示着存在某种不仅仅是通常的库函数调用的粘合的编程形式。&lt;/p&gt;&#xA;&lt;p&gt;一个具体的例子：Lisp宏。Lisp宏即使对许多Lisp程序员来说也显得怪异。它们不仅不在流行语言的交集中，而且它们的性质使得在语言中正确实现它们而不将其变成Lisp的方言会很困难。宏绝对证明超越了粘合编程的技术。例如，通过首先为该类型的问题编写一种语言，然后在其中编写你的特定应用程序来解决问题。这不是你用宏能做的全部；它只是程序操作技术空间中的一个区域，即使现在还远未被完全探索。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你想扩展你对编程可能性的概念，一种方法是学习怪异语言。选择一种大多数程序员认为怪异但其中位数用户聪明的语言，然后专注于这种语言与流行语言交集之间的差异。你能用这种语言说什么，而在其他语言中说会极其不便？在学习如何说你以前不能说的话的过程中，你可能会学习如何想你以前不能想的事。&lt;/p&gt;&#xA;&lt;p&gt;感谢Trevor Blackwell、Patrick Collison、Daniel Gackle、Amjad Masad和Robert Morris阅读草稿。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://paulgraham.com/weird.ja.html&#34;&gt;日语翻译&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>百年编程语言</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/hundred/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/hundred/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/hundred/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;百年编程语言&#34;&gt;百年编程语言&lt;/h1&gt;&#xA;&lt;p&gt;2003年4月&lt;/p&gt;&#xA;&lt;p&gt;（本文源于在PyCon 2003的主题演讲。）&lt;/p&gt;&#xA;&lt;p&gt;很难预测一百年后的生活会是什么样子。我们只能确定几件事。我们知道每个人都会驾驶飞行汽车，区划法律将会放宽以允许建造数百层高的建筑，大部分时间都会是黑暗的，女性都会接受武术训练。在这里，我想聚焦于这个图景中的一个细节。他们会用什么样的编程语言来编写控制那些飞行汽车的软件？&lt;/p&gt;&#xA;&lt;p&gt;思考这个问题之所以有价值，并不是因为我们真的能用到这些语言，而是因为，如果我们幸运的话，我们会使用从现在到那个时间点的路径上的语言。&lt;/p&gt;&#xA;&lt;p&gt;我认为，像物种一样，语言会形成进化树，到处都有死胡同分支。我们已经看到这种情况正在发生。Cobol尽管曾经流行，但似乎没有任何知识后代。它是一个进化死胡同——尼安德特人式的语言。&lt;/p&gt;&#xA;&lt;p&gt;我预测Java也会有类似的命运。人们有时给我写信说，&amp;ldquo;你怎么能说Java不会成为一种成功的语言？它已经是成功的语言了。&amp;ldquo;我承认它是，如果你用关于它的书籍所占用的书架空间（特别是关于它的单本书籍），或者相信必须学习它才能找到工作的本科生数量来衡量成功的话。当我说Java不会成为成功的语言时，我的意思更具体：Java将是一个进化死胡同，就像Cobol一样。&lt;/p&gt;&#xA;&lt;p&gt;这只是一个猜测。我可能是错的。我在这里的重点不是批评Java，而是提出进化树的问题，让人们思考，语言X在树的哪个位置？问这个问题的原因不仅仅是为了让我们的鬼魂在一百年后说我告诉过你这样。这是因为靠近主要分支是寻找现在适合编程的语言的有用启发式方法。&lt;/p&gt;&#xA;&lt;p&gt;在任何给定的时间，你可能最幸福地处于进化树的主要分支上。即使仍然有很多尼安德特人，成为其中的一员也一定很糟糕。克罗马农人会不断过来殴打你并偷走你的食物。&lt;/p&gt;&#xA;&lt;p&gt;我想知道一百年后语言会是什么样子，这样我就知道现在应该赌树的哪个分支。&lt;/p&gt;&#xA;&lt;p&gt;语言的进化与物种的进化不同，因为分支可以融合。例如，Fortran分支似乎正在与Algol的后代融合。理论上这对物种也是可能的，但不太可能发生在比细胞更大的生物上。&lt;/p&gt;&#xA;&lt;p&gt;语言更有可能融合，部分是因为可能性空间较小，部分是因为突变不是随机的。语言设计师有意地融合其他语言的思想。&lt;/p&gt;&#xA;&lt;p&gt;对于语言设计师来说，思考编程语言的进化可能导致的方向特别有用，因为他们可以相应地引导。在这种情况下，&amp;ldquo;停留在主分支上&amp;quot;不仅仅是选择好语言的方法。它成为做出正确语言设计决策的启发式方法。&lt;/p&gt;&#xA;&lt;p&gt;任何编程语言都可以分为两部分：一组扮演公理角色的基本运算符，以及语言的其余部分，原则上可以用这些基本运算符来编写。&lt;/p&gt;&#xA;&lt;p&gt;我认为基本运算符是语言长期生存的最重要因素。其余的你可以改变。这就像买房子的规则，你首先应该考虑位置。其他的一切你都可以稍后修复，但你不能修复位置。&lt;/p&gt;&#xA;&lt;p&gt;我认为不仅公理要选择得好，而且数量要少。数学家一直对公理有这样的感觉——越少越好——我认为他们抓住了要点。&lt;/p&gt;&#xA;&lt;p&gt;至少，仔细审视语言的核心，看看是否有任何可以剔除的公理，这必须是一个有用的练习。我在我作为一个邋遢人的漫长职业生涯中发现，冗余会产生冗余，我看到这种情况不仅发生在软件中，也发生在床下和房间角落。&lt;/p&gt;&#xA;&lt;p&gt;我有一种预感，进化树的主要分支通过那些具有最小、最干净核心的语言。你能在语言本身中编写的语言部分越多越好。&lt;/p&gt;&#xA;&lt;p&gt;当然，即使问一百年后编程语言会是什么样子，我也做出了一个很大的假设。一百年后我们还会编写程序吗？我们不会只是告诉计算机我们想要它们做什么吗？&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，那个部门没有太多进展。我猜测一百年后人们仍会使用我们能识别的程序来告诉计算机做什么。可能有些我们现在通过编写程序来解决的问题，一百年后你不必编写程序来解决，但我认为仍会有大量我们今天所做的那种编程。&lt;/p&gt;&#xA;&lt;p&gt;认为任何人都能预测任何技术在一百年后会是什么样子可能显得 presumptuous。但请记住，我们背后已经有将近五十年的历史。当我们考虑到语言在过去五十年中进化得多么缓慢时，展望一百年是一个可以把握的想法。&lt;/p&gt;&#xA;&lt;p&gt;语言进化缓慢是因为它们并不是真正的技术。语言是符号。程序是你希望计算机为你解决问题的形式化描述。所以编程语言的进化速度更像数学符号的进化速度，而不是交通或通信的进化速度。数学符号确实在进化，但没有你在技术中看到的巨大飞跃。&lt;/p&gt;&#xA;&lt;p&gt;无论一百年后计算机由什么制成，似乎可以安全地预测它们会比现在快得多。如果摩尔定律继续发挥作用，它们将快74 quintillion（73,786,976,294,838,206,464）倍。这很难想象。事实上，速度部门最可能的预测可能是摩尔定律将停止工作。任何应该每十八个月翻一番的东西似乎最终都会遇到某种基本限制。但我毫不怀疑计算机会快得多。即使它们最终只快一百倍，这也应该大大改变编程语言的基本规则。除此之外，还会有更多空间给现在被认为是慢的语言，即那些不能产生非常高效代码的语言。&lt;/p&gt;&#xA;&lt;p&gt;然而，有些应用仍然需要速度。我们想用计算机解决的有些问题是计算机创造的；例如，你必须处理视频图像的速度取决于另一台计算机生成它们的速度。还有另一类问题本身就具有无限吸收计算周期的能力：图像渲染、密码学、模拟。&lt;/p&gt;&#xA;&lt;p&gt;如果一些应用可以变得越来越低效，而其他应用继续要求硬件能够提供的所有速度，更快的计算机将意味着语言必须覆盖更广泛的效率范围。我们已经看到这种情况正在发生。按照过去几十年的标准，一些流行新语言的当前实现惊人地浪费。&lt;/p&gt;&#xA;&lt;p&gt;这不仅仅是编程语言发生的事情。这是一个普遍的历史趋势。随着技术的改进，每一代人都能做前一代人认为是浪费的事情。三十年前的人会对我们如此随意地打长途电话感到惊讶。一百年前的人会更惊讶有一天一个包裹会通过孟菲斯从波士顿旅行到纽约。&lt;/p&gt;&#xA;&lt;p&gt;我已经可以告诉你未来一百年更快的硬件将给我们的所有额外周期会发生什么。它们几乎都会被浪费掉。&lt;/p&gt;&#xA;&lt;p&gt;我学习编程时计算机能力很稀缺。我记得取出我Basic程序中的所有空格，使它们能适合4K TRS-80的内存。想到所有这些惊人低效的软件一遍又一遍地烧掉周期做同样的事情，我觉得有点恶心。但我认为我的直觉在这里是错的。我就像一个长大的穷人，即使是为了重要的事情也不能忍受花钱，比如去看医生。&lt;/p&gt;&#xA;&lt;p&gt;有些浪费确实是令人厌恶的。例如，SUVs即使运行在永远不会耗尽且不产生污染的燃料上，也可能是令人厌恶的。SUVs之所以令人厌恶，是因为它们是一个令人厌恶的问题的解决方案。（如何使小型货车看起来更阳刚。）但并非所有浪费都是坏的。现在我们有了支持它的基础设施，计算你的长途通话分钟数开始显得吝啬。如果你有资源，更优雅的思考方式是把所有电话通话视为一类事情，无论对方在哪里。&lt;/p&gt;&#xA;&lt;p&gt;有好浪费，也有坏浪费。我对好浪费感兴趣——那种通过花费更多，我们可以获得更简单设计的浪费。我们将如何利用新、更快的硬件给我们带来的浪费周期的机会？&lt;/p&gt;&#xA;&lt;p&gt;对速度的渴望在我们这些拥有可怜计算机的人心中根深蒂固，以至于需要 conscious 努力来克服它。在语言设计中，我们应该有意识地寻找可以用效率换取哪怕是最小的便利增加的情况。&lt;/p&gt;&#xA;&lt;p&gt;大多数数据结构的存在是因为速度。例如，今天的许多语言既有字符串也有列表。在语义上，字符串或多或少是列表的一个子集，其中元素是字符。那么为什么你需要单独的数据类型呢？你真的不需要。字符串的存在仅仅是为了效率。但是用使程序运行得更快的hack来使语言的语义变得混乱是很蹩脚的。在语言中拥有字符串似乎是一个过早优化的例子。&lt;/p&gt;&#xA;&lt;p&gt;如果我们将语言的核心视为一组公理，那么仅仅为了效率而增加不增加表达能力的额外公理肯定是令人厌恶的。效率很重要，但我认为这不是获得它的正确方法。&lt;/p&gt;&#xA;&lt;p&gt;我认为解决这个问题的正确方法是将程序的含义与实现细节分开。不要同时拥有列表和字符串，只拥有列表，同时有某种方式给编译器优化建议，使其能够在必要时将字符串布置为连续的字节。&lt;/p&gt;&#xA;&lt;p&gt;由于速度在程序的大部分中都不重要，你通常不需要费心处理这种微观管理。随着计算机变得越来越快，这一点会越来越真实。&lt;/p&gt;&#xA;&lt;p&gt;少说实现细节也应该使程序更灵活。规范在程序编写过程中会改变，这不仅是不可避免的，而且是可取的。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;essay&amp;quot;这个词来自法语动词&amp;quot;essayer&amp;rdquo;，意思是&amp;quot;尝试&amp;rdquo;。essay在原始意义上是你写来试图弄清楚某些东西的东西。这在软件中也会发生。我认为一些最好的程序是essay，从这个意义上说，作者们在开始时并不知道他们确切地想要写什么。&lt;/p&gt;&#xA;&lt;p&gt;Lisp黑客们已经知道灵活使用数据结构的价值。我们倾向于编写程序的第一版本，使其用列表做所有事情。这些初始版本可能如此惊人地低效，以至于需要conscious努力不去思考它们在做什么，就像，至少对我而言，吃牛排需要conscious努力不去思考它来自哪里。&lt;/p&gt;&#xA;&lt;p&gt;一百年后的程序员最寻找的，最重要的是一种语言，你可以用最少的努力组合成一个令人难以置信的低效版本1程序。至少，这是我们现在会描述的方式。他们会说他们想要一种易于编程的语言。&lt;/p&gt;&#xA;&lt;p&gt;低效的软件并不令人厌恶。令人厌恶的是让程序员做不必要工作的语言。浪费程序员时间是真正的低效，而不是浪费机器时间。随着计算机变得越来越快，这一点会变得越来越清晰。&lt;/p&gt;&#xA;&lt;p&gt;我认为摆脱字符串已经是我们可以忍受思考的事情了。我们在Arc中这样做了，这似乎是一个胜利；一些用正则表达式描述会很尴尬的操作可以很容易地描述为递归函数。&lt;/p&gt;&#xA;&lt;p&gt;这种数据结构扁平化会走多远？我能想到甚至让我这个思想开明的人感到震惊的可能性。例如，我们会摆脱数组吗？毕竟，它们只是哈希表的一个子集，其中键是整数向量。我们会用列表替换哈希表本身吗？&lt;/p&gt;&#xA;&lt;p&gt;还有比这更令人震惊的前景。例如，McCarthy在1960年描述的Lisp没有数字。从逻辑上讲，你不需要有一个单独的数字概念，因为你可以用列表来表示它们：整数n可以表示为n个元素的列表。你可以用这种方式做数学。这只是令人难以忍受的低效。&lt;/p&gt;&#xA;&lt;p&gt;实际上没有人提议在实践中用列表实现数字。事实上，McCarthy的1960年论文在当时根本不打算实现。这是一个理论练习，试图创建一个更优雅的图灵机替代方案。当有人意外地拿走这篇论文并将其翻译成工作的Lisp解释器时，数字肯定不是用列表表示的；它们像所有其他语言一样用二进制表示。&lt;/p&gt;&#xA;&lt;p&gt;编程语言能否走得那么远，以至于摆脱数字作为基本数据类型？我问这个与其说是作为一个严肃的问题，不如说是作为一种与未来玩胆小鬼游戏的方式。这就像不可抗拒的力量遇到不可移动的物体的假设情况——这里，一个令人难以想象的低效实现遇到令人难以想象的巨大资源。我看不出为什么不。未来是相当长的。如果我们能做些什么来减少核心语言中公理的数量，那么随着t趋向无穷大，这似乎是值得押注的一方。如果这个想法在一百年后似乎仍然难以忍受，也许在一千年后不会。&lt;/p&gt;&#xA;&lt;p&gt;为了明确这一点，我并不是建议所有数值计算实际上都会使用列表进行。我建议核心语言，在关于实现的任何额外符号之前，应该这样定义。在实践中，任何想做任何数量数学的程序可能会用二进制表示数字，但这将是一种优化，而不是核心语言语义的一部分。&lt;/p&gt;&#xA;&lt;p&gt;燃烧周期的另一种方法是在应用程序和硬件之间拥有多层软件。这也是我们已经看到正在发生的趋势：许多最近的语言被编译成字节码。Bill Woods曾经告诉我，根据经验法则，每层解释成本在速度上要付出10倍的代价。这种额外的代价给你带来灵活性。&lt;/p&gt;&#xA;&lt;p&gt;Arc的第一个版本就是这种多层次缓慢的极端情况，相应的好处。它是一个经典的&amp;quot;元循环&amp;quot;解释器，在Common Lisp之上编写，与McCarthy原始Lisp论文中定义的eval函数有明显的家族相似性。整个事情只有几百行代码，所以非常容易理解和改变。我们使用的Common Lisp，CLisp，本身在字节码解释器之上运行。所以我们有两层解释，其中一层（顶层）惊人地低效，而语言是可用的。我承认勉强可用，但是可用的。&lt;/p&gt;&#xA;&lt;p&gt;即使在应用程序内部，将软件编写为多层也是一种强大的技术。自底向上编程意味着将程序编写为一系列层，每一层都作为其上一层的语言。这种方法往往产生更小、更灵活的程序。它也是通往圣杯可重用性的最佳途径。语言按定义是可重用的。你能将应用程序的更多部分推入用于编写这类应用程序的语言中，你的软件就会有更多部分是可重用的。&lt;/p&gt;&#xA;&lt;p&gt;不知何故，可重用性的想法在20世纪80年代与面向对象编程联系在一起，似乎没有任何相反的证据能够动摇它。但是虽然一些面向对象的软件是可重用的，使其可重用的是其自底向上性，而不是其面向对象性。考虑库：它们是可重用的因为它们是语言，无论它们是否以面向对象风格编写。&lt;/p&gt;&#xA;&lt;p&gt;顺便说一下，我不预测面向对象编程的消亡。虽然我认为它对好的程序员没有太多提供，除了在某些特定领域，它对大组织来说是不可抗拒的。面向对象编程提供了一种可持续的方式来编写意大利面条式代码。它让你能够将程序累积为一系列补丁。大组织总是倾向于以这种方式开发软件，我期望一百年后也会如此。既然我们在谈论未来，我们最好谈谈并行计算，因为这是这个想法似乎存在的地方。也就是说，无论你什么时候谈论，并行计算似乎都是未来要发生的事情。&lt;/p&gt;&#xA;&lt;p&gt;未来会赶上它吗？人们谈论并行计算作为即将发生的事情至少有20年了，到目前为止它还没有太多影响编程实践。或者说有吗？芯片设计师现在必须考虑它，试图在多cpu计算机上编写系统软件的人也必须考虑。&lt;/p&gt;&#xA;&lt;p&gt;真正的问题是，抽象的阶梯上并行会走多远？一百年后它甚至会影响应用程序员吗？或者它会是编译器作者思考的事情，但在应用程序源代码中通常是不可见的？&lt;/p&gt;&#xA;&lt;p&gt;似乎很可能的一件事是，大多数并行机会被浪费。这是我对我们得到的大部分额外计算机能力将被浪费的更一般预测的一个特例。我期望，就像底层硬件的惊人速度一样，并行将是如果你明确要求它就可以使用的东西，但通常不被使用。这意味着我们一百年后拥有的那种并行不会，除非在特殊应用中，是大规模并行。我期望对于普通程序员来说，它更像是能够分叉出最终并行运行的进程。&lt;/p&gt;&#xA;&lt;p&gt;这将像要求数据结构的特定实现一样，是你对程序进行优化时相当晚才做的事情。版本1通常会忽略从并行计算中获得的任何优势，就像它们会忽略从数据的特定表示中获得的任何优势一样。&lt;/p&gt;&#xA;&lt;p&gt;除了特殊类型的应用程序，并行不会渗透到一百年后编写的程序中。如果确实如此，那将是过早优化。&lt;/p&gt;&#xA;&lt;p&gt;一百年后会有多少种编程语言？最近似乎有大量的新编程语言。部分原因是更快的硬件使程序员能够在速度和便利性之间做出不同的权衡，取决于应用。如果这是一个真正的趋势，我们一百年后拥有的硬件只会增加它。&lt;/p&gt;&#xA;&lt;p&gt;然而一百年后可能只有几种广泛使用的语言。我说这个的部分原因是乐观：似乎，如果你做得很好，你可以制作一种理想的语言来编写慢速版本1，然而通过给编译器正确的优化建议，也能在必要时产生非常快的代码。所以，既然我乐观，我预测尽管它们在可接受和最大效率之间会有巨大差距，一百年后的程序员将拥有能够跨越大部分差距的语言。&lt;/p&gt;&#xA;&lt;p&gt;随着这个差距扩大，性能分析器将变得越来越重要。现在对性能分析的关注很少。许多人似乎仍然相信获得快速应用程序的方法是编写生成快速代码的编译器。随着可接受和最大性能之间的差距扩大，获得快速应用程序的方法是拥有一个从可接受到最大的良好指南，这一点将变得越来越清晰。&lt;/p&gt;</description>
    </item>
    <item>
      <title>设计与研究</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/desres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/desres/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/desres/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;设计与研究&#34;&gt;设计与研究&lt;/h1&gt;&#xA;&lt;p&gt;2003年1月&lt;/p&gt;&#xA;&lt;p&gt;（本文源自2002年秋季NEPLS会议的主题演讲。）&lt;/p&gt;&#xA;&lt;p&gt;访问这个国家的人常常惊讶地发现，美国人喜欢以询问&amp;quot;你是做什么的？&amp;ldquo;来开始对话。我从来不喜欢这个问题。我很少有一个简洁的答案。但我想我终于解决了这个问题。现在，当有人问我做什么时，我会直视他们的眼睛说&amp;quot;我正在设计一种新的Lisp方言。&amp;ldquo;我推荐这个答案给任何不喜欢被问及做什么的人。对话会立即转向其他话题。&lt;/p&gt;&#xA;&lt;p&gt;我不认为自己在研究编程语言。我只是在设计一种，就像有人可能设计一座建筑、一把椅子或一种新字体一样。我不是在试图发现什么新东西。我只是想创造一种编程起来很舒服的语言。在某些方面，这个假设让生活轻松很多。&lt;/p&gt;&#xA;&lt;p&gt;设计和研究之间的区别似乎是一个新与好的问题。设计不一定要新，但一定要好。研究不一定要好，但一定要新。我认为这两条路在顶端汇合：最好的设计通过使用新思想超越其前人，而最好的研究解决的不仅是新的问题，而且是真正值得解决的问题。所以最终我们的目标是相同的目的地，只是从不同的方向接近。&lt;/p&gt;&#xA;&lt;p&gt;今天我要谈论的是从背面看你的目标是什么样子的。当你把编程语言视为设计问题而非研究课题时，你会做什么不同的事情？&lt;/p&gt;&#xA;&lt;p&gt;最大的区别是你更关注用户。设计始于问，这是为谁而做的，他们从中需要什么？例如，一个好的建筑师不是先创建一个设计然后强加给用户，而是通过研究预期用户并找出他们需要什么来开始。&lt;/p&gt;&#xA;&lt;p&gt;注意我说的是&amp;quot;他们需要的&amp;rdquo;，而不是&amp;quot;他们想要的&amp;rdquo;。我并不是说作为一名设计师工作意味着像快餐厨师一样工作，做客户告诉你的任何事情。这在艺术领域的各个领域都有所不同，但我不认为有任何领域是由那些完全按照客户要求做事的人做出最好的作品的。&lt;/p&gt;&#xA;&lt;p&gt;在衡量好设计的标准是它对用户有多好用这一点上，顾客永远是对的。如果你写了一本让所有人都感到无聊的小说，或者一把坐着极不舒服的椅子，那么你的工作就很糟糕，就是这样。说小说或椅子是根据最先进的理论原理设计的，这并不是辩解。&lt;/p&gt;&#xA;&lt;p&gt;然而，做出对用户有用的东西并不意味着简单地做用户告诉你做的事情。用户不知道所有的选择是什么，而且常常对他们真正想要的东西感到困惑。&lt;/p&gt;&#xA;&lt;p&gt;这个悖论的答案，我认为是你必须为用户设计，但必须设计用户需要的东西，而不是仅仅设计他们说他们想要的东西。这很像做医生。你不能仅仅治疗病人的症状。当病人告诉你他们的症状时，你必须找出真正的问题所在，并治疗那个。&lt;/p&gt;&#xA;&lt;p&gt;这种对用户的关注是一种公理，大多数好的设计实践都可以从中推导出来，大多数设计问题都围绕着它。&lt;/p&gt;&#xA;&lt;p&gt;如果好的设计必须满足用户的需求，那么用户是谁？当我说设计必须为用户时，我并不是说好的设计旨在某种最低标准。你可以选择任何你想要的用户群体。例如，如果你在设计一个工具，你可以为从初学者到专家的任何人设计，而针对一个群体的好设计对另一个群体可能是坏的设计。关键是，你必须选择某个用户群体。我认为除非参考某个预期用户，否则你甚至无法谈论好或坏的设计。&lt;/p&gt;&#xA;&lt;p&gt;如果预期用户包括设计师自己，你最有可能获得好的设计。当你为不包括你自己的群体设计东西时，它往往是为那些你认为比你不够复杂的人设计的，而不是更复杂的。&lt;/p&gt;&#xA;&lt;p&gt;这是一个问题，因为无论多么仁慈，居高临下地看待用户似乎不可避免地会腐蚀设计师。我怀疑美国很少有住房项目是由期望住在那里的建筑师设计的。你可以在编程语言中看到同样的现象。C、Lisp和Smalltalk是为它们自己的设计师使用而创建的。Cobol、Ada和Java是为其他人使用而创建的。&lt;/p&gt;&#xA;&lt;p&gt;如果你认为你在为白痴设计东西，那么很可能你设计的东西不够好，即使是对白痴来说。即使你为最复杂的用户设计东西，你仍然在为人类设计。在研究方面情况不同。在数学中，你选择抽象不是因为它们容易理解，而是因为它们能让证明更短。我认为这对科学大体上也是如此。科学思想并不是为了符合人体工程学。&lt;/p&gt;&#xA;&lt;p&gt;在艺术领域，情况非常不同。设计完全是关于人的。人体是个奇怪的东西，但当你设计一把椅子时，那就是你设计的对象，没有办法回避。所有艺术都必须迎合人类的兴趣和局限性。例如，在绘画中，在其他条件相同的情况下，有人的画比没有人的画更有趣。文艺复兴时期的伟大画作都充满了人，这不仅仅是历史的偶然。如果不是这样，绘画作为媒介就不会拥有它所拥有的声望。&lt;/p&gt;&#xA;&lt;p&gt;不管喜欢与否，编程语言也是为人类服务的，我怀疑人脑就像人体一样凹凸不平且特异。有些思想人们很容易掌握，有些则不然。例如，我们处理细节的能力似乎非常有限。正是这个事实使得编程语言一开始就是个好主意；如果我们能处理细节，我们可以直接用机器语言编程。&lt;/p&gt;&#xA;&lt;p&gt;还要记住，语言主要不是完成程序的形式，而是程序必须在其中开发的东西。任何艺术领域的人都会告诉你，你可能需要不同的媒介来处理这两种情况。例如，大理石是完成思想的漂亮、耐用的媒介，但对于开发新思想来说，它却是一种无可救药的僵化媒介。&lt;/p&gt;&#xA;&lt;p&gt;程序就像证明一样，是一棵树的修剪版本，这棵树过去到处都有错误的分支。所以语言的测试不仅仅是完成的程序在它里面看起来有多干净，而是到达完成程序的路径有多干净。一个能给你优雅完成程序的设计选择可能不会给你一个优雅的设计过程。例如，我写过几个定义宏的宏，充满了嵌套的反引号，现在看起来像小宝石，但写它们花费了数小时最丑陋的试错，而且坦率地说，我仍然不完全确定它们是正确的。&lt;/p&gt;&#xA;&lt;p&gt;我们常常表现得好像语言的测试是完成的程序在它里面看起来有多好。当你看到同一个程序用两种语言编写，一个版本短得多时，这似乎很有说服力。当你从艺术的角度接近这个问题时，你不太可能依赖这种测试。你不想最终得到一个像大理石一样的编程语言。&lt;/p&gt;&#xA;&lt;p&gt;例如，在软件开发中拥有一个交互式顶层（在Lisp中称为读取-求值-打印循环）是一个巨大的胜利。当你有一个这样的东西时，它对语言的设计有实际影响。它对于一个必须在使用前声明变量的语言来说效果不佳，例如。当你只是在顶层输入表达式时，你希望能够将x设置为某个值，然后开始对x做事情。你不想必须先声明x的类型。你可以对任何一个前提提出异议，但如果一个语言必须有顶层才能方便，而强制类型声明与顶层不兼容，那么任何强制类型声明的语言都不可能方便编程。&lt;/p&gt;&#xA;&lt;p&gt;在实践中，要获得好的设计，你必须接近并保持接近你的用户。你必须不断在实际用户上校准你的想法，尤其是在开始时。简·奥斯汀的小说如此之好的原因之一是她把它们大声读给家人听。这就是为什么她从不沉溺于自我放纵的风景描述或矫饰的哲学思考。（哲学在那里，但它被编织进故事中，而不是像标签一样粘贴在上面。）如果你打开一本普通的&amp;quot;文学&amp;quot;小说，想象把它作为你写的东西大声读给朋友听，你会敏锐地感觉到那种东西对读者来说是多么令人难以忍受。&lt;/p&gt;&#xA;&lt;p&gt;在软件世界，这个想法被称为&amp;quot;较差就是更好&amp;quot;。实际上，&amp;ldquo;较差就是更好&amp;quot;的概念中混合了几个想法，这就是为什么人们仍在争论较差是否真的更好。但这个混合中的主要思想之一是，如果你在构建新东西，你应该尽快将原型放到用户面前。&lt;/p&gt;&#xA;&lt;p&gt;另一种方法可能叫做&amp;quot;万福玛丽亚策略&amp;rdquo;。你不是快速拿出原型并逐步改进它，而是试图在一次长传触地中创建完整、完成的产品。据我所知，这是灾难的根源。无数创业公司在互联网泡沫期间这样自我毁灭。我从未听说过有成功的案例。&lt;/p&gt;&#xA;&lt;p&gt;软件世界之外的人可能没有意识到的是，&amp;ldquo;较差就是更好&amp;quot;的思想在整个艺术领域都有体现。例如，在绘画中，这个思想在文艺复兴时期被发现。现在几乎每个绘画老师都会告诉你，获得准确绘画的正确方法不是慢慢地围绕物体的轮廓工作，因为错误会累积，最后你会发现线条不相遇。相反，你应该在大致正确的地方画几条快速的线，然后逐渐完善这个初始草图。&lt;/p&gt;&#xA;&lt;p&gt;在大多数领域，传统上原型是用不同材料制作的。要切割成金属的字体最初是用刷子在纸上设计的。要铸成青铜的雕像是用蜡建模的。要在挂毯上刺绣的图案是用墨水在纸上绘制的。要用石头建造的建筑是在较小规模的木材上测试的。&lt;/p&gt;&#xA;&lt;p&gt;当油画在十五世纪首次流行时令人兴奋的原因是，你实际上可以从原型制作完成的作品。如果你愿意，可以做一个初步的绘图，但你不必受它约束；你可以在完成绘画时解决所有细节，甚至做重大改变。&lt;/p&gt;&#xA;&lt;p&gt;在软件中你也可以这样做。原型不一定只是一个模型；你可以将其精制成成品。我认为你应该在可能的时候总是这样做。它能让你利用一路上获得的新见解。但也许更重要的是，它对士气有好处。&lt;/p&gt;&#xA;&lt;p&gt;士气在设计中至关重要。我很惊讶人们不多谈论它。我的第一个绘画老师告诉我：当你画某样东西感到无聊时，画出来的东西看起来会很无聊。例如，假设你必须画一栋建筑，你决定单独画每一块砖。如果你愿意，你可以这样做，但如果你中途感到无聊并开始机械地画砖而不是观察每一块，那么画出来的效果会比仅仅暗示砖块要差。&lt;/p&gt;&#xA;&lt;p&gt;通过逐步完善原型来建造东西对士气有好处，因为它能让你保持投入。在软件中，我的规则是：始终有可工作的代码。如果你正在写一小时内可以测试的东西，那么你有立即获得奖励的前景来激励你。在艺术领域也是如此，特别是在油画中。大多数画家从模糊的草图开始，然后逐步完善。如果你这样工作，那么原则上你永远不必在一天结束时留下看起来确实未完成的东西。确实，画家之间甚至有句谚语：&amp;ldquo;一幅画永远不会完成，你只是停止在上面工作。&amp;ldquo;这个想法对任何做过软件的人来说都很熟悉。&lt;/p&gt;&#xA;&lt;p&gt;士气是难以设计给不够复杂用户的另一个原因。很难对自己不喜欢的东西保持兴趣。要做出好东西，你必须想&amp;quot;哇，这真的很棒&amp;rdquo;，而不是&amp;quot;这是什么垃圾；那些傻瓜会喜欢它&amp;rdquo;。&lt;/p&gt;&#xA;&lt;p&gt;设计意味着为人类制造东西。但不仅仅是用户是人。设计师也是人。&lt;/p&gt;&#xA;&lt;p&gt;注意这段时间我一直在谈论&amp;quot;设计师&amp;rdquo;。设计通常必须由单个人控制才能做好。然而，似乎几个人可以合作进行一个研究项目。这在我看来是研究和设计之间最有趣的区别之一。&lt;/p&gt;&#xA;&lt;p&gt;艺术领域有著名合作的例子，但它们大多数似乎是分子结合而不是核融合的情况。在歌剧中，通常由一个人写剧本，另一个人写音乐。在文艺复兴时期，来自北欧的工匠经常被雇佣来做意大利绘画背景中的风景。但这些不是真正的合作。它们更像是罗伯特·弗罗斯特&amp;quot;好篱笆造就好邻居&amp;quot;的例子。你可以把好的设计实例粘在一起，但在每个单独的项目中，一个人必须处于控制地位。&lt;/p&gt;&#xA;&lt;p&gt;我不是说好的设计要求一个人思考所有事情。没有什么比一个你信任其判断的人的建议更有价值了。但谈话结束后，关于做什么的决定必须由一个人来做。&lt;/p&gt;&#xA;&lt;p&gt;为什么研究可以由合作者完成而设计不能？这是一个有趣的问题。我不知道答案。也许，如果设计和研究汇合，最好的研究也是好的设计，而且实际上不能由合作者完成。许多最著名的科学家似乎都是独自工作的。但我了解得不够多，无法说这里是否有模式。这可能仅仅是因为许多著名科学家工作时合作不那么普遍。&lt;/p&gt;&#xA;&lt;p&gt;无论科学领域的情况如何，真正的合作在艺术领域似乎极为罕见。委员会设计是坏设计的同义词。为什么会这样？有什么方法可以克服这个限制吗？&lt;/p&gt;&#xA;&lt;p&gt;我倾向于认为没有——好的设计需要一个独裁者。一个原因是好的设计必须是一体的。设计不仅是为人类，而是为单个的人。如果一个设计代表的思想适合一个人的头脑，那么这个思想也会适合用户的头脑。&lt;/p&gt;&#xA;&lt;p&gt;相关链接：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.aoky.net/articles/paul_graham/design_and_research_japanese.htm&#34;&gt;日语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://linguage.github.io/paul_graham/essays_zh/taste/&#34;&gt;制造者的品味&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.kent.ac.uk/people/staff/srk21/research/papers/graham/design_and_research_romanian.pdf&#34;&gt;罗马尼亚语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.barrahome.org/blog/articulos/diseno_e_investigacion&#34;&gt;西班牙语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
