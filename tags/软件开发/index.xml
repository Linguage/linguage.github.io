<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件开发 on Linguista</title>
    <link>https://linguage.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 软件开发 on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://linguage.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python悖论</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/pypar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/pypar/</guid>
      <description>&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/pypar.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/pypar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/pypar.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;python悖论&#34;&gt;Python悖论&lt;/h1&gt;&#xA;&lt;p&gt;2004年8月&lt;/p&gt;&#xA;&lt;p&gt;在最近的一次演讲中，我说了一些让很多人不高兴的话：你可以让更聪明的程序员在Python项目上工作，而不是在Java项目上工作。&lt;/p&gt;&#xA;&lt;p&gt;我这样说并不是指Java程序员很笨。我的意思是Python程序员很聪明。学习一门新的编程语言需要很多工作。人们学习Python并不是因为它能给他们带来工作；他们学习它是因为他们真正喜欢编程，并且对已经知道的语言不满意。&lt;/p&gt;&#xA;&lt;p&gt;这使他们成为公司应该想要雇佣的那种程序员。因此，由于缺乏更好的名称，我称之为Python悖论：如果一个公司选择用相对冷门的语言编写其软件，他们将能够雇佣到更好的程序员，因为他们只会吸引那些足够关心它而去学习它的人。而对于程序员来说，这个悖论更加明显：如果你想找到一份好工作，应该学习的语言是那些人们不仅仅是为了找工作而学习的语言。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，只有少数公司足够聪明地意识到了这一点。但这里也有一种选择在进行：它们正是程序员最想为之工作的公司。例如，Google。当他们发布Java编程工作时，他们也希望有Python经验。&lt;/p&gt;&#xA;&lt;p&gt;我的一位朋友几乎知道所有广泛使用的语言，他在大多数项目中都使用Python。他说主要的原因是他喜欢源代码的外观。这可能是选择一种语言而不是另一种语言的轻率理由。但并没有听起来那么轻率：当你编程时，你花在阅读代码上的时间比写代码的时间多。你推着源代码团，就像雕塑家推着粘土团一样。因此，一种让源代码看起来丑陋的语言对于要求精确的程序员来说是令人发疯的，就像充满疙瘩的粘土对于雕塑家一样。&lt;/p&gt;&#xA;&lt;p&gt;提到丑陋的源代码，人们当然会想到Perl。但Perl表面的丑陋并不是我指的那种。真正的丑陋不是看起来刺耳的语法，而是不得不用错误的概念来构建程序。Perl可能看起来像一个骂人的卡通人物，但在某些情况下，它在概念上超越了Python。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，无论如何。当然，这两种语言都是不断发展的目标。但它们与Ruby（以及Icon、Joy、J、Lisp和Smalltalk）共享一个事实：它们都是由真正关心编程的人创建和使用的。而那些往往是做得好的人。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;如果你喜欢这篇文章，你可能也会喜欢&lt;a href=&#34;https://linguage.github.io/paul_graham/essays_zh/hp/&#34;&gt;黑客与画家&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>书呆子的复仇</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/icad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/icad/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/icad/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/icad.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/icad.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/icad.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;书呆子的复仇&#34;&gt;书呆子的复仇&lt;/h1&gt;&#xA;&lt;p&gt;想要创业？获得Y Combinator的投资。&lt;/p&gt;&#xA;&lt;p&gt;2002年5月&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;我们当时在追逐C++程序员。我们成功地将他们中的许多人拖到了Lisp的路上。&amp;rdquo;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Guy Steele，Java规范合著者&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在软件行业中，一直存在着一场持续的斗争，一方是尖脑袋的学者，另一方是同样强大的力量——尖头发的老板。大家都知道尖头发的老板是谁，对吧？我认为技术界的大多数人不仅认识这个卡通人物，而且知道他们公司中这个人物的原型是谁。&lt;/p&gt;&#xA;&lt;p&gt;尖头发的老板奇迹般地结合了两个各自常见但很少同时出现的品质：(a)他对技术一无所知，(b)他对技术有非常强烈的看法。&lt;/p&gt;&#xA;&lt;p&gt;假设，例如，你需要编写一个软件。尖头发的老板对这个软件应该如何工作一无所知，也无法区分一种编程语言和另一种，但他知道你应该用什么语言来编写它。完全正确。他认为你应该用Java来编写。&lt;/p&gt;&#xA;&lt;p&gt;他为什么这么认为？让我们来看看尖头发的老板的大脑里面在想什么。他在想的大概是这样的。Java是一个标准。我知道它一定是标准，因为我总是在媒体上看到它。既然它是标准，我使用它就不会惹上麻烦。这也意味着总会有很多Java程序员，所以如果现在为我工作的程序员辞职了——为我工作的程序员总是神秘地辞职——我可以很容易地替换他们。&lt;/p&gt;&#xA;&lt;p&gt;嗯，这听起来并不那么不合理。但这一切都基于一个未言明的假设，而这个假设结果是错误的。尖头发的老板认为所有编程语言都差不多是等价的。如果这是真的，那他完全正确。如果所有语言都等价，当然，使用其他人都在使用的语言。&lt;/p&gt;&#xA;&lt;p&gt;但并非所有语言都是等价的，我想我甚至不需要深入它们之间的差异就能向你证明这一点。如果你在1992年问尖头发的老板软件应该用什么语言编写，他会像今天一样毫不犹豫地回答。软件应该用C++编写。但如果所有语言都等价，为什么尖头发的老板的意见会改变？事实上，Java的开发者为什么要费心创建一种新语言？&lt;/p&gt;&#xA;&lt;p&gt;据推测，如果你创建一种新语言，那是因为你认为它在某些方面比人们已有的语言更好。事实上，Gosling在第一份Java白皮书中明确表示，Java被设计用来解决C++的一些问题。所以事情就是这样：语言并不都是等价的。如果你顺着尖头发的老板的大脑思路追踪到Java，然后再回溯Java的历史到它的起源，你最终会得到一个与你开始时的假设相矛盾的想法。&lt;/p&gt;&#xA;&lt;p&gt;那么，谁是对的？James Gosling，还是尖头发的老板？毫不奇怪，Gosling是对的。某些语言对于某些问题来说比其他语言更好。你知道，这引发了一些有趣的问题。Java被设计为在特定问题上比C++更好。什么问题？什么时候Java更好，什么时候C++更好？是否存在某些情况下其他语言比两者都更好？&lt;/p&gt;&#xA;&lt;p&gt;一旦你开始考虑这个问题，你就打开了一个真正的潘多拉盒子。如果尖头发的老板不得不以全部复杂性来思考这个问题，他的大脑会爆炸。只要他认为所有语言都等价，他所要做的就是选择一个似乎最有势头的语言，既然这更多是时尚问题而不是技术问题，即使他也可能得到正确的答案。但如果语言各不相同，他突然必须同时解两个方程，试图在他一无所知的两件事之间找到最佳平衡：解决他需要解决的问题的二十种左右主要语言的相对适用性，以及为每种语言找到程序员、库等的可能性。如果门后是这样的东西，尖头发的老板不想打开它也就不足为奇了。&lt;/p&gt;&#xA;&lt;p&gt;认为所有编程语言都等价的缺点是这不是真的。但优点是它让你的生活简单得多。我认为这是这个想法如此广泛传播的主要原因。这是一个令人舒适的想法。&lt;/p&gt;&#xA;&lt;p&gt;我们知道Java一定相当不错，因为它是酷的、新的编程语言。或者真是如此吗？如果你从远处看编程语言的世界，看起来Java是最新的事物。（从足够远的地方看，你只能看到Sun支付的大型闪烁广告牌。）但如果你近距离观察这个世界，你会发现酷的程度是不同的。在黑客亚文化中，有一种叫做Perl的语言被认为比Java酷得多。例如，Slashdot就是用Perl生成的。我想你不会发现那些家伙使用Java Server Pages。但还有另一种更新的语言叫做Python，它的用户倾向于看不起Perl，还有更多的语言在等待。&lt;/p&gt;&#xA;&lt;p&gt;如果你按顺序看这些语言，Java、Perl、Python，你会注意到一个有趣的模式。至少，如果你是Lisp黑客，你会注意到这种模式。每一种都比前一种更像Lisp。Python甚至复制了许多Lisp黑客认为是错误的特性。你可以将简单的Lisp程序逐行翻译成Python。现在是2002年，编程语言几乎赶上了1958年。&lt;/p&gt;&#xA;&lt;h2 id=&#34;追上数学&#34;&gt;追上数学&lt;/h2&gt;&#xA;&lt;p&gt;我的意思是，Lisp是John McCarthy在1958年首次发现的，而流行的编程语言现在才赶上他当时发展的想法。&lt;/p&gt;&#xA;&lt;p&gt;现在，这怎么可能是真的？计算机技术不是变化很快的东西吗？我的意思是，在1958年，计算机是冰箱大小的庞然大物，处理能力相当于手表。怎么可能有那么古老的技术仍然相关，更不用说比最新的发展更优越？&lt;/p&gt;&#xA;&lt;p&gt;我来告诉你原因。这是因为Lisp并不是真正被设计为一种编程语言，至少不是我们今天意义上的编程语言。我们所说的编程语言是我们用来告诉计算机做什么的东西。McCarthy最终确实打算发展这种意义上的编程语言，但我们实际得到的Lisp是基于他作为理论练习所做的另一件事——努力定义一个比图灵机更方便的替代方案。正如McCarthy后来所说，&lt;/p&gt;&#xA;&lt;p&gt;展示Lisp比图灵机更整洁的另一种方法是编写一个通用的Lisp函数，并证明它比通用图灵机的描述更简洁、更易理解。这就是Lisp函数eval&amp;hellip;&amp;hellip;它计算Lisp表达式的值&amp;hellip;&amp;hellip;编写eval需要发明一种表示Lisp函数作为Lisp数据的符号，这种符号是为了论文的目的而设计的，并没有想到它会用来实际表达Lisp程序。&lt;/p&gt;&#xA;&lt;p&gt;接下来发生的事情是，在1958年末的某个时候，Steve Russell，McCarthy的一个研究生，看着这个eval的定义，意识到如果将它翻译成机器语言，结果将是一个Lisp解释器。&lt;/p&gt;&#xA;&lt;p&gt;这在当时是一个很大的惊喜。以下是McCarthy后来在采访中对此的评论：&lt;/p&gt;&#xA;&lt;p&gt;Steve Russell说，看，为什么我不来编程这个eval&amp;hellip;&amp;hellip;，我对他说，呵，呵，你把理论和实践混淆了，这个eval是为了阅读，不是为了计算的。但他还是继续做了。也就是说，他把我论文中的eval编译成[IBM] 704机器码，修复了一些错误，然后将其宣传为Lisp解释器，它确实是。在那时，Lisp基本上就有了今天的形式。&lt;/p&gt;&#xA;&lt;p&gt;所以，我想在几周内，McCarthy发现他的理论练习转变为实际的编程语言——而且是一种比他预期更强大的语言。&lt;/p&gt;&#xA;&lt;p&gt;所以，这个1950年代的语言没有过时的简短解释是它不是技术而是数学，而数学不会过时。将Lisp比较的正确对象不是1950年代的硬件，而是，比如说，快速排序算法，它发现于1960年，至今仍然是最快的通用排序算法。&lt;/p&gt;&#xA;&lt;p&gt;1950年代还有另一种语言幸存下来，Fortran，它代表了语言设计的相反方法。Lisp是一段意想不到地转变为编程语言的理论。Fortran是故意被开发为一种编程语言的，但我们现在认为是一种非常低级的语言。&lt;/p&gt;&#xA;&lt;p&gt;1956年开发的Fortran I语言与现在的Fortran是完全不同的动物。Fortran I基本上是带有数学的汇编语言。在某些方面它比最近的汇编语言功能更弱；例如，没有子程序，只有分支。现在的Fortran可以说更接近Lisp而不是Fortran I。&lt;/p&gt;&#xA;&lt;p&gt;Lisp和Fortran是两个独立进化树的树干，一个根植于数学，一个根植于机器架构。这两棵树从那时起一直在收敛。Lisp开始时很强大，在接下来的二十年里变得快速。所谓的主流语言开始时很快，在接下来的四十年里逐渐变得更强大，直到现在它们中最先进的相当接近Lisp。接近，但仍然缺少一些东西。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使lisp不同的东西&#34;&gt;使Lisp不同的东西&lt;/h2&gt;&#xA;&lt;p&gt;当Lisp首次被开发时，它体现了九个新想法。其中一些我们现在认为是理所当然的，其他只在更先进的语言中看到，有两个仍然是Lisp独有的。这九个想法按主流采用的顺序排列，&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件语句&lt;/strong&gt;。条件语句是if-then-else结构。我们现在认为这是理所当然的，但Fortran I没有它们。它只有基于底层机器指令的条件goto。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;函数类型&lt;/strong&gt;。在Lisp中，函数是一种像整数或字符串一样的数据类型。它们有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt;。Lisp是第一种支持递归的编程语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;动态类型&lt;/strong&gt;。在Lisp中，所有变量实际上都是指针。值才有类型，变量没有，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;垃圾回收&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;由表达式组成的程序&lt;/strong&gt;。Lisp程序是表达式的树，每个表达式都返回一个值。这与Fortran和大多数后续语言形成对比，它们区分表达式和语句。&lt;/p&gt;&#xA;&lt;p&gt;在Fortran I中很自然要有这种区别，因为你不能嵌套语句。所以虽然你需要表达式来进行数学运算，但没有必要让其他任何东西返回值，因为不可能有任何东西在等待它。&lt;/p&gt;&#xA;&lt;p&gt;随着块结构语言的出现，这种限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们两者的后代。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;符号类型&lt;/strong&gt;。符号实际上是指向存储在哈希表中的字符串的指针。所以你可以通过比较指针来测试相等性，而不是比较每个字符。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;使用符号和常量树的代码表示法&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;整个语言一直存在&lt;/strong&gt;。读取时、编译时和运行时之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;&#xA;&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp在Emacs等程序中用作扩展语言的基础；在运行时读取使程序能够使用s表达式进行通信，这是一个最近重新发明的想法，称为XML。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当Lisp首次出现时，这些想法与普通的编程实践相距甚远，这在很大程度上是由1950年代后期可用的硬件决定的。随着时间的推移，默认语言，体现在一系列流行语言中，逐渐向Lisp发展。想法1-5现在已经广泛传播。数字6开始出现在主流中。Python有7的形式，尽管似乎没有任何语法。&lt;/p&gt;&#xA;&lt;p&gt;至于数字8，这可能是最有趣的。想法8和9只是偶然成为Lisp的一部分，因为Steve Russell实现了McCarthy从未打算实现的东西。然而，这些想法结果要对Lisp的奇怪外观和其最独特的特征负责。Lisp看起来奇怪不是因为它有奇怪的语法，而是因为它没有语法；你直接在解析树中表达程序，当其他语言被解析时，这些解析树是在幕后构建的，而这些树是由列表组成的，列表是Lisp数据结构。&lt;/p&gt;&#xA;&lt;p&gt;用其自身的数据结构表达语言结果证明是一个非常强大的特性。想法8和9一起意味着你可以编写编写程序的程序。这可能听起来像是一个奇怪的想法，但在Lisp中这是日常的事情。最常见的方法是使用叫做宏的东西。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;宏&amp;quot;这个术语在Lisp中的含义与其他语言中的含义不同。Lisp宏可以是从缩写到新语言编译器的任何东西。如果你想真正理解Lisp，或者只是扩展你的编程视野，我会学习更多关于宏的知识。&lt;/p&gt;&#xA;&lt;p&gt;据我所知，Lisp意义上的宏仍然是Lisp独有的。这部分是因为为了拥有宏，你可能必须使你的语言看起来像Lisp一样奇怪。也可能是因为如果你确实添加了这最后的力量增量，你不能再声称你发明了一种新语言，只是一种新的Lisp方言。&lt;/p&gt;&#xA;&lt;p&gt;我提到这主要是作为一个笑话，但这是相当真实的。如果你定义一种具有car、cdr、cons、quote、cond、atom、eq和函数列表表示法的语言，那么你可以从中构建出所有其余的Lisp。这实际上是Lisp的定义品质：McCarthy给予Lisp现在的形状就是为了使这一点成为可能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;语言重要的地方&#34;&gt;语言重要的地方&lt;/h2&gt;&#xA;&lt;p&gt;所以假设Lisp确实代表了主流语言渐近接近的一种极限——这是否意味着你实际上应该使用它来编写软件？使用不太强大的语言你会失去多少？有时候，不处于创新的最前沿不是更明智吗？受欢迎度在某种程度上不是其自身的证明吗？例如，尖头发的老板想要使用一种他可以轻松雇到程序员的语言，难道不对吗？&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于语言设计的五个问题</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/langdes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/langdes/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/langdes/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/langdes.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/langdes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/langdes.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;关于语言设计的五个问题&#34;&gt;关于语言设计的五个问题&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-编程语言是为人设计的&#34;&gt;1. 编程语言是为人设计的。&lt;/h2&gt;&#xA;&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;&#xA;&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;&#xA;&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;&#xA;&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;&#xA;&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-为自己和你的朋友设计&#34;&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;&#xA;&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;&#xA;&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;&#xA;&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;&#xA;&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;&#xA;&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-给程序员尽可能多的控制权&#34;&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;&#xA;&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;&#xA;&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-追求简洁&#34;&gt;4. 追求简洁。&lt;/h2&gt;&#xA;&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;&#xA;&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;&#xA;&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;5-承认黑客的本质&#34;&gt;5. 承认黑客的本质。&lt;/h2&gt;&#xA;&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开放性问题&#34;&gt;开放性问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-如何组织大型库&#34;&gt;1. 如何组织大型库？&lt;/h3&gt;&#xA;&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-人们真的害怕前缀语法吗&#34;&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;&#xA;&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-基于服务器的软件需要什么&#34;&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;&#xA;&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;&#xA;&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;&#xA;&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;&#xA;&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-还有什么新的抽象有待发现&#34;&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;&#xA;&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;&#xA;&lt;h2 id=&#34;预测&#34;&gt;预测&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-你可以使用任何你想要的语言&#34;&gt;1. 你可以使用任何你想要的语言。&lt;/h3&gt;&#xA;&lt;p&gt;编写应用程序过去意味着编写桌面软件。在桌面软件中，有很大的偏向于使用与操作系统相同的语言编写应用程序。所以十年前，编写软件几乎意味着用C编写软件。最终形成了一个传统：应用程序不能用不寻常的语言编写。而这个传统有很长时间发展，以至于像经理和风险投资家这样的非技术人员也学会了它。&lt;/p&gt;&#xA;&lt;p&gt;基于服务器的软件彻底打破了这一模式。使用基于服务器的软件，你可以使用任何你想要的语言。几乎没有人理解这一点（特别是经理和风险投资家）。一些黑客理解它，这就是为什么我们甚至听到像Perl和Python这样的新的独立语言。我们听到Perl和Python不是因为人们用它们编写Windows应用程序。&lt;/p&gt;&#xA;&lt;p&gt;作为对设计编程语言感兴趣的人，这对我们意味着我们的工作现在可能有真正的受众。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-速度来自分析器&#34;&gt;2. 速度来自分析器。&lt;/h3&gt;&#xA;&lt;p&gt;语言设计师，或者至少语言实现者，喜欢编写生成快速代码的编译器。但我不认为这是使语言对用户来说快速的原因。Knuth很久以前就指出，速度只在几个关键瓶颈中重要。任何尝试过的人都知道你无法猜测这些瓶颈在哪里。分析器是答案。&lt;/p&gt;&#xA;&lt;p&gt;语言设计师在解决错误的问题。用户不需要基准测试运行得快。他们需要的是一种能够显示他们自己程序的哪些部分需要重写的语言。这就是实践中速度的来源。所以也许如果语言实现者把他们本来会花在编译器优化上的一半时间用来编写一个好的分析器，这会是一个净收益。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-你需要一个应用程序来推动语言的设计&#34;&gt;3. 你需要一个应用程序来推动语言的设计。&lt;/h3&gt;&#xA;&lt;p&gt;这可能不是一个绝对的规则，但似乎最好的语言都是与它们被用来编写的某个应用程序一起演化的。C是由需要它进行系统编程的人编写的。Lisp的开发部分是为了进行符号微分，McCarthy如此急于开始，甚至在1960年第一篇关于Lisp的论文中就在编写微分程序。&lt;/p&gt;&#xA;&lt;p&gt;如果你的应用程序解决一些新问题，那就特别好。这将倾向于推动你的语言拥有程序员需要的新特性。我个人对编写一种适合编写基于服务器的应用程序的语言感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;[在小组讨论中，Guy Steele也提出了这一点，并补充建议应用程序不应该包括为你语言编写编译器，除非你的语言碰巧是用于编写编译器的。]&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-语言必须适合编写一次性程序&#34;&gt;4. 语言必须适合编写一次性程序。&lt;/h3&gt;&#xA;&lt;p&gt;你知道什么是一次性程序：你为某些有限任务快速编写的东西。我认为如果你环顾四周，你会发现很多大的、严肃的程序开始时是一次性程序。如果大多数程序开始时是一次性程序，我不会感到惊讶。所以如果你想制造一种适合一般软件编写的好语言，它必须适合编写一次性程序，因为这是大多数软件的幼虫阶段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>另一条道路</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/road/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/road/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/road/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/road.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/road.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/road.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;另一条道路&#34;&gt;另一条道路&lt;/h1&gt;&#xA;&lt;p&gt;2001年9月&lt;/p&gt;&#xA;&lt;p&gt;（本文解释了为什么下一代软件的大部分可能是基于服务器的，这对程序员意味着什么，以及这种新型软件为什么是创业公司的绝佳机会。本文源自在BBN实验室的一次演讲。）&lt;/p&gt;&#xA;&lt;p&gt;1995年夏天，我的朋友Robert Morris和我决定创办一家创业公司。当时，围绕Netscape IPO的公关活动正如火如荼地进行，媒体上有很多关于电子商务的讨论。那时网络上可能只有三十家实际的商店，都是手工制作的。如果将来会有很多在线商店，就需要制作它们的软件，所以我们决定写一些这样的软件。&lt;/p&gt;&#xA;&lt;p&gt;在最初的一周左右，我们打算将其制作成一个普通的桌面应用程序。然后有一天我们想到让软件在我们的Web服务器上运行，使用浏览器作为界面。我们尝试重写软件使其在Web上工作，很明显这是正确的方法。如果我们编写的软件在服务器上运行，对用户和我们自己都会容易得多。&lt;/p&gt;&#xA;&lt;p&gt;结果证明这是一个好计划。现在，作为Yahoo Store，这个软件是最受欢迎的在线商店构建器，拥有约14,000个用户。&lt;/p&gt;&#xA;&lt;p&gt;当我们开始Viaweb时，几乎没有人理解我们说软件在服务器上运行是什么意思。直到一年后Hotmail推出，人们才开始理解。现在每个人都知道这是一个有效的方法。我们现在所做的事情有了一个名字：应用服务提供商，或ASP。&lt;/p&gt;&#xA;&lt;p&gt;我认为下一代软件的大部分都将按照这个模型编写。即使是损失最大的微软，似乎也看到将一些东西移出桌面是不可避免的。如果软件从桌面移到服务器上，对开发者来说将意味着一个完全不同的世界。本文描述了我们作为这个新世界的首批访客所看到的令人惊讶的事情。就软件确实转移到服务器上的程度而言，我在这里描述的就是未来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;下一件大事&#34;&gt;下一件大事？&lt;/h2&gt;&#xA;&lt;p&gt;当我们回顾桌面软件时代时，我想我们会惊叹于人们忍受的不便，就像我们现在惊叹于早期车主忍受的不便一样。在最初的二三十年里，你必须是一个汽车专家才能拥有汽车。但汽车是一个如此巨大的进步，以至于很多不是汽车专家的人也想拥有它们。&lt;/p&gt;&#xA;&lt;p&gt;计算机现在正处于这个阶段。当你拥有桌面计算机时，你最终会学到比你想要知道的更多关于其内部情况的知识。但超过一半的美国家庭都拥有一台。我母亲有一台计算机，她用它来收发邮件和记账。大约一年前，她收到Apple的一封信，为她提供新操作系统的折扣，这让她感到担忧。当一个65岁的女性只想用计算机来收发邮件和记账时，却不得不考虑安装新的操作系统，这就有问题了。普通用户甚至不应该知道&amp;quot;操作系统&amp;quot;这个词，更不用说&amp;quot;设备驱动程序&amp;quot;或&amp;quot;补丁&amp;quot;了。&lt;/p&gt;&#xA;&lt;p&gt;现在有另一种交付软件的方式可以拯救用户免于成为系统管理员。基于Web的应用程序是在Web服务器上运行并使用Web页面作为用户界面的程序。对于普通用户来说，这种新型软件将比桌面软件更容易、更便宜、更便携、更可靠，而且通常更强大。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的软件，大多数用户除了他们使用的应用程序外，不必考虑任何其他事情。所有混乱、变化的东西都将位于某处的服务器上，由擅长这种事情的人维护。因此，你通常不需要特定的计算机来使用软件。你只需要一个带有键盘、屏幕和Web浏览器的东西。也许它会有无线互联网接入。也许它也会是你的手机。无论它是什么，都将是消费电子产品：价格约200美元，人们主要根据外观选择的东西。你将在互联网服务上花费比硬件更多的钱，就像你现在对电话所做的那样。[1]&lt;/p&gt;&#xA;&lt;p&gt;点击到达服务器并返回需要大约十分之一秒，所以重度交互软件的用户，如Photoshop，仍然希望计算在桌面上进行。但如果你看大多数人使用计算机做的那种事情，十分之一秒的延迟不会成为问题。我母亲真的不需要桌面计算机，有很多像她这样的人。&lt;/p&gt;&#xA;&lt;h2 id=&#34;用户的胜利&#34;&gt;用户的胜利&lt;/h2&gt;&#xA;&lt;p&gt;我家附近有一辆车，保险杠上贴着&amp;quot;死也不愿不便&amp;quot;。大多数人，在大多数时候，会选择需要最少工作的选择。如果基于Web的软件获胜，那将是因为它更方便。对于用户和开发者来说，它似乎都会更方便。&lt;/p&gt;&#xA;&lt;p&gt;使用纯基于Web的应用程序，你只需要一个连接到互联网的浏览器。所以你可以在任何地方使用基于Web的应用程序。当你在桌面计算机上安装软件时，你只能在该计算机上使用它。更糟糕的是，你的文件被困在那台计算机上。随着人们习惯网络，这种模式的不便越来越明显。&lt;/p&gt;&#xA;&lt;p&gt;这里的开端是基于Web的电子邮件。现在数百万人意识到，无论你在哪里，都应该能够访问电子邮件。如果你能看到你的邮件，为什么不能看到你的日历？如果你能和同事讨论文档，为什么不能编辑它？为什么你的任何数据都应该被困在某个远处桌子的计算机上？&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;你的计算机&amp;quot;的整个概念正在消失，被&amp;quot;你的数据&amp;quot;所取代。你应该能够从任何计算机访问你的数据。或者更确切地说，任何客户端，而客户端不一定是计算机。&lt;/p&gt;&#xA;&lt;p&gt;客户端不应该存储数据；它们应该像电话一样。事实上，它们可能会变成电话，或者反之亦然。随着客户端变小，你有另一个理由不在它们上保存数据：随身携带的东西可能会丢失或被盗。把PDA留在出租车里就像磁盘崩溃，只是你的数据交给了别人而不是被蒸发掉了。&lt;/p&gt;&#xA;&lt;p&gt;使用纯基于Web的软件，你的数据和应用程序都不会保存在客户端上。所以你不需要安装任何东西来使用它。当没有安装时，你不必担心安装出错。应用程序和你的操作系统之间不可能存在不兼容性，因为软件不在你的操作系统上运行。&lt;/p&gt;&#xA;&lt;p&gt;因为它不需要安装，所以在你&amp;quot;购买&amp;quot;之前尝试基于Web的软件将是容易且常见的。你应该期望能够免费试用任何基于Web的应用程序，只需访问提供它的网站即可。在Viaweb，我们的整个网站就像一个大箭头，指向用户试驾。&lt;/p&gt;&#xA;&lt;p&gt;试驾后，注册服务只需要填写一个简短的表格（越简短越好）。这应该是用户必须做的最后工作。有了基于Web的软件，你应该无需额外付费、做任何工作，甚至可能无需知道就能获得新版本。&lt;/p&gt;&#xA;&lt;p&gt;升级不会像现在那样令人震惊。随着时间的推移，应用程序将悄然变得更强大。这需要开发者付出一些努力。他们必须设计软件，使其能够在不使用户困惑的情况下更新。这是一个新问题，但有解决方法。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的应用程序，每个人都使用相同的版本，错误一旦发现就可以修复。所以基于Web的软件应该比桌面软件的错误少得多。在Viaweb，我怀疑我们任何时候有过十个已知的错误。这比桌面软件好几个数量级。&lt;/p&gt;&#xA;&lt;p&gt;基于Web的应用程序可以同时被多个人使用。这对于协作应用程序来说显然是一个优势，但我敢打赌，一旦用户意识到这是可能的，他们会开始在大多数应用程序中想要这个功能。例如，让两个人编辑同一个文档通常是有用的。Viaweb允许多个用户同时编辑一个站点，更多是因为这是编写软件的正确方式，而不是因为我们期望用户想要这样做，但结果证明很多人确实这样做了。&lt;/p&gt;&#xA;&lt;p&gt;当你使用基于Web的应用程序时，你的数据会更安全。磁盘崩溃不会成为过去的事情，但用户不会再听到它们。它们将发生在服务器集群中。提供基于Web应用程序的公司实际上会进行备份——不仅因为他们会有真正的系统管理员担心这些事情，而且因为丢失用户数据的ASP将陷入巨大的麻烦。当人们在自己的磁盘崩溃中丢失数据时，他们不会太生气，因为他们只能生自己的气。当公司为他们丢失数据时，他们会更生气。&lt;/p&gt;&#xA;&lt;p&gt;最后，基于Web的软件应该对病毒不那么脆弱。如果客户端除了浏览器外不运行任何东西，运行病毒的机会就更少，本地也没有数据可以损坏。攻击服务器本身的程序会发现它们防御得很好。[2]&lt;/p&gt;&#xA;&lt;p&gt;对于用户来说，基于Web的软件压力会更小。我认为如果你查看普通Windows用户的内心，你会发现对符合这种描述的软件有着巨大且基本未被利用的渴望。释放出来，它可能是一股强大的力量。&lt;/p&gt;&#xA;&lt;h2 id=&#34;代码之城&#34;&gt;代码之城&lt;/h2&gt;&#xA;&lt;p&gt;对于开发者来说，基于Web和桌面软件之间最显著的区别是，基于Web的应用程序不是单一的代码片段。它将是不同类型程序的集合，而不是单一的大二进制文件。因此设计基于Web的软件更像设计城市而不是建筑：除了建筑物，你还需要道路、路标、公用设施、警察和消防部门，以及增长和各种灾难的计划。&lt;/p&gt;&#xA;&lt;p&gt;在Viaweb，软件包括相当大的应用程序，用户直接与之对话；这些程序使用的程序；在后台持续运行寻找问题的程序；如果出现问题尝试重新启动事物的程序；偶尔运行以编译统计信息或构建搜索索引的程序；我们明确运行以垃圾收集资源或移动或恢复数据的程序；假装是用户的程序（以测量性能或暴露错误）；诊断网络问题的程序；进行备份的程序；外部服务的接口；驱动令人印象深刻的表盘集合显示实时服务器统计的软件（对访客来说很受欢迎，但对我们来说也是不可或缺的）；对开源软件的修改（包括错误修复）；以及大量的配置文件和设置。在我们被Yahoo收购后，Trevor Blackwell编写了一个精彩的程序，可以在不关闭商店的情况下将商店迁移到全国的新服务器。程序通过传呼机呼叫我们，向用户发送传真和电子邮件，与信用卡处理商进行交易，并通过套接字、管道、http请求、ssh、udp数据包、共享内存和文件相互交谈。Viaweb的一部分甚至由程序的缺失组成，因为Unix安全的关键之一是不运行人们可能用来闯入服务器的不必要实用程序。&lt;/p&gt;&#xA;&lt;p&gt;这并不以软件结束。我们花了很多时间思考服务器配置。我们自己从组件构建服务器——部分是为了省钱，部分是为了得到我们想要的东西。我们必须考虑我们的上游ISP是否与所有骨干网有足够快的连接。我们与RAID供应商连续约会。&lt;/p&gt;&#xA;&lt;p&gt;但硬件不仅仅是要担心的事情。当你控制它时，你可以为用户做更多。对于桌面应用程序，你可以指定某些最低硬件要求，但你不能添加更多。如果你管理服务器，你可以一步让所有用户能够传呼别人，或发送传真，或通过电话发送命令，或处理信用卡等，只需安装相关硬件即可。我们总是寻找用硬件添加功能的新方法，不仅因为它让用户高兴，而且作为将自己与竞争对手区分开来的方式——竞争对手要么因为他们销售桌面软件，要么通过ISP转售基于Web的应用程序，不能直接控制硬件。&lt;/p&gt;&#xA;&lt;p&gt;因为基于Web应用程序中的软件将是程序的集合而不是单一的二进制文件，它可以用多种不同的语言编写。当你编写桌面软件时，你实际上被迫用与底层操作系统相同的语言编写应用程序——即C和C++。因此，这些语言（尤其是在非技术人员如经理和风险投资家中）被认为是&amp;quot;严肃&amp;quot;软件开发的语言。但这只是桌面软件必须交付方式的人工产物。对于基于服务器的软件，你可以使用任何你想要的语言。[3] 今天，许多顶级黑客使用远离C和C++的语言：Perl、Python，甚至Lisp。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，没有人能告诉你使用什么语言，因为你控制整个系统，一直到硬件。不同的语言适合不同的任务。你可以为每个任务使用最适合的语言。当你有竞争对手时，&amp;ldquo;你可以&amp;quot;意味着&amp;quot;你必须&amp;rdquo;（我们稍后会回到这一点），因为如果你不利用这种可能性，你的竞争对手会。&lt;/p&gt;&#xA;&lt;p&gt;我们的大多数竞争对手使用C和C++，这使得他们的软件明显 inferior，因为（除其他外），他们无法解决CGI脚本的无状态性问题。如果你要改变什么，所有的改变都必须在一个页面上发生，底部有一个更新按钮。正如我在其他地方写过的，通过使用许多人仍然认为是研究语言的Lisp，我们能够让Viaweb编辑器的行为更像桌面软件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;发布&#34;&gt;发布&lt;/h2&gt;&#xA;&lt;p&gt;在这个新世界中最重要的变化之一是你进行发布的方式。在桌面软件业务中，进行发布是一个巨大的创伤，整个公司都在努力推出一个单一的、巨大的代码片段。明显的比较会让人联想到这个过程和最终产品。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，你可以像为自己编写的程序那样几乎实时地进行更改。你以一系列增量更改而不是偶尔的大爆炸形式发布软件。一个典型的桌面软件公司可能一年进行一两次发布。在Viaweb，我们通常一天进行三到五次发布。&lt;/p&gt;&#xA;&lt;p&gt;当你切换到这个新模式时，你会意识到软件开发受到发布方式的影响有多大。你在桌面软件业务中看到的一些最令人讨厌的问题是由于发布的灾难性性质造成的。&lt;/p&gt;&#xA;&lt;p&gt;当你每年只发布一个新版本时，你倾向于批量处理错误。在发布日期之前的某个时间，你组装一个新版本，其中一半的代码被撕掉并替换，引入了无数错误。然后一队QA人员介入并开始计算它们，程序员们处理这个列表，修复它们。他们通常不会到达列表的末尾，事实上，没有人确定末尾在哪里。这就像从池塘里捞碎石。你永远不知道软件内部发生了什么。充其量你最终得到一种统计上的正确性。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，大多数更改都是小而增量的。这本身就不太可能引入错误。这也意味着当你准备发布软件时，你知道最需要仔细测试什么：你最后改变的东西。你对代码的控制要牢固得多。作为一个一般规则，你确实知道它内部发生了什么。当然你没有记住源代码，但当你阅读源代码时，你这样做就像飞行员扫描仪表盘，而不是像侦探试图解开一些谜团。&lt;/p&gt;&#xA;&lt;p&gt;桌面软件培养了对错误的某种宿命论。你知道你正在发布充满错误的东西，你甚至建立了补偿机制（例如补丁发布）。那么为什么还要担心几个更多的错误呢？很快你就会发布你知道有问题的整个功能。苹果今年早些时候就这样做了。他们感到压力要发布他们的新操作系统，其发布日期已经四次推迟，但一些软件（对CD和DVD的支持）还没有准备好。解决方案？他们在没有完成部分的情况下发布了操作系统，用户将不得不稍后安装它们。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的软件，你永远不必在软件能够工作之前发布它，你可以一旦它能够工作就发布它。&lt;/p&gt;&#xA;&lt;p&gt;行业资深人士可能会想，说你在软件能够工作之前永远不必发布软件听起来是个好主意，但当你承诺在某个日期之前交付软件的新版本时会发生什么？有了基于Web的软件，你不会做出这样的承诺，因为没有版本。你的软件逐渐而持续地变化。一些变化可能比其他变化更大，但版本的概念自然不适合基于Web的软件。&lt;/p&gt;&#xA;&lt;p&gt;如果有人记得Viaweb，这可能听起来很奇怪，因为我们总是在宣布新版本。这完全是为了公关目的。我们了解到，行业媒体是以版本号思考的。他们会为主要版本提供主要报道，意思是版本号的新第一位数字，而对于点版本，通常最多只有一个段落，意思是小数点后的新数字。&lt;/p&gt;&#xA;&lt;p&gt;我们的一些竞争对手提供桌面软件，实际上有版本号。对于这些发布，仅仅这个事实在我们看来就是他们落后的证据，他们会获得各种宣传。我们不想错过，所以我们也开始给我们的软件版本号。当我们想要一些宣传时，我们会列出自上次&amp;quot;发布&amp;quot;以来我们添加的所有功能，在软件上贴上一个新版本号，并发布新闻稿说新版本立即可用。令人惊讶的是，从来没有人指责我们这样做。&lt;/p&gt;&#xA;&lt;p&gt;到我们被收购时，我们已经这样做了三次，所以我们处于版本4。如果我没记错的话，是版本4.1。在Viaweb成为Yahoo Store后，不再如此迫切需要宣传，所以尽管软件继续发展，版本号的整个概念被悄然放弃了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;错误&#34;&gt;错误&lt;/h2&gt;&#xA;&lt;p&gt;基于Web软件的另一个主要技术优势是你可以重现大多数错误。用户的数据就在你的磁盘上。如果有人破坏了你的软件，你不必像桌面软件那样猜测发生了什么：你应该能够在他们在电话上与你交谈时重现错误。如果你在应用程序中内置了注意错误的代码，你甚至可能已经知道它。&lt;/p&gt;&#xA;&lt;p&gt;基于Web的软件全天候使用，所以你所做的一切都会立即受到考验。错误很快就会出现。&lt;/p&gt;&#xA;&lt;p&gt;软件公司有时被指控让用户调试他们的软件。而这正是我所倡导的。对于基于Web的软件，这实际上是一个好计划，因为错误更少且短暂。当你逐渐发布软件时，一开始你得到的错误会少得多。当你能够重现错误并立即发布更改时，你可以在大多数错误出现时找到并修复它们。我们任何时候都没有足够的错误需要正式的错误跟踪系统。&lt;/p&gt;&#xA;&lt;p&gt;当然，你应该在发布之前测试更改，所以不应该发布主要错误。那些不可避免地漏掉的少数错误将涉及边界情况，并且只会在有人打电话抱怨之前影响少数遇到它们的用户。只要你立即修复错误，对于普通用户来说，净效果是错误少得多。我怀疑普通Viaweb用户曾经看到过错误。&lt;/p&gt;&#xA;&lt;p&gt;修复新错误比修复旧错误更容易。在你刚刚编写的代码中找到错误通常相当快。当它出现时，你往往在查看源代码之前就知道哪里错了，因为你已经在潜意识中担心它了。修复六个月前编写的代码中的错误（如果你一年发布一次，这是平均情况）要多花很多工作。而且由于你对代码的理解不够，你更有可能以丑陋的方式修复它，甚至引入更多错误。[4]&lt;/p&gt;&#xA;&lt;p&gt;当你及早发现错误时，你也会得到更少的复合错误。复合错误是两个相互作用的独立错误：你下楼时绊倒，当你伸手抓住栏杆时，它从你手中脱落。在软件中，这种错误是最难发现的，而且往往具有最严重的后果。[5] 传统的&amp;quot;打破一切然后过滤错误&amp;quot;方法本质上会产生很多复合错误。而以一系列小更改发布的软件本质上不会这样。地板不断被清扫干净，任何可能后来卡在什么东西里的松散物体。&lt;/p&gt;&#xA;&lt;p&gt;如果你使用一种称为函数式编程的技术，这会有所帮助。函数式编程意味着避免副作用。你更可能在研究论文中看到它，而不是商业软件，但对于基于Web的应用程序，它结果非常有用。将整个程序写成纯函数式代码很难，但你可以用这种方式编写实质性的部分。它使你软件的这些部分更容易测试，因为它们没有状态，在你不断制作和测试小修改的情况下，这非常方便。我用这种风格编写了Viaweb编辑器的大部分，我们使我们的脚本语言RTML成为一种纯函数式语言。&lt;/p&gt;&#xA;&lt;p&gt;来自桌面软件业务的人会发现这难以置信，但在Viaweb，错误几乎成了一种游戏。由于大多数发布的错误都涉及边界情况，遇到它们的用户可能是高级用户，他们在测试极限。高级用户对错误更宽容，特别是因为你可能是在添加他们要求的功能时引入了它们的。事实上，因为错误很少，你必须做复杂的事情才能看到它们，高级用户常常为抓住一个而感到自豪。他们会怀着更多是胜利而不是愤怒的精神致电支持，好像他们从我们这里得分了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如果Lisp这么好</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/iflisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/iflisp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/iflisp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/iflisp.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/iflisp.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/iflisp.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;如果lisp这么好&#34;&gt;如果Lisp这么好&lt;/h1&gt;&#xA;&lt;p&gt;2003年5月&lt;/p&gt;&#xA;&lt;p&gt;如果Lisp这么好，为什么没有更多人使用它？我最近在一次演讲中被听众中的一个学生问到了这个问题。而且不是第一次了。&lt;/p&gt;&#xA;&lt;p&gt;在语言方面，就像在许多事情中一样，流行度和质量之间没有太大关联。为什么约翰·格里沙姆（《诉讼之王》销售排名第44）比简·奥斯汀（《傲慢与偏见》销售排名第6191）卖得更好？即使是格里沙姆会声称这是因为他是更好的作家吗？&lt;/p&gt;&#xA;&lt;p&gt;这是《傲慢与偏见》的第一句话：&amp;ldquo;凡是有钱的单身汉，总想娶位太太，这已经成了一条举世公认的真理。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;举世公认的真理？&amp;rdquo; 对于一个爱情故事的第一句话来说，这些词太长了。&lt;/p&gt;&#xA;&lt;p&gt;就像简·奥斯汀的作品一样，Lisp看起来很难。它的语法，或者说缺乏语法，使它看起来完全不同于大多数人习惯的语言。在学习Lisp之前，我也害怕它。我最近发现了一本1983年的笔记本，我在上面写道：&amp;ldquo;我想我应该学习Lisp，但它看起来太陌生了。&amp;ldquo;幸运的是，我当时19岁，对学习新东西没有太多抵触。我非常无知，学习几乎任何东西都意味着学习新事物。&lt;/p&gt;&#xA;&lt;p&gt;被Lisp吓到的人们编造了其他不使用它的理由。当C是默认语言时，标准的借口是Lisp太慢。现在Lisp方言是可用语言中较快的之一，这个借口已经消失了。现在的标准借口是公开循环的：其他语言更流行。&lt;/p&gt;&#xA;&lt;p&gt;（小心这种推理。它会让你得到Windows。）&lt;/p&gt;&#xA;&lt;p&gt;流行度总是自我延续的，但在编程语言中尤其如此。为流行语言编写的库更多，这使它们更流行。程序经常必须与现有程序一起工作，如果它们用相同的语言编写，这会更容易，所以语言像病毒一样从程序传播到程序。管理者更喜欢流行的语言，因为它们给他们更多对开发者的控制力，开发者可以更容易被替换。&lt;/p&gt;&#xA;&lt;p&gt;确实，如果编程语言都或多或少等价，那么使用除最流行语言之外的任何语言都没有什么理由。但它们并不都等价，差远了。这就是为什么不那么流行的语言，像简·奥斯汀的小说，继续存在的原因。当其他人在阅读最新的约翰·格里沙姆小说时，总会有一小部分人在阅读简·奥斯汀。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;日语翻译 | 罗马尼亚语翻译 | 西班牙语翻译&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>将程序装在脑中</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/head/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/head/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/head/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/head.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/head.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/head.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;将程序装在脑中&#34;&gt;将程序装在脑中&lt;/h1&gt;&#xA;&lt;p&gt;2007年8月&lt;/p&gt;&#xA;&lt;p&gt;一个优秀的程序员密集地工作在他自己的代码上时，可以像数学家把持一个他在解决的问题那样把持它。数学家不像学校教的那样在纸上工作来回答问题。他们在脑子里做得更多：他们试图充分理解问题空间，能够像漫步在你成长房屋的记忆中那样漫步其中。在最佳状态下，编程也是如此。你把整个程序装在脑中，你可以随意操纵它。&lt;/p&gt;&#xA;&lt;p&gt;这在项目开始时特别有价值，因为最初最重要的是能够改变你正在做的事情。不仅仅是以不同的方式解决问题，而是改变你正在解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;你的代码是你对你正在探索的问题的理解。所以只有当你把代码装在脑中时，你才真正理解这个问题。&lt;/p&gt;&#xA;&lt;p&gt;把程序装进脑中并不容易。如果你离开一个项目几个月，当你回到它时，可能需要几天才能真正再次理解它。即使你在积极地处理一个程序，每天开始工作时也需要半小时才能把它装进脑中。这是最好的情况。在典型办公条件下工作的普通程序员永远不会进入这种模式。或者更戏剧性地说，在典型办公条件下工作的普通程序员永远不会真正理解他们正在解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;即使是最优秀的程序员并不总是把他们正在处理的整个程序都装在脑中。但你可以做一些事情来帮助：&lt;/p&gt;&#xA;&lt;h2 id=&#34;避免干扰&#34;&gt;避免干扰。&lt;/h2&gt;&#xA;&lt;p&gt;干扰对许多类型的工作都是有害的，但对编程尤其有害，因为程序员倾向于在他们能处理的细节极限上运作。&lt;/p&gt;&#xA;&lt;p&gt;干扰的危险不在于它持续多久，而在于它使你的大脑混乱的程度。程序员可以离开办公室去吃个三明治而不会失去脑中的代码。但错误的干扰可以在30秒内抹去你的大脑。&lt;/p&gt;&#xA;&lt;p&gt;奇怪的是，有计划的干扰可能比没有计划的干扰更糟。如果你知道一小时后有个会议，你甚至不会开始处理困难的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;长时间工作&#34;&gt;长时间工作。&lt;/h2&gt;&#xA;&lt;p&gt;因为每次开始处理一个程序都有固定成本，所以在几个长时段中工作比在许多短时段中工作更有效率。当然，总会有一个点，因为你累了而变得愚蠢。这因人而异。我听说过人们连续36小时编程，但我能管理的最多只有18小时左右，而且我在不超过12小时的块中工作效果最好。&lt;/p&gt;&#xA;&lt;p&gt;最佳状态不是你身体能忍受的极限。分解项目既有优势也有成本。有时当你在休息后回到问题时，你会发现你的潜意识留下了答案等着你。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用简洁的语言&#34;&gt;使用简洁的语言。&lt;/h2&gt;&#xA;&lt;p&gt;更强大的编程语言使程序更短。程序员似乎至少部分地用他们用来编写程序的语言来思考程序。语言越简洁，程序越短，就越容易装进脑中并保持在那里。&lt;/p&gt;&#xA;&lt;p&gt;你可以通过使用一种称为自底向上编程的风格来增强强大语言的效果，在这种风格中，你编写多层程序，较低的层作为其上层的编程语言。如果你正确地这样做，你只需要把最顶层装在脑中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;不断重写你的程序&#34;&gt;不断重写你的程序。&lt;/h2&gt;&#xA;&lt;p&gt;重写程序通常会得到更清晰的设计。但即使不会，它也有优势：你必须完全理解一个程序才能重写它，所以没有更好的方法把它装进脑中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;写可重读的代码&#34;&gt;写可重读的代码。&lt;/h2&gt;&#xA;&lt;p&gt;所有程序员都知道写可读代码是好的。但你自己是最重要的读者。特别是在开始时；原型是与自己的对话。当为自己写作时，你有不同的优先事项。如果为别人写作，你可能不想让代码太密集。程序的某些部分可能最容易读，如果你把东西摊开，像一本入门教科书。而如果你写代码是为了让它容易重新装进脑中，最好追求简洁。&lt;/p&gt;&#xA;&lt;h2 id=&#34;小组工作&#34;&gt;小组工作。&lt;/h2&gt;&#xA;&lt;p&gt;当你在脑中操纵一个程序时，你的视野倾向于停在你拥有的代码边缘。其他部分你理解得不够好，更重要的是，不能随意处理。所以程序员数量越少，项目就能越完全地变异。如果只有一个程序员，通常开始时是这样，你可以做全面重新设计。&lt;/p&gt;&#xA;&lt;h2 id=&#34;不要让多个人编辑同一段代码&#34;&gt;不要让多个人编辑同一段代码。&lt;/h2&gt;&#xA;&lt;p&gt;你永远不会像理解自己的代码那样理解别人的代码。无论你多么彻底地读过它，你只是读了它，而不是写了它。所以如果一段代码由多个作者编写，他们中没有人像单个作者那样理解它。&lt;/p&gt;&#xA;&lt;p&gt;当然你不能安全地重新设计别人正在处理的东西。不仅仅是你必须请求许可。你甚至不让自己考虑这样的事情。重新设计有几个作者的代码就像改变法律；重新设计你独自控制的代码就像看到模糊图像的另一种解释。&lt;/p&gt;&#xA;&lt;p&gt;如果你想让几个人在一个项目上工作，把它分成组件，每个给一个人。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从小开始&#34;&gt;从小开始。&lt;/h2&gt;&#xA;&lt;p&gt;随着你对程序越来越熟悉，它变得更容易装在脑中。一旦你确信你已经完全探索了某些部分，你就可以开始把它们当作黑盒处理。但当你开始处理一个项目时，你被迫看到一切。如果你开始的问题太大，你可能永远无法完全把握它。所以如果你需要写一个大的、复杂的程序，开始的最佳方式可能不是为它写规范，而是写一个解决子集问题的原型。无论计划有什么优势，它们往往被能够把程序装在脑中的优势所抵消。&lt;/p&gt;&#xA;&lt;p&gt;程序员们经常偶然做到这八点，这很引人注目。有人有了一个新项目的想法，但因为不是正式批准的，他必须在下班时间做——结果证明更有生产力，因为没有干扰。受到他对新项目的热情驱使，他连续工作许多小时。因为它最初只是一个实验，他使用的是&amp;quot;脚本&amp;quot;语言而不是&amp;quot;生产&amp;quot;语言——实际上它强大得多。他完全重写程序几次；这对正式项目是不合理的，但这是爱的劳动，他想要它完美。而且因为除了他没有人会看到它，他省略了除笔记类型外的任何注释。他被迫在小团队中工作，因为他要么还没有告诉任何人这个想法，要么它看起来如此无望以至于不允许其他人在其上工作。即使有一个团队，他们也不能让多个人编辑同一段代码，因为它变化太快，那是不可能的。项目从小开始是因为想法一开始很小；他只是有一些很酷的黑客技巧想试试。&lt;/p&gt;&#xA;&lt;p&gt;更引人注目的是有多少正式批准的项目设法把这八件事都做错了。事实上，如果你看看大多数组织中软件编写的方式，几乎就像他们在故意做错事情。在某种意义上，他们确实如此。自从有组织以来，其定义性品质之一就是把个人当作可互换的部件。这对更可并行化的任务很有效，比如打仗。在历史上大部分时间里，一支训练有素的专业士兵军队可以指望打败一群个人战士，无论多么勇敢。但拥有想法不是很可并行化的。而程序就是：想法。&lt;/p&gt;&#xA;&lt;p&gt;组织不喜欢依赖个人天才的想法不仅仅是真的，它是同义反复。不这样做是组织定义的一部分。至少是我们当前组织概念的一部分。&lt;/p&gt;&#xA;&lt;p&gt;也许我们可以定义一种新型的组织，结合个人的努力而不要求他们可互换。可以说市场就是这种形式的组织，尽管把市场描述为退化情况可能更准确——当组织不可能时默认得到的情况。&lt;/p&gt;&#xA;&lt;p&gt;可能我们能做到的最好的是某种hack，比如让一个组织的编程部分以不同于其他部分的方式工作。也许最佳解决方案是大公司甚至不尝试内部开发想法，而只是购买它们。但无论解决方案是什么，第一步是意识到存在问题。&amp;ldquo;软件公司&amp;quot;这个短语本身就有矛盾。这两个词在相反的方向上拉扯。任何大型组织中的优秀程序员都会与之冲突，因为组织的设计是为了防止程序员追求的目标。&lt;/p&gt;&#xA;&lt;p&gt;优秀的程序员无论如何都能完成很多事情。但这往往需要对雇佣他们的组织进行实际上反抗的行为。如果更多的人理解程序员的行为方式是由他们工作的需求驱动的，这可能会有所帮助。他们长时间工作，期间推掉所有其他义务，直接投入编程而不是先写规范，重写已经工作的代码，这不是因为他们不负责任。他们更喜欢独自工作，或者对探头说你好的人咆哮，这不是因为他们不友好。这个表面上随机的令人讨厌习惯集合有一个单一的解释：将程序装在脑中的力量。&lt;/p&gt;&#xA;&lt;p&gt;无论理解这一点是否能帮助大型组织，它肯定能帮助他们的竞争对手。大公司的最弱点是他们不让个别程序员做出伟大的工作。所以如果你是一个小创业公司，这是攻击他们的地方。接手那些必须在一个大脑中解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;感谢Sam Altman、David Greenspan、Aaron Iba、Jessica Livingston、Robert Morris、Peter Norvig、Lisa Randall、Emmett Shear、Sergei Tsarev和Stephen Wolfram阅读本文的草稿。&lt;/p&gt;</description>
    </item>
    <item>
      <title>怪异语言</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/weird/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/weird/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/weird/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/weird.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/weird.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/weird.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;怪异语言&#34;&gt;怪异语言&lt;/h1&gt;&#xA;&lt;p&gt;2021年8月&lt;/p&gt;&#xA;&lt;p&gt;当人们说根据他们的经验所有编程语言基本上等价时，他们做出的不是关于语言的陈述，而是关于他们做过的编程类型的陈述。&lt;/p&gt;&#xA;&lt;p&gt;99.5%的编程包括将库函数调用粘合在一起。所有流行的语言在这方面都同样好。所以一个人可以很容易地花费整个职业生涯在流行编程语言的交集中操作。&lt;/p&gt;&#xA;&lt;p&gt;但另外0.5%的编程不成比例地有趣。如果你想了解它由什么组成，怪异语言的怪异性是一个很好的线索。&lt;/p&gt;&#xA;&lt;p&gt;怪异语言不是偶然怪异的。至少好的不是。好的怪异语言的怪异性通常暗示着存在某种不仅仅是通常的库函数调用的粘合的编程形式。&lt;/p&gt;&#xA;&lt;p&gt;一个具体的例子：Lisp宏。Lisp宏即使对许多Lisp程序员来说也显得怪异。它们不仅不在流行语言的交集中，而且它们的性质使得在语言中正确实现它们而不将其变成Lisp的方言会很困难。宏绝对证明超越了粘合编程的技术。例如，通过首先为该类型的问题编写一种语言，然后在其中编写你的特定应用程序来解决问题。这不是你用宏能做的全部；它只是程序操作技术空间中的一个区域，即使现在还远未被完全探索。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你想扩展你对编程可能性的概念，一种方法是学习怪异语言。选择一种大多数程序员认为怪异但其中位数用户聪明的语言，然后专注于这种语言与流行语言交集之间的差异。你能用这种语言说什么，而在其他语言中说会极其不便？在学习如何说你以前不能说的话的过程中，你可能会学习如何想你以前不能想的事。&lt;/p&gt;&#xA;&lt;p&gt;感谢Trevor Blackwell、Patrick Collison、Daniel Gackle、Amjad Masad和Robert Morris阅读草稿。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://paulgraham.com/weird.ja.html&#34;&gt;日语翻译&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>百年编程语言</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/hundred/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/hundred/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/hundred/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/hundred.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/hundred.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/hundred.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;百年编程语言&#34;&gt;百年编程语言&lt;/h1&gt;&#xA;&lt;p&gt;2003年4月&lt;/p&gt;&#xA;&lt;p&gt;（本文源于在PyCon 2003的主题演讲。）&lt;/p&gt;&#xA;&lt;p&gt;很难预测一百年后的生活会是什么样子。我们只能确定几件事。我们知道每个人都会驾驶飞行汽车，区划法律将会放宽以允许建造数百层高的建筑，大部分时间都会是黑暗的，女性都会接受武术训练。在这里，我想聚焦于这个图景中的一个细节。他们会用什么样的编程语言来编写控制那些飞行汽车的软件？&lt;/p&gt;&#xA;&lt;p&gt;思考这个问题之所以有价值，并不是因为我们真的能用到这些语言，而是因为，如果我们幸运的话，我们会使用从现在到那个时间点的路径上的语言。&lt;/p&gt;&#xA;&lt;p&gt;我认为，像物种一样，语言会形成进化树，到处都有死胡同分支。我们已经看到这种情况正在发生。Cobol尽管曾经流行，但似乎没有任何知识后代。它是一个进化死胡同——尼安德特人式的语言。&lt;/p&gt;&#xA;&lt;p&gt;我预测Java也会有类似的命运。人们有时给我写信说，&amp;ldquo;你怎么能说Java不会成为一种成功的语言？它已经是成功的语言了。&amp;ldquo;我承认它是，如果你用关于它的书籍所占用的书架空间（特别是关于它的单本书籍），或者相信必须学习它才能找到工作的本科生数量来衡量成功的话。当我说Java不会成为成功的语言时，我的意思更具体：Java将是一个进化死胡同，就像Cobol一样。&lt;/p&gt;&#xA;&lt;p&gt;这只是一个猜测。我可能是错的。我在这里的重点不是批评Java，而是提出进化树的问题，让人们思考，语言X在树的哪个位置？问这个问题的原因不仅仅是为了让我们的鬼魂在一百年后说我告诉过你这样。这是因为靠近主要分支是寻找现在适合编程的语言的有用启发式方法。&lt;/p&gt;&#xA;&lt;p&gt;在任何给定的时间，你可能最幸福地处于进化树的主要分支上。即使仍然有很多尼安德特人，成为其中的一员也一定很糟糕。克罗马农人会不断过来殴打你并偷走你的食物。&lt;/p&gt;&#xA;&lt;p&gt;我想知道一百年后语言会是什么样子，这样我就知道现在应该赌树的哪个分支。&lt;/p&gt;&#xA;&lt;p&gt;语言的进化与物种的进化不同，因为分支可以融合。例如，Fortran分支似乎正在与Algol的后代融合。理论上这对物种也是可能的，但不太可能发生在比细胞更大的生物上。&lt;/p&gt;&#xA;&lt;p&gt;语言更有可能融合，部分是因为可能性空间较小，部分是因为突变不是随机的。语言设计师有意地融合其他语言的思想。&lt;/p&gt;&#xA;&lt;p&gt;对于语言设计师来说，思考编程语言的进化可能导致的方向特别有用，因为他们可以相应地引导。在这种情况下，&amp;ldquo;停留在主分支上&amp;quot;不仅仅是选择好语言的方法。它成为做出正确语言设计决策的启发式方法。&lt;/p&gt;&#xA;&lt;p&gt;任何编程语言都可以分为两部分：一组扮演公理角色的基本运算符，以及语言的其余部分，原则上可以用这些基本运算符来编写。&lt;/p&gt;&#xA;&lt;p&gt;我认为基本运算符是语言长期生存的最重要因素。其余的你可以改变。这就像买房子的规则，你首先应该考虑位置。其他的一切你都可以稍后修复，但你不能修复位置。&lt;/p&gt;&#xA;&lt;p&gt;我认为不仅公理要选择得好，而且数量要少。数学家一直对公理有这样的感觉——越少越好——我认为他们抓住了要点。&lt;/p&gt;&#xA;&lt;p&gt;至少，仔细审视语言的核心，看看是否有任何可以剔除的公理，这必须是一个有用的练习。我在我作为一个邋遢人的漫长职业生涯中发现，冗余会产生冗余，我看到这种情况不仅发生在软件中，也发生在床下和房间角落。&lt;/p&gt;&#xA;&lt;p&gt;我有一种预感，进化树的主要分支通过那些具有最小、最干净核心的语言。你能在语言本身中编写的语言部分越多越好。&lt;/p&gt;&#xA;&lt;p&gt;当然，即使问一百年后编程语言会是什么样子，我也做出了一个很大的假设。一百年后我们还会编写程序吗？我们不会只是告诉计算机我们想要它们做什么吗？&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，那个部门没有太多进展。我猜测一百年后人们仍会使用我们能识别的程序来告诉计算机做什么。可能有些我们现在通过编写程序来解决的问题，一百年后你不必编写程序来解决，但我认为仍会有大量我们今天所做的那种编程。&lt;/p&gt;&#xA;&lt;p&gt;认为任何人都能预测任何技术在一百年后会是什么样子可能显得 presumptuous。但请记住，我们背后已经有将近五十年的历史。当我们考虑到语言在过去五十年中进化得多么缓慢时，展望一百年是一个可以把握的想法。&lt;/p&gt;&#xA;&lt;p&gt;语言进化缓慢是因为它们并不是真正的技术。语言是符号。程序是你希望计算机为你解决问题的形式化描述。所以编程语言的进化速度更像数学符号的进化速度，而不是交通或通信的进化速度。数学符号确实在进化，但没有你在技术中看到的巨大飞跃。&lt;/p&gt;&#xA;&lt;p&gt;无论一百年后计算机由什么制成，似乎可以安全地预测它们会比现在快得多。如果摩尔定律继续发挥作用，它们将快74 quintillion（73,786,976,294,838,206,464）倍。这很难想象。事实上，速度部门最可能的预测可能是摩尔定律将停止工作。任何应该每十八个月翻一番的东西似乎最终都会遇到某种基本限制。但我毫不怀疑计算机会快得多。即使它们最终只快一百倍，这也应该大大改变编程语言的基本规则。除此之外，还会有更多空间给现在被认为是慢的语言，即那些不能产生非常高效代码的语言。&lt;/p&gt;&#xA;&lt;p&gt;然而，有些应用仍然需要速度。我们想用计算机解决的有些问题是计算机创造的；例如，你必须处理视频图像的速度取决于另一台计算机生成它们的速度。还有另一类问题本身就具有无限吸收计算周期的能力：图像渲染、密码学、模拟。&lt;/p&gt;&#xA;&lt;p&gt;如果一些应用可以变得越来越低效，而其他应用继续要求硬件能够提供的所有速度，更快的计算机将意味着语言必须覆盖更广泛的效率范围。我们已经看到这种情况正在发生。按照过去几十年的标准，一些流行新语言的当前实现惊人地浪费。&lt;/p&gt;&#xA;&lt;p&gt;这不仅仅是编程语言发生的事情。这是一个普遍的历史趋势。随着技术的改进，每一代人都能做前一代人认为是浪费的事情。三十年前的人会对我们如此随意地打长途电话感到惊讶。一百年前的人会更惊讶有一天一个包裹会通过孟菲斯从波士顿旅行到纽约。&lt;/p&gt;&#xA;&lt;p&gt;我已经可以告诉你未来一百年更快的硬件将给我们的所有额外周期会发生什么。它们几乎都会被浪费掉。&lt;/p&gt;&#xA;&lt;p&gt;我学习编程时计算机能力很稀缺。我记得取出我Basic程序中的所有空格，使它们能适合4K TRS-80的内存。想到所有这些惊人低效的软件一遍又一遍地烧掉周期做同样的事情，我觉得有点恶心。但我认为我的直觉在这里是错的。我就像一个长大的穷人，即使是为了重要的事情也不能忍受花钱，比如去看医生。&lt;/p&gt;&#xA;&lt;p&gt;有些浪费确实是令人厌恶的。例如，SUVs即使运行在永远不会耗尽且不产生污染的燃料上，也可能是令人厌恶的。SUVs之所以令人厌恶，是因为它们是一个令人厌恶的问题的解决方案。（如何使小型货车看起来更阳刚。）但并非所有浪费都是坏的。现在我们有了支持它的基础设施，计算你的长途通话分钟数开始显得吝啬。如果你有资源，更优雅的思考方式是把所有电话通话视为一类事情，无论对方在哪里。&lt;/p&gt;&#xA;&lt;p&gt;有好浪费，也有坏浪费。我对好浪费感兴趣——那种通过花费更多，我们可以获得更简单设计的浪费。我们将如何利用新、更快的硬件给我们带来的浪费周期的机会？&lt;/p&gt;&#xA;&lt;p&gt;对速度的渴望在我们这些拥有可怜计算机的人心中根深蒂固，以至于需要 conscious 努力来克服它。在语言设计中，我们应该有意识地寻找可以用效率换取哪怕是最小的便利增加的情况。&lt;/p&gt;&#xA;&lt;p&gt;大多数数据结构的存在是因为速度。例如，今天的许多语言既有字符串也有列表。在语义上，字符串或多或少是列表的一个子集，其中元素是字符。那么为什么你需要单独的数据类型呢？你真的不需要。字符串的存在仅仅是为了效率。但是用使程序运行得更快的hack来使语言的语义变得混乱是很蹩脚的。在语言中拥有字符串似乎是一个过早优化的例子。&lt;/p&gt;&#xA;&lt;p&gt;如果我们将语言的核心视为一组公理，那么仅仅为了效率而增加不增加表达能力的额外公理肯定是令人厌恶的。效率很重要，但我认为这不是获得它的正确方法。&lt;/p&gt;&#xA;&lt;p&gt;我认为解决这个问题的正确方法是将程序的含义与实现细节分开。不要同时拥有列表和字符串，只拥有列表，同时有某种方式给编译器优化建议，使其能够在必要时将字符串布置为连续的字节。&lt;/p&gt;&#xA;&lt;p&gt;由于速度在程序的大部分中都不重要，你通常不需要费心处理这种微观管理。随着计算机变得越来越快，这一点会越来越真实。&lt;/p&gt;&#xA;&lt;p&gt;少说实现细节也应该使程序更灵活。规范在程序编写过程中会改变，这不仅是不可避免的，而且是可取的。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;essay&amp;quot;这个词来自法语动词&amp;quot;essayer&amp;rdquo;，意思是&amp;quot;尝试&amp;rdquo;。essay在原始意义上是你写来试图弄清楚某些东西的东西。这在软件中也会发生。我认为一些最好的程序是essay，从这个意义上说，作者们在开始时并不知道他们确切地想要写什么。&lt;/p&gt;&#xA;&lt;p&gt;Lisp黑客们已经知道灵活使用数据结构的价值。我们倾向于编写程序的第一版本，使其用列表做所有事情。这些初始版本可能如此惊人地低效，以至于需要conscious努力不去思考它们在做什么，就像，至少对我而言，吃牛排需要conscious努力不去思考它来自哪里。&lt;/p&gt;&#xA;&lt;p&gt;一百年后的程序员最寻找的，最重要的是一种语言，你可以用最少的努力组合成一个令人难以置信的低效版本1程序。至少，这是我们现在会描述的方式。他们会说他们想要一种易于编程的语言。&lt;/p&gt;&#xA;&lt;p&gt;低效的软件并不令人厌恶。令人厌恶的是让程序员做不必要工作的语言。浪费程序员时间是真正的低效，而不是浪费机器时间。随着计算机变得越来越快，这一点会变得越来越清晰。&lt;/p&gt;&#xA;&lt;p&gt;我认为摆脱字符串已经是我们可以忍受思考的事情了。我们在Arc中这样做了，这似乎是一个胜利；一些用正则表达式描述会很尴尬的操作可以很容易地描述为递归函数。&lt;/p&gt;&#xA;&lt;p&gt;这种数据结构扁平化会走多远？我能想到甚至让我这个思想开明的人感到震惊的可能性。例如，我们会摆脱数组吗？毕竟，它们只是哈希表的一个子集，其中键是整数向量。我们会用列表替换哈希表本身吗？&lt;/p&gt;&#xA;&lt;p&gt;还有比这更令人震惊的前景。例如，McCarthy在1960年描述的Lisp没有数字。从逻辑上讲，你不需要有一个单独的数字概念，因为你可以用列表来表示它们：整数n可以表示为n个元素的列表。你可以用这种方式做数学。这只是令人难以忍受的低效。&lt;/p&gt;&#xA;&lt;p&gt;实际上没有人提议在实践中用列表实现数字。事实上，McCarthy的1960年论文在当时根本不打算实现。这是一个理论练习，试图创建一个更优雅的图灵机替代方案。当有人意外地拿走这篇论文并将其翻译成工作的Lisp解释器时，数字肯定不是用列表表示的；它们像所有其他语言一样用二进制表示。&lt;/p&gt;&#xA;&lt;p&gt;编程语言能否走得那么远，以至于摆脱数字作为基本数据类型？我问这个与其说是作为一个严肃的问题，不如说是作为一种与未来玩胆小鬼游戏的方式。这就像不可抗拒的力量遇到不可移动的物体的假设情况——这里，一个令人难以想象的低效实现遇到令人难以想象的巨大资源。我看不出为什么不。未来是相当长的。如果我们能做些什么来减少核心语言中公理的数量，那么随着t趋向无穷大，这似乎是值得押注的一方。如果这个想法在一百年后似乎仍然难以忍受，也许在一千年后不会。&lt;/p&gt;&#xA;&lt;p&gt;为了明确这一点，我并不是建议所有数值计算实际上都会使用列表进行。我建议核心语言，在关于实现的任何额外符号之前，应该这样定义。在实践中，任何想做任何数量数学的程序可能会用二进制表示数字，但这将是一种优化，而不是核心语言语义的一部分。&lt;/p&gt;&#xA;&lt;p&gt;燃烧周期的另一种方法是在应用程序和硬件之间拥有多层软件。这也是我们已经看到正在发生的趋势：许多最近的语言被编译成字节码。Bill Woods曾经告诉我，根据经验法则，每层解释成本在速度上要付出10倍的代价。这种额外的代价给你带来灵活性。&lt;/p&gt;&#xA;&lt;p&gt;Arc的第一个版本就是这种多层次缓慢的极端情况，相应的好处。它是一个经典的&amp;quot;元循环&amp;quot;解释器，在Common Lisp之上编写，与McCarthy原始Lisp论文中定义的eval函数有明显的家族相似性。整个事情只有几百行代码，所以非常容易理解和改变。我们使用的Common Lisp，CLisp，本身在字节码解释器之上运行。所以我们有两层解释，其中一层（顶层）惊人地低效，而语言是可用的。我承认勉强可用，但是可用的。&lt;/p&gt;&#xA;&lt;p&gt;即使在应用程序内部，将软件编写为多层也是一种强大的技术。自底向上编程意味着将程序编写为一系列层，每一层都作为其上一层的语言。这种方法往往产生更小、更灵活的程序。它也是通往圣杯可重用性的最佳途径。语言按定义是可重用的。你能将应用程序的更多部分推入用于编写这类应用程序的语言中，你的软件就会有更多部分是可重用的。&lt;/p&gt;&#xA;&lt;p&gt;不知何故，可重用性的想法在20世纪80年代与面向对象编程联系在一起，似乎没有任何相反的证据能够动摇它。但是虽然一些面向对象的软件是可重用的，使其可重用的是其自底向上性，而不是其面向对象性。考虑库：它们是可重用的因为它们是语言，无论它们是否以面向对象风格编写。&lt;/p&gt;&#xA;&lt;p&gt;顺便说一下，我不预测面向对象编程的消亡。虽然我认为它对好的程序员没有太多提供，除了在某些特定领域，它对大组织来说是不可抗拒的。面向对象编程提供了一种可持续的方式来编写意大利面条式代码。它让你能够将程序累积为一系列补丁。大组织总是倾向于以这种方式开发软件，我期望一百年后也会如此。既然我们在谈论未来，我们最好谈谈并行计算，因为这是这个想法似乎存在的地方。也就是说，无论你什么时候谈论，并行计算似乎都是未来要发生的事情。&lt;/p&gt;&#xA;&lt;p&gt;未来会赶上它吗？人们谈论并行计算作为即将发生的事情至少有20年了，到目前为止它还没有太多影响编程实践。或者说有吗？芯片设计师现在必须考虑它，试图在多cpu计算机上编写系统软件的人也必须考虑。&lt;/p&gt;&#xA;&lt;p&gt;真正的问题是，抽象的阶梯上并行会走多远？一百年后它甚至会影响应用程序员吗？或者它会是编译器作者思考的事情，但在应用程序源代码中通常是不可见的？&lt;/p&gt;&#xA;&lt;p&gt;似乎很可能的一件事是，大多数并行机会被浪费。这是我对我们得到的大部分额外计算机能力将被浪费的更一般预测的一个特例。我期望，就像底层硬件的惊人速度一样，并行将是如果你明确要求它就可以使用的东西，但通常不被使用。这意味着我们一百年后拥有的那种并行不会，除非在特殊应用中，是大规模并行。我期望对于普通程序员来说，它更像是能够分叉出最终并行运行的进程。&lt;/p&gt;&#xA;&lt;p&gt;这将像要求数据结构的特定实现一样，是你对程序进行优化时相当晚才做的事情。版本1通常会忽略从并行计算中获得的任何优势，就像它们会忽略从数据的特定表示中获得的任何优势一样。&lt;/p&gt;&#xA;&lt;p&gt;除了特殊类型的应用程序，并行不会渗透到一百年后编写的程序中。如果确实如此，那将是过早优化。&lt;/p&gt;&#xA;&lt;p&gt;一百年后会有多少种编程语言？最近似乎有大量的新编程语言。部分原因是更快的硬件使程序员能够在速度和便利性之间做出不同的权衡，取决于应用。如果这是一个真正的趋势，我们一百年后拥有的硬件只会增加它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>简洁即力量</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/power/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/power/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/power/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/power.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/power.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/power.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;简洁即力量&#34;&gt;简洁即力量&lt;/h1&gt;&#xA;&lt;p&gt;2002年5月&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;通过代数符号将大量意义压缩到一个小空间中，这是另一个有助于我们习惯性推理的因素。&amp;rdquo; - 查尔斯·巴贝奇，引自艾弗森的图灵奖演讲&lt;/p&gt;&#xA;&lt;p&gt;在LL1邮件列表上关于《书呆子的复仇》所提出问题的讨论中，保罗·普雷斯科德写了一些让我印象深刻的话。Python的目标是规范性和可读性，而不是简洁性。表面上看来，这对编程语言来说似乎是一个相当不利的评价。据我所知，简洁性=力量。如果是这样，那么替换后我们得到Python的目标是规范性和可读性，而不是力量。这似乎不是一个你想要做出的权衡（如果这确实是一个权衡的话）。这几乎等同于说Python的目标不是作为一种有效的编程语言。&lt;/p&gt;&#xA;&lt;p&gt;简洁性等于力量吗？在我看来，这是一个重要的问题，可能是对任何对语言设计感兴趣的人来说最重要的问题，直接面对这个问题会很有用。我还不确定答案是否是简单的&amp;quot;是&amp;quot;，但这似乎是一个很好的开始假设。&lt;/p&gt;&#xA;&lt;h2 id=&#34;假设&#34;&gt;假设&lt;/h2&gt;&#xA;&lt;p&gt;我的假设是简洁性就是力量，或者足够接近，除了在病态的例子中，你可以将它们视为相同。&lt;/p&gt;&#xA;&lt;p&gt;在我看来，简洁性就是编程语言的意义所在。计算机对于直接用机器语言被告知要做什么同样满意。我认为我们开发高级语言的主要原因是获得杠杆作用，这样我们就可以用高级语言的10行代码来表达（更重要的是思考）需要1000行机器语言才能完成的事情。换句话说，高级语言的主要目的是使源代码更小。&lt;/p&gt;&#xA;&lt;p&gt;如果更小的源代码是高级语言的目的，而某种东西的力量是它实现其目的的程度，那么编程语言力量的衡量标准就是它使你的程序变得多小。&lt;/p&gt;&#xA;&lt;p&gt;相反，不能使你的程序更小的语言在编程语言应该做的事情上做得不好，就像一把不好切的刀或难以辨认的印刷品。&lt;/p&gt;&#xA;&lt;h2 id=&#34;衡量标准&#34;&gt;衡量标准&lt;/h2&gt;&#xA;&lt;p&gt;但是从什么意义上来说更小呢？代码大小最常见的衡量标准是代码行数。但我认为这个衡量标准最常见是因为它最容易测量。我不认为有人真正相信它是程序长度的真正测试。不同的语言对于在一行中放多少内容有不同的约定；在C语言中，很多行只有一个或两个分隔符。&lt;/p&gt;&#xA;&lt;p&gt;另一个简单的测试是程序中的字符数，但这也不是很好；一些语言（例如Perl）只是使用比其他语言更短的标识符。&lt;/p&gt;&#xA;&lt;p&gt;我认为程序大小的更好衡量标准是元素的数量，其中元素是如果你画一个表示源代码的树，会成为不同节点的任何东西。变量或函数的名称是一个元素；整数或浮点数是一个元素；一段字面文本是一个元素；模式元素或格式指令是一个元素；新块是一个元素。有一些边界情况（-5是两个元素还是一个？）但我认为大多数情况对每种语言都是相同的，所以它们不会对比较产生太大影响。&lt;/p&gt;&#xA;&lt;p&gt;这个衡量标准需要充实，在特定语言的情况下可能需要解释，但我认为它试图衡量正确的东西，即程序拥有的部分数量。我认为在这个练习中你会画的树就是你为了构思程序而必须在头脑中构建的东西，它的大小与你必须做的工作量成正比，无论是写还是读。&lt;/p&gt;&#xA;&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;&#xA;&lt;p&gt;这种衡量标准可以让我们比较不同的语言，但至少对我而言，这不是它的主要价值。简洁性测试的主要价值是作为设计语言的指导。语言之间最有用的比较是同一种语言的两个潜在变体之间的比较。我能在语言中做什么来使程序更短？&lt;/p&gt;&#xA;&lt;p&gt;如果程序的概念负荷与其复杂性成正比，而给定的程序员可以容忍固定的概念负荷，那么这与问&amp;quot;我能做什么来让程序员完成最多工作？&amp;ldquo;是相同的。这在我看来与问&amp;quot;我如何设计一种好的语言？&amp;ldquo;是相同的。&lt;/p&gt;&#xA;&lt;p&gt;（顺便说一句，没有什么比设计语言更能明显地证明&amp;quot;所有语言都是等价的&amp;quot;这个老生常谈是错误的了。当你设计一种新语言时，你不断地比较两种语言——如果我做了x的语言，如果我没做x的语言——来决定哪个更好。如果这真是一个无意义的问题，你不妨抛硬币。）&lt;/p&gt;&#xA;&lt;p&gt;以简洁性为目标似乎是寻找新想法的好方法。如果你能做一些让许多不同程序更短的事情，这可能不是巧合：你可能发现了一个有用的新抽象。你甚至可以编写一个程序来帮助搜索源代码中的重复模式。在其他语言中，那些以简洁性著称的语言是寻找新想法的地方：Forth、Joy、Icon。&lt;/p&gt;&#xA;&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;&#xA;&lt;p&gt;据我所知，第一个写这些相关文章的人是弗雷德·布鲁克斯在《人月神话》中。他写道，无论使用什么语言，程序员每天似乎生成大致相同数量的代码。我在二十出头第一次读到这个时，这是一个很大的惊喜，似乎有巨大的含义。这意味着（a）让软件写得更快的方法是使用更简洁的语言，（b）花功夫这样做的人可以把不这样做的竞争对手远远甩在后面。&lt;/p&gt;&#xA;&lt;p&gt;布鲁克斯的假设，如果它是真的，似乎处于黑客精神的核心。从那以后的几年里，我密切关注我能得到的关于这个问题的任何证据，从正式研究到个人项目的轶事。我没有看到任何与他相矛盾的证据。&lt;/p&gt;&#xA;&lt;p&gt;我还没有看到我认为决定性的证据，我也不期望看到。像卢茨·普雷克特尔对编程语言的比较这样的研究，虽然产生了我期望的那种结果，但往往使用太短的问题，无法成为有意义的测试。语言的更好测试是在需要一个月编写的程序中发生什么。而真正的测试，如果你像我一样相信语言的主要目的是为了便于思考（而不仅仅是在你思考完后告诉计算机要做什么），是你能用它写出什么新东西。所以任何需要满足预定义规范的语言比较都在测试稍微错误的东西。&lt;/p&gt;&#xA;&lt;p&gt;语言的真正测试是你发现和解决新问题的能力，而不是你用它解决别人已经制定的问题的能力。这是两个完全不同的标准。在艺术中，像刺绣和马赛克这样的媒介，如果你事先知道你想制作什么，效果很好，但如果你不知道，就绝对糟糕。当你想在制作过程中发现图像时——就像你必须处理像人物图像这样复杂的东西一样——你需要使用更流动的媒介，如铅笔、水墨或油画。实际上，挂毯和马赛克的制作方式是先制作一幅画，然后复制它。（&amp;ldquo;卡通&amp;quot;这个词最初用来描述用于这个目的的画。）&lt;/p&gt;&#xA;&lt;p&gt;这意味着我们永远不可能对编程语言的相对力量有准确的比较。我们会有精确的比较，但不会有准确的比较。特别是，为了比较语言而进行的明确研究，因为它们可能会使用小问题，并且必须使用预定义的问题，往往会低估更强大语言的力量。&lt;/p&gt;&#xA;&lt;p&gt;来自现场的报告，虽然它们必然不如&amp;quot;科学&amp;quot;研究精确，但可能更有意义。例如，爱立信的乌尔夫·维格进行了一项研究，结论是Erlang比C++简洁4-10倍，开发软件的速度也相应更快：爱立信内部开发项目之间的比较表明，包括软件开发的所有阶段在内的每行/小时生产力相似，几乎与使用的语言（Erlang、PLEX、C、C++或Java）无关。区分不同语言的成为源代码量。该研究还明确处理了布鲁克斯书中只是隐含的一点（因为他测量的是调试代码的行数）：用更强大语言编写的程序往往有更少的错误。这本身就成为一个目的，在网络交换机等应用中，可能比程序员的生产力更重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;味道测试&#34;&gt;味道测试&lt;/h2&gt;&#xA;&lt;p&gt;最终，我认为你必须凭直觉行事。用这种语言编程感觉如何？我认为找到（或设计）最好语言的方法是对语言让你思考的出色程度变得高度敏感，然后选择/设计感觉最好的语言。如果某些语言功能笨拙或限制性，别担心，你会知道的。&lt;/p&gt;&#xA;&lt;p&gt;这种高度敏感是有代价的。你会发现你无法忍受在笨拙的语言中编程。我觉得在没有宏的语言中编程是无法忍受的限制性，就像习惯动态类型的人发现必须回到必须声明每个变量类型、不能制作不同类型对象列表的语言中编程是无法忍受的限制性一样。我不是唯一一个这样的人。我知道许多Lisp黑客都经历过这种情况。事实上，编程语言相对力量的最准确衡量标准可能是了解该语言的人愿意接受任何使用该语言的工作的百分比，不管应用领域如何。&lt;/p&gt;&#xA;&lt;h2 id=&#34;限制性&#34;&gt;限制性&lt;/h2&gt;&#xA;&lt;p&gt;我认为大多数黑客都知道语言感觉限制性是什么意思。当你有这种感觉时发生了什么？我认为这与当你想走的街道被封锁，你必须绕很长的路才能到达你想去的地方时的感觉相同。你有想说的话，但语言不允许你说。&lt;/p&gt;&#xA;&lt;p&gt;这里真正发生的事情，我认为，是限制性语言是一种不够简洁的语言。问题不仅仅是你不能说你计划说的话。而是语言让你绕的弯路更长。试试这个思维实验。假设你想写某个程序，语言不允许你按计划的方式表达它，而是强迫你用某种更短的方式写程序。至少对我来说，这不会感觉很有限制性。这就像你想走的街道被封锁，十字路口的警察给你指了一条捷径而不是绕路。太好了！&lt;/p&gt;&#xA;&lt;p&gt;我认为限制性的感觉大部分（百分之九十？）来自于被迫使你在语言中写的程序比你头脑中的更长。限制性主要是缺乏简洁性。所以当一种语言感觉有限制性时，这（大部分）意味着它不够简洁，而当一种语言不够简洁时，它会感觉有限制性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;可读性&#34;&gt;可读性&lt;/h2&gt;&#xA;&lt;p&gt;我开始引用的引言提到了另外两个品质，规范性和可读性。我不确定性规范性是什么，或者规范和可读的代码比仅仅可读的代码有什么优势，如果有的话。但我想我知道可读性是什么意思，我认为它也与简洁性有关。&lt;/p&gt;&#xA;&lt;p&gt;我们必须小心区分单行代码的可读性和整个程序的可读性。重要的是后者。我同意Basic的一行代码可能比Lisp的一行代码更易读。但用Basic编写的程序行数会比用Lisp编写的相同程序多（特别是当你进入格林斯彭之地时）。阅读Basic程序的总工作量肯定会更大。总工作量 = 每行工作量 × 行数&lt;/p&gt;&#xA;&lt;p&gt;我不像确信力量与简洁性成正比那样确信可读性与简洁性成正比，但简洁性肯定是可读性的一个因素（在数学意义上；见上面的公式）。所以，说语言的目标是可读性而不是简洁性可能甚至没有意义；这就像说目标是可读性，而不是可读性。&lt;/p&gt;&#xA;&lt;p&gt;每行可读性对第一次遇到语言的用户来说，意味着源代码看起来不具威胁性。所以每行可读性可能是一个好的营销决策，即使它是一个糟糕的设计决策。它与让人们分期付款的非常成功的技术同构：不是用高昂的前期价格吓唬他们，而是告诉他们低月付款。分期付款对买方来说是净亏损，而每行可读性对程序员来说可能也是如此。买方将进行很多很多低月付款；而程序员将阅读很多很多单独可读的行。&lt;/p&gt;&#xA;&lt;p&gt;这种权衡比编程语言更早。如果你习惯于阅读小说和报纸文章，你第一次阅读数学论文的经历可能会令人沮丧。阅读一页可能需要半小时。然而，我很确定符号不是问题，尽管感觉上可能是。数学论文难读是因为思想难。如果你用散文表达相同的思想（正如数学家在发展出简洁的符号之前必须做的那样），它们不会更容易读，因为论文会增长到一本书的大小。&lt;/p&gt;&#xA;&lt;h2 id=&#34;到什么程度&#34;&gt;到什么程度？&lt;/h2&gt;&#xA;&lt;p&gt;许多人拒绝了简洁性=力量的想法。我认为与其简单地争论它们相同或不同，不如问：简洁性在多大程度上等于力量？因为很明显，简洁性是高级语言重要目的的大部分。如果不是全部，那么它们还有什么其他目的，相对而言，这些其他功能有多重要？&lt;/p&gt;&#xA;&lt;p&gt;我提出这个不仅仅是为了让辩论更加文明。我真的想知道答案。如果有的话，语言什么时候会因为过于简洁而对自己不利？&lt;/p&gt;&#xA;&lt;p&gt;我开始的假设是，除了在病态的例子中，我认为简洁性可以被视为等同于力量。我的意思是，在任何任何人会设计的语言中，它们都是相同的，但如果有人想要设计一种语言来明确反驳这个假设，他们可能能够做到。实际上，我甚至不确定这一点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;语言而不是程序&#34;&gt;语言，而不是程序&lt;/h2&gt;&#xA;&lt;p&gt;我们应该清楚我们讨论的是语言的简洁性，而不是单个程序的简洁性。单个程序当然可能写得太密集。&lt;/p&gt;&#xA;&lt;p&gt;我在《On Lisp》中写过这个。一个复杂的宏可能需要节省自身长度的许多倍才能证明其合理性。如果编写某个复杂的宏每次使用都能为你节省十行代码，而宏本身是十行代码，那么如果你使用超过一次，你就会在行数上获得净节省。但这可能仍然是一个坏举动，因为宏定义比普通代码更难读。你可能需要使用宏十次或二十次才能在可读性上获得净改善。&lt;/p&gt;&#xA;&lt;p&gt;我确信每种语言都有这样的权衡（虽然我怀疑随着语言变得更强大，赌注会更高）。每个程序员肯定都见过一些聪明人使用可疑的编程技巧使代码略微缩短的例子。&lt;/p&gt;&#xA;&lt;p&gt;所以对此没有争论——至少，不是我争论。单个程序当然可能因为过于简洁而对自己不利。问题是，语言会吗？语言能强迫程序员编写在元素上很短但以整体可读性为代价的代码吗？&lt;/p&gt;&#xA;&lt;p&gt;很难想象语言过于简洁的一个原因是，如果有一些过于紧凑的方式来表达某些东西，可能也会有更长的表达方式。例如，如果你觉得使用大量宏或高阶函数的Lisp程序太密集，如果你愿意，你可以编写与Pascal同构的代码。如果你不想在Arc中将对高阶函数的调用表示为阶乘（rec zero 1 * 1-），你也可以写出递归定义：(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))&lt;/p&gt;</description>
    </item>
    <item>
      <title>设计与研究</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/desres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/desres/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/desres/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/desres.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/desres.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/desres.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;设计与研究&#34;&gt;设计与研究&lt;/h1&gt;&#xA;&lt;p&gt;2003年1月&lt;/p&gt;&#xA;&lt;p&gt;（本文源自2002年秋季NEPLS会议的主题演讲。）&lt;/p&gt;&#xA;&lt;p&gt;访问这个国家的人常常惊讶地发现，美国人喜欢以询问&amp;quot;你是做什么的？&amp;ldquo;来开始对话。我从来不喜欢这个问题。我很少有一个简洁的答案。但我想我终于解决了这个问题。现在，当有人问我做什么时，我会直视他们的眼睛说&amp;quot;我正在设计一种新的Lisp方言。&amp;ldquo;我推荐这个答案给任何不喜欢被问及做什么的人。对话会立即转向其他话题。&lt;/p&gt;&#xA;&lt;p&gt;我不认为自己在研究编程语言。我只是在设计一种，就像有人可能设计一座建筑、一把椅子或一种新字体一样。我不是在试图发现什么新东西。我只是想创造一种编程起来很舒服的语言。在某些方面，这个假设让生活轻松很多。&lt;/p&gt;&#xA;&lt;p&gt;设计和研究之间的区别似乎是一个新与好的问题。设计不一定要新，但一定要好。研究不一定要好，但一定要新。我认为这两条路在顶端汇合：最好的设计通过使用新思想超越其前人，而最好的研究解决的不仅是新的问题，而且是真正值得解决的问题。所以最终我们的目标是相同的目的地，只是从不同的方向接近。&lt;/p&gt;&#xA;&lt;p&gt;今天我要谈论的是从背面看你的目标是什么样子的。当你把编程语言视为设计问题而非研究课题时，你会做什么不同的事情？&lt;/p&gt;&#xA;&lt;p&gt;最大的区别是你更关注用户。设计始于问，这是为谁而做的，他们从中需要什么？例如，一个好的建筑师不是先创建一个设计然后强加给用户，而是通过研究预期用户并找出他们需要什么来开始。&lt;/p&gt;&#xA;&lt;p&gt;注意我说的是&amp;quot;他们需要的&amp;rdquo;，而不是&amp;quot;他们想要的&amp;rdquo;。我并不是说作为一名设计师工作意味着像快餐厨师一样工作，做客户告诉你的任何事情。这在艺术领域的各个领域都有所不同，但我不认为有任何领域是由那些完全按照客户要求做事的人做出最好的作品的。&lt;/p&gt;&#xA;&lt;p&gt;在衡量好设计的标准是它对用户有多好用这一点上，顾客永远是对的。如果你写了一本让所有人都感到无聊的小说，或者一把坐着极不舒服的椅子，那么你的工作就很糟糕，就是这样。说小说或椅子是根据最先进的理论原理设计的，这并不是辩解。&lt;/p&gt;&#xA;&lt;p&gt;然而，做出对用户有用的东西并不意味着简单地做用户告诉你做的事情。用户不知道所有的选择是什么，而且常常对他们真正想要的东西感到困惑。&lt;/p&gt;&#xA;&lt;p&gt;这个悖论的答案，我认为是你必须为用户设计，但必须设计用户需要的东西，而不是仅仅设计他们说他们想要的东西。这很像做医生。你不能仅仅治疗病人的症状。当病人告诉你他们的症状时，你必须找出真正的问题所在，并治疗那个。&lt;/p&gt;&#xA;&lt;p&gt;这种对用户的关注是一种公理，大多数好的设计实践都可以从中推导出来，大多数设计问题都围绕着它。&lt;/p&gt;&#xA;&lt;p&gt;如果好的设计必须满足用户的需求，那么用户是谁？当我说设计必须为用户时，我并不是说好的设计旨在某种最低标准。你可以选择任何你想要的用户群体。例如，如果你在设计一个工具，你可以为从初学者到专家的任何人设计，而针对一个群体的好设计对另一个群体可能是坏的设计。关键是，你必须选择某个用户群体。我认为除非参考某个预期用户，否则你甚至无法谈论好或坏的设计。&lt;/p&gt;&#xA;&lt;p&gt;如果预期用户包括设计师自己，你最有可能获得好的设计。当你为不包括你自己的群体设计东西时，它往往是为那些你认为比你不够复杂的人设计的，而不是更复杂的。&lt;/p&gt;&#xA;&lt;p&gt;这是一个问题，因为无论多么仁慈，居高临下地看待用户似乎不可避免地会腐蚀设计师。我怀疑美国很少有住房项目是由期望住在那里的建筑师设计的。你可以在编程语言中看到同样的现象。C、Lisp和Smalltalk是为它们自己的设计师使用而创建的。Cobol、Ada和Java是为其他人使用而创建的。&lt;/p&gt;&#xA;&lt;p&gt;如果你认为你在为白痴设计东西，那么很可能你设计的东西不够好，即使是对白痴来说。即使你为最复杂的用户设计东西，你仍然在为人类设计。在研究方面情况不同。在数学中，你选择抽象不是因为它们容易理解，而是因为它们能让证明更短。我认为这对科学大体上也是如此。科学思想并不是为了符合人体工程学。&lt;/p&gt;&#xA;&lt;p&gt;在艺术领域，情况非常不同。设计完全是关于人的。人体是个奇怪的东西，但当你设计一把椅子时，那就是你设计的对象，没有办法回避。所有艺术都必须迎合人类的兴趣和局限性。例如，在绘画中，在其他条件相同的情况下，有人的画比没有人的画更有趣。文艺复兴时期的伟大画作都充满了人，这不仅仅是历史的偶然。如果不是这样，绘画作为媒介就不会拥有它所拥有的声望。&lt;/p&gt;&#xA;&lt;p&gt;不管喜欢与否，编程语言也是为人类服务的，我怀疑人脑就像人体一样凹凸不平且特异。有些思想人们很容易掌握，有些则不然。例如，我们处理细节的能力似乎非常有限。正是这个事实使得编程语言一开始就是个好主意；如果我们能处理细节，我们可以直接用机器语言编程。&lt;/p&gt;&#xA;&lt;p&gt;还要记住，语言主要不是完成程序的形式，而是程序必须在其中开发的东西。任何艺术领域的人都会告诉你，你可能需要不同的媒介来处理这两种情况。例如，大理石是完成思想的漂亮、耐用的媒介，但对于开发新思想来说，它却是一种无可救药的僵化媒介。&lt;/p&gt;&#xA;&lt;p&gt;程序就像证明一样，是一棵树的修剪版本，这棵树过去到处都有错误的分支。所以语言的测试不仅仅是完成的程序在它里面看起来有多干净，而是到达完成程序的路径有多干净。一个能给你优雅完成程序的设计选择可能不会给你一个优雅的设计过程。例如，我写过几个定义宏的宏，充满了嵌套的反引号，现在看起来像小宝石，但写它们花费了数小时最丑陋的试错，而且坦率地说，我仍然不完全确定它们是正确的。&lt;/p&gt;&#xA;&lt;p&gt;我们常常表现得好像语言的测试是完成的程序在它里面看起来有多好。当你看到同一个程序用两种语言编写，一个版本短得多时，这似乎很有说服力。当你从艺术的角度接近这个问题时，你不太可能依赖这种测试。你不想最终得到一个像大理石一样的编程语言。&lt;/p&gt;&#xA;&lt;p&gt;例如，在软件开发中拥有一个交互式顶层（在Lisp中称为读取-求值-打印循环）是一个巨大的胜利。当你有一个这样的东西时，它对语言的设计有实际影响。它对于一个必须在使用前声明变量的语言来说效果不佳，例如。当你只是在顶层输入表达式时，你希望能够将x设置为某个值，然后开始对x做事情。你不想必须先声明x的类型。你可以对任何一个前提提出异议，但如果一个语言必须有顶层才能方便，而强制类型声明与顶层不兼容，那么任何强制类型声明的语言都不可能方便编程。&lt;/p&gt;&#xA;&lt;p&gt;在实践中，要获得好的设计，你必须接近并保持接近你的用户。你必须不断在实际用户上校准你的想法，尤其是在开始时。简·奥斯汀的小说如此之好的原因之一是她把它们大声读给家人听。这就是为什么她从不沉溺于自我放纵的风景描述或矫饰的哲学思考。（哲学在那里，但它被编织进故事中，而不是像标签一样粘贴在上面。）如果你打开一本普通的&amp;quot;文学&amp;quot;小说，想象把它作为你写的东西大声读给朋友听，你会敏锐地感觉到那种东西对读者来说是多么令人难以忍受。&lt;/p&gt;&#xA;&lt;p&gt;在软件世界，这个想法被称为&amp;quot;较差就是更好&amp;quot;。实际上，&amp;ldquo;较差就是更好&amp;quot;的概念中混合了几个想法，这就是为什么人们仍在争论较差是否真的更好。但这个混合中的主要思想之一是，如果你在构建新东西，你应该尽快将原型放到用户面前。&lt;/p&gt;&#xA;&lt;p&gt;另一种方法可能叫做&amp;quot;万福玛丽亚策略&amp;rdquo;。你不是快速拿出原型并逐步改进它，而是试图在一次长传触地中创建完整、完成的产品。据我所知，这是灾难的根源。无数创业公司在互联网泡沫期间这样自我毁灭。我从未听说过有成功的案例。&lt;/p&gt;&#xA;&lt;p&gt;软件世界之外的人可能没有意识到的是，&amp;ldquo;较差就是更好&amp;quot;的思想在整个艺术领域都有体现。例如，在绘画中，这个思想在文艺复兴时期被发现。现在几乎每个绘画老师都会告诉你，获得准确绘画的正确方法不是慢慢地围绕物体的轮廓工作，因为错误会累积，最后你会发现线条不相遇。相反，你应该在大致正确的地方画几条快速的线，然后逐渐完善这个初始草图。&lt;/p&gt;&#xA;&lt;p&gt;在大多数领域，传统上原型是用不同材料制作的。要切割成金属的字体最初是用刷子在纸上设计的。要铸成青铜的雕像是用蜡建模的。要在挂毯上刺绣的图案是用墨水在纸上绘制的。要用石头建造的建筑是在较小规模的木材上测试的。&lt;/p&gt;&#xA;&lt;p&gt;当油画在十五世纪首次流行时令人兴奋的原因是，你实际上可以从原型制作完成的作品。如果你愿意，可以做一个初步的绘图，但你不必受它约束；你可以在完成绘画时解决所有细节，甚至做重大改变。&lt;/p&gt;&#xA;&lt;p&gt;在软件中你也可以这样做。原型不一定只是一个模型；你可以将其精制成成品。我认为你应该在可能的时候总是这样做。它能让你利用一路上获得的新见解。但也许更重要的是，它对士气有好处。&lt;/p&gt;&#xA;&lt;p&gt;士气在设计中至关重要。我很惊讶人们不多谈论它。我的第一个绘画老师告诉我：当你画某样东西感到无聊时，画出来的东西看起来会很无聊。例如，假设你必须画一栋建筑，你决定单独画每一块砖。如果你愿意，你可以这样做，但如果你中途感到无聊并开始机械地画砖而不是观察每一块，那么画出来的效果会比仅仅暗示砖块要差。&lt;/p&gt;&#xA;&lt;p&gt;通过逐步完善原型来建造东西对士气有好处，因为它能让你保持投入。在软件中，我的规则是：始终有可工作的代码。如果你正在写一小时内可以测试的东西，那么你有立即获得奖励的前景来激励你。在艺术领域也是如此，特别是在油画中。大多数画家从模糊的草图开始，然后逐步完善。如果你这样工作，那么原则上你永远不必在一天结束时留下看起来确实未完成的东西。确实，画家之间甚至有句谚语：&amp;ldquo;一幅画永远不会完成，你只是停止在上面工作。&amp;ldquo;这个想法对任何做过软件的人来说都很熟悉。&lt;/p&gt;&#xA;&lt;p&gt;士气是难以设计给不够复杂用户的另一个原因。很难对自己不喜欢的东西保持兴趣。要做出好东西，你必须想&amp;quot;哇，这真的很棒&amp;rdquo;，而不是&amp;quot;这是什么垃圾；那些傻瓜会喜欢它&amp;rdquo;。&lt;/p&gt;&#xA;&lt;p&gt;设计意味着为人类制造东西。但不仅仅是用户是人。设计师也是人。&lt;/p&gt;&#xA;&lt;p&gt;注意这段时间我一直在谈论&amp;quot;设计师&amp;rdquo;。设计通常必须由单个人控制才能做好。然而，似乎几个人可以合作进行一个研究项目。这在我看来是研究和设计之间最有趣的区别之一。&lt;/p&gt;&#xA;&lt;p&gt;艺术领域有著名合作的例子，但它们大多数似乎是分子结合而不是核融合的情况。在歌剧中，通常由一个人写剧本，另一个人写音乐。在文艺复兴时期，来自北欧的工匠经常被雇佣来做意大利绘画背景中的风景。但这些不是真正的合作。它们更像是罗伯特·弗罗斯特&amp;quot;好篱笆造就好邻居&amp;quot;的例子。你可以把好的设计实例粘在一起，但在每个单独的项目中，一个人必须处于控制地位。&lt;/p&gt;&#xA;&lt;p&gt;我不是说好的设计要求一个人思考所有事情。没有什么比一个你信任其判断的人的建议更有价值了。但谈话结束后，关于做什么的决定必须由一个人来做。&lt;/p&gt;&#xA;&lt;p&gt;为什么研究可以由合作者完成而设计不能？这是一个有趣的问题。我不知道答案。也许，如果设计和研究汇合，最好的研究也是好的设计，而且实际上不能由合作者完成。许多最著名的科学家似乎都是独自工作的。但我了解得不够多，无法说这里是否有模式。这可能仅仅是因为许多著名科学家工作时合作不那么普遍。&lt;/p&gt;&#xA;&lt;p&gt;无论科学领域的情况如何，真正的合作在艺术领域似乎极为罕见。委员会设计是坏设计的同义词。为什么会这样？有什么方法可以克服这个限制吗？&lt;/p&gt;&#xA;&lt;p&gt;我倾向于认为没有——好的设计需要一个独裁者。一个原因是好的设计必须是一体的。设计不仅是为人类，而是为单个的人。如果一个设计代表的思想适合一个人的头脑，那么这个思想也会适合用户的头脑。&lt;/p&gt;&#xA;&lt;p&gt;相关链接：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.aoky.net/articles/paul_graham/design_and_research_japanese.htm&#34;&gt;日语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://linguage.github.io/paul_graham/essays_zh/taste/&#34;&gt;制造者的品味&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.kent.ac.uk/people/staff/srk21/research/papers/graham/design_and_research_romanian.pdf&#34;&gt;罗马尼亚语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.barrahome.org/blog/articulos/diseno_e_investigacion&#34;&gt;西班牙语翻译&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
