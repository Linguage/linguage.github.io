<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>软件工程 on Linguista</title><link>https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 软件工程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 27 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>AI编程时代之后软件工程的未来演进</title><link>https://linguista.cn/curated/henrinotes-2025_p2/ai-coding-future-software-engineering-scott-wu/</link><pubDate>Sat, 27 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025_p2/ai-coding-future-software-engineering-scott-wu/</guid><description>&lt;h1 id="ai编程时代之后软件工程的未来演进"&gt;AI编程时代之后软件工程的未来演进&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于AI&amp;amp;I播客对Cognition Labs CEO Scott Wu的深度访谈，探讨了AI编程代理（如Devin）的崛起如何重塑软件工程的本质。Wu认为，AGI已在经济意义上部分到来，AI代理的自主时间正像孩子成长一样逐步延长。未来软件工程将呈现人机协作新范式：AI负责重复性编码任务，人类工程师专注于架构设计、需求拆解和技术决策等高阶抽象工作。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;对话围绕六大核心主题展开。首先关于AGI是否已到来，Wu提出&amp;quot;经济价值标准&amp;quot;——当AI代理能够持续自主运作并创造经济价值时，即意味着AGI实质到来。他强调社会对AGI的定义是动态演进的，自动化水平提升后，人类又会转向剩余未被自动化的工作。&lt;/p&gt;
&lt;p&gt;在软件工程变革方面，Wu认为AI正在重塑编程的&amp;quot;基本单元&amp;quot;。未来工程师将分化为两类：通过AI提升效率的传统工程师，以及以人机协作为本的AI优先型工程师。后者仅在特殊情况下手动编码，更多承担决策与调度角色。&lt;/p&gt;
&lt;p&gt;关于工具形态演化，Wu描述了从同步IDE工具（Tab补全）到异步智能体（Devin）再到CLI智能体（Cloud Code）的演进路径。未来将形成同步-异步无缝切换的混合开发流程：人类主导项目决策和需求拆解，AI执行具体编码、测试、调试等流程化任务。&lt;/p&gt;
&lt;p&gt;在技术实现层面，Cognition Labs不自研基础模型，但专注于后训练和强化学习环境打造。代码场景独特的可验证反馈回路使其成为理想的RL训练环境。Wu预判长远来看，AI的在线持续学习将成为主流提升路径。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AGI的经济价值标准&lt;/strong&gt;：Wu提出判断AGI到来的实用标准不是抽象的智能指标，而是&amp;quot;长期开启AI代理成为一种盈利模式&amp;quot;。当AI能够始终处于运作状态并持续创造经济价值时，就可认为AGI实质到来。这一标准将技术能力与实际应用紧密挂钩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件工程的分层认知框架&lt;/strong&gt;：第一层为基础技能与自动化，由AI负责重复性底层工作；第二层为中阶抽象与架构设计，人类专注把控需求拆分、系统架构等决策；第三层为跨界思维与协作，激发创造性解决方案。人类需向&amp;quot;系统性专家&amp;quot;身份转型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机协作型工程师&lt;/strong&gt;：具备试错迭代心态，不断尝试新工具并坦然面对不成熟性；拥有团队归属感，强调长期事业意义高于短期收益；善于运用多终端接入点，根据需求在CLI、IDE、IM等接口间切换，适时向AI代理放权。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可验证反馈回路&lt;/strong&gt;：代码场景的独特优势在于能够提供清晰的奖励信号（运行结果、错误追踪），这使其成为理想的强化学习训练环境。训练AI软件工程师的核心是抽象设计有代表性的真实问题环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理自主时间的成长类比&lt;/strong&gt;：Wu将AI代理的发展比作儿童成长的自理能力提升——从最初只能执行Tab补全，到可连续自主运行十多分钟的长链代理，自主性持续增强。这种类比形象描述了AI能力进化的渐进性质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=ectyyex0IBo"&gt;Cognition&amp;rsquo;s CEO on What Comes After Code&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Scott Wu (采访者: Dan Shipper)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;来源&lt;/td&gt;
 &lt;td&gt;Every AI&amp;amp;I 播客&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读</title><link>https://linguista.cn/curated/henrinotes-2025-p1/devin-ai-intern-software-team-scott-wu/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/devin-ai-intern-software-team-scott-wu/</guid><description>&lt;h1 id="让ai实习生成为软件团队的无限力量devin产品与ai工程协作深度解读"&gt;让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Cognition Labs联合创始人兼CEO Scott Wu详细介绍了AI代理产品Devin如何以&amp;quot;实习生&amp;quot;角色融入软件开发团队。Devin能独立承接明确定义的工程任务，支持异步多线程并行推进，覆盖前端修复、依赖升级、文档生成、故障响应和自动化测试五大核心场景，极大提升团队吞吐量与协作效率。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;Scott Wu在本次访谈中系统阐述了Devin的产品定位与工作方式。Devin并非传统的智能IDE式代码补全工具，而是一位可被委派具体任务、能独立开展工作的AI团队成员。它定位于初级工程师角色，擅长处理明确定义的操作型任务，而非需要深度推理的复杂架构决策。&lt;/p&gt;
&lt;p&gt;在实际工作流方面，Scott演示了从任务触发到AI执行再到成果交付的完整闭环。任务通常由Slack或Linear等平台发起，Devin通过DeepWiki等工具分析代码库，自动生成Pull Request并附带截图与前后对比。团队成员可同时分派多项任务让AI并行推进，遇到瓶颈时人类即时补充指导，形成高效的人机协作Debug闭环。&lt;/p&gt;
&lt;p&gt;Scott还总结了AI融入团队的关键心智模型：异步并行与自动化协同、知识共享与公共学习、精准的Prompt工程方法论，以及人机混合的Debug复盘机制。这些框架帮助团队将AI从工具升级为真正的组织成员，实现持续成长的多智能体协作生态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异步AI实习生成员制&lt;/strong&gt;：将AI定位为团队的&amp;quot;异步无限实习生&amp;quot;，分派明确可交付的任务由AI全程自动推进。人类成员无需同步等待，可并行开展更高价值事务。这一模式的核心在于&amp;quot;任务而非问题&amp;quot;导向——AI擅长执行精准描述的操作型任务，而人类专注于需要深度推理和综合判断的复杂问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务导向的Prompt方法论&lt;/strong&gt;：所有给AI的任务需做到&amp;quot;背景充分＋指令明确&amp;quot;。Scott强调应先用DeepWiki等工具沉淀需求和背景，再生成精确Prompt输入给AI，而非直接甩给AI一句话。良好的Prompt习惯直接提升AI完成质量，减少后续返工，也推动AI产品向自动理解半成品需求的方向演进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五大黄金应用场景&lt;/strong&gt;：前端修复与微调、依赖与版本升级、文档自动生成与完善、故障响应与分析（作为第一道防线）、自动化测试与CI流程辅助。这五类任务具有明确定义、重复性高、对创造性要求较低的特点，是AI工程代理最能发挥价值的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机混合Debug闭环&lt;/strong&gt;：团队成员可追踪AI执行日志，实时发现问题并补充信息，通过多轮交互持续提升AI表现。公共频道中的协作讨论让AI不断积累组织知识，反哺后续新成员，将AI代理运营成学习型组织的核心成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多端融合协作界面&lt;/strong&gt;：AI代理可集成到Slack、Linear、IDE等多种工具中，适配不同角色和团队协作习惯。未来趋势是人类只需与AI交流需求，AI在后台自动完成所有实现细节，人类关注输出而非每一步流程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=7m_xKFqSxTo"&gt;How Devin replaces your junior engineers with infinite AI interns that never sleep&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;How I AI（Claire Vo对话Scott Wu，Cognition Labs CEO）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件复杂性的本质与偶然：AI 时代的工程变革</title><link>https://linguista.cn/curated/henrinotes_2025_p4/software-complexity-essential-vs-accidental/</link><pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/software-complexity-essential-vs-accidental/</guid><description>&lt;h1 id="软件复杂性的本质与偶然ai-时代的工程变革"&gt;软件复杂性的本质与偶然：AI 时代的工程变革&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Cognition CEO Scott Wu 在访谈中提出了软件复杂性的核心框架：本质复杂性与偶然复杂性。本质复杂性指业务逻辑、架构设计等需要人类决策的核心问题；偶然复杂性则是代码规范、环境配置等技术实现细节。他认为，AI 工具如 Devin 能够大幅削减偶然复杂性，让工程师从 80%&lt;del&gt;90% 的重复性工作中解放出来，实现 8&lt;/del&gt;15 倍的效率提升。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;访谈围绕软件复杂性的双重展开。Scott 首先明确区分了本质复杂性与偶然复杂性：前者关乎&amp;quot;做什么&amp;quot;的战略决策，如系统架构、业务逻辑处理、特殊场景应对；后者涉及&amp;quot;怎么做&amp;quot;的技术实现，如代码规范、环境配置、兼容性处理。&lt;/p&gt;
&lt;p&gt;他强调，传统软件工程中存在一个悖论：工程师的核心价值在于决策（本质复杂性），却花费 80%&lt;del&gt;90% 的时间在执行（偶然复杂性）。AI 工具的介入正在打破这一困局。Scott 以 Cognition 的 Devin 为例，展示了 AI 代理在代码迁移、版本升级、批量重构等场景下的实战表现——企业客户获得 8&lt;/del&gt;15 倍效率提升。&lt;/p&gt;
&lt;p&gt;未来工作模式将呈现&amp;quot;同步+异步&amp;quot;混合特征。同步部分，工程师在 IDE 中直接参与高层决策、架构设计、关键逻辑制定；异步部分，AI 代理根据人类指令自动完成具体实现、测试、文档等工作。Scott 预测，工程师的核心能力将从&amp;quot;记忆细节、语法&amp;quot;转向&amp;quot;高层决策、产品理解、架构设计&amp;quot;。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本质复杂性（Essential Complexity）&lt;/strong&gt;：软件开发的战略层面，指必须由人类工程师做出的核心决策，包括系统架构设计、业务逻辑处理、特殊场景应对（如余额为负时的处理方式）。Scott 认为，&amp;ldquo;软件工程师的本质就是在代码的语境下解决问题，做出各种决策&amp;rdquo;，这部分工作是 AI 无法替代的人类价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偶然复杂性（Accidental Complexity）&lt;/strong&gt;：软件开发的战术层面，指为实现和维护软件而产生的额外工作，包括代码规范、环境配置、兼容性处理等。Scott 指出，这部分工作占据工程师 80%~90% 的时间，但并不创造直接价值，正是 AI 工具应该自动化的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步+异步混合模式&lt;/strong&gt;：未来人机协作的工作范式。同步部分指工程师直接参与的高层决策、架构设计、关键逻辑制定；异步部分指 AI 代理自动完成的具体实现、测试、文档等工作。Scott 强调，&amp;ldquo;任何需要你参与的环节你都同步介入，纯执行的部分则可以异步交给 AI&amp;rdquo;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=MmKkNmnoEvw"&gt;A Cheeky Pint with Cognition CEO Scott Wu&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Stripe&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-08-27&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>AI优先与零公交因子的风险</title><link>https://linguista.cn/curated/henrinotes_2025_p4/ai-first-zero-bus-factor-risk/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/ai-first-zero-bus-factor-risk/</guid><description>&lt;h1 id="ai优先与零公交因子的风险"&gt;AI优先与零公交因子的风险&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文深入分析了生成式AI时代&amp;quot;公交因子&amp;quot;概念的根本性变化。随着ChatGPT等工具的普及，越来越多的开发者采用&amp;quot;AI优先&amp;quot;的工作方式，导致项目知识掌握者可能为零。这种现象带来了严重的知识断层、维护困境和安全风险，亟需行业重新审视AI辅助开发的边界与责任。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先回顾了公交因子的历史演变，指出这一指标长期以来用于衡量项目的知识分布风险。在最坏情况下，公交因子为1，即唯一的知识掌握者离开会导致项目无法维护。为应对这一风险，人类社会建立了完整的知识传承体系，包括内部培训、文档编写、视频教程等多种机制。&lt;/p&gt;
&lt;p&gt;然而，2022年11月ChatGPT的发布标志着这一格局的彻底改变。三年后的今天，&amp;ldquo;AI优先&amp;quot;理念逐渐成型，越来越多的开发者开始依赖大语言模型生成代码，甚至将整个项目的开发外包给AI。这种趋势导致团队成员主动或被动放弃对代码库的深度理解，形成了&amp;quot;零公交因子&amp;quot;的危险局面。&lt;/p&gt;
&lt;p&gt;作者进一步阐述了AI生成代码带来的维护困境。即使AI生成的代码质量较高，团队成员也难以快速掌握其原理和细节。传统的导师制度和文档支持体系逐渐消失，开发者只能依赖自己解读不完美系统产出的能力。在这种环境下，修复bug、添加新功能、修补安全漏洞都变得异常困难，因为没有任何人真正了解代码的来龙去脉。&lt;/p&gt;
&lt;p&gt;最后，文章从安全角度警示了这一趋势的风险。当用户将个人文件、信用卡信息、隐私数据上传到无人知晓其构建原理的软件时，数据安全和隐私保障变得极为脆弱。这不仅是技术问题，更是整个行业需要面对的责任与伦理挑战。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;公交因子&lt;/strong&gt;：衡量项目知识分布的指标，指有多少关键人员离开后项目就无法维护。传统软件工程中，公交因子的最低值是1，而在AI优先时代可能降为0，意味着无人真正掌握项目知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI优先&lt;/strong&gt;：并非让人类退居第二，而是让人类在知识掌握上彻底消失的开发理念。开发者依赖AI生成函数、特性甚至完整项目，主动放弃对代码的深入理解，导致知识断层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随性编程&lt;/strong&gt;：指在AI辅助下，开发者不关心代码实现细节，仅依赖AI生成代码的工作方式。这种方式减少了人工参与和知识积累，使项目维护和升级面临极高风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识传承体系&lt;/strong&gt;：包括内部讲座、文档、视频教程、交接、演示等传统知识分享机制。在AI主导开发的时代，这些体系逐渐被边缘化，加剧了零公交因子问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全责任断层&lt;/strong&gt;：当AI生成的代码出现安全漏洞或隐私问题时，由于无人理解代码原理，责任认定和问题修复都变得极其困难，用户数据安全面临严峻挑战。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.mindflash.org/coding/ai/ai-and-the-bus-factor-of-0-1608"&gt;AI First and the Bus Factor of 0&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;MindFlash&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>为什么大语言模型无法真正构建软件</title><link>https://linguista.cn/curated/henrinotes_2025_p3/why-llms-cant-really-build-software/</link><pubDate>Sun, 17 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p3/why-llms-cant-really-build-software/</guid><description>&lt;h1 id="为什么大语言模型无法真正构建软件"&gt;为什么大语言模型无法真正构建软件&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者丰富的软件工程师面试经验，深入分析了大语言模型在软件开发领域的现状与局限。虽然LLM在代码生成方面表现出色，但缺乏人类工程师最核心的能力——构建和维护清晰的心智模型。这使得LLM在面对复杂、非线性的问题时，难以像人类一样有效地迭代和解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先阐述了软件工程师的核心工作循环，即从理解需求、编写代码、构建代码行为的心智模型，到识别差异并持续修正的完整过程。作者强调，优秀工程师的关键在于能够持续维护清晰的心智模型，并在测试失败时做出合理判断。&lt;/p&gt;
&lt;p&gt;接着，文章分析了LLM的能力与局限。虽然LLM能够生成代码、运行测试、使用调试工具，但它们无法维护清晰的心智模型。当测试失败时，LLM往往无法判断是代码还是测试有问题，只能猜测如何修复，甚至会选择推倒重来而非有针对性地调整。&lt;/p&gt;
&lt;p&gt;最后，作者探讨了LLM未来的可能性。人类在解决问题时能够灵活管理上下文，在全局与局部之间自由切换，而当前LLM存在新近性偏见和幻觉等问题。虽然业界正在尝试为模型增加记忆能力，但LLM仍无法真正理解全局，也无法像人类一样判断是该修改代码还是需求。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;心智模型&lt;/strong&gt;：这是软件工程师最核心的能力，包括对需求的理解和对代码实际行为的把握。工程师通过不断构建和维护清晰的心智模型，能够在复杂系统中准确判断问题所在并做出合理调整。LLM缺乏这种能力，容易混淆自己生成的代码与实际需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求-实现-验证-修正循环&lt;/strong&gt;：这是软件工程师的核心工作流程。从理解需求、编写代码、构建对代码行为的心智模型，到识别差异并持续修正，这是一个不断迭代的非线性过程。LLM在这个循环中只能完成部分环节，缺乏对全局的理解和判断能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文管理&lt;/strong&gt;：人类在解决问题时能够灵活管理上下文，可以暂时搁置细节专注于当前问题，也能在全局与局部之间自由切换。而当前LLM存在新近性偏见，更关注最近输入的信息，容易忽略前文重要内容，也无法像人类一样避免信息过载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新近性偏见与幻觉&lt;/strong&gt;：这是LLM面临的两个主要问题。新近性偏见使模型更关注最近输入的信息，幻觉则让模型凭空编造不存在的细节。这些问题限制了LLM在复杂任务中的表现，使其难以准确维护足够的上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机协作&lt;/strong&gt;：尽管LLM存在局限，但它们在快速生成代码片段、合成文档、处理简单明确需求等方面仍然很有价值。现阶段，工程师必须承担起确保需求清晰、代码正确的责任，主导权仍掌握在工程师手中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://zed.dev/blog/why-llms-cant-build-software"&gt;Why LLMs Can&amp;rsquo;t Really Build Software&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Zed Blog 团队&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>专有技术困境与AI代码生成</title><link>https://linguista.cn/static/ai-know-how-dilemma/</link><pubDate>Thu, 03 Jul 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/static/ai-know-how-dilemma/</guid><description>深入探讨 AI 在软件工程中的“专有技术困境”。尽管 AI 擅长处理可编码的事实知识，但在涉及经验、直觉和情境理解的复杂任务中，其局限性暴露无遗。本分析通过交互式图表，揭示了 AI 代码生成中存在的复合错误累积、安全漏洞风险以及领域性能衰减等核心问题，并对比了人类专家与 AI 在知识处理机制上的本质差异。</description></item><item><title>AI原生软件工程师</title><link>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/ai-native-software-engineer/</guid><description>&lt;h1 id="ai原生软件工程师"&gt;AI原生软件工程师&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文定义了AI原生软件工程师的概念，即将AI深度融入日常开发工作流程、视其为协作伙伴而非威胁的工程师。文章阐述了核心思维转变——从恐惧AI取代转向主动利用AI放大自身能力，提出信任但验证的协作原则，并给出了从工具准备到逐步建立AI熟练度的实践路径，强调工程师仍需对代码质量承担全部责任。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI原生思维&lt;/strong&gt;：将AI内化为思考问题和构建软件的核心方式，对每项任务主动思考AI如何协助完成，而非被动等待&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文工程&lt;/strong&gt;：通过精心构造提示词和上下文信息，引导AI生成高质量输出的技术手段，是高级工程师发挥专业优势的关键能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信任但验证&lt;/strong&gt;：将AI视为知识丰富但经验尚浅的结对编程伙伴，利用其速度和信息量的同时，工程师必须对每一行代码的质量和正确性负最终责任&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工程师即管理者&lt;/strong&gt;：AI时代工程师角色从亲力亲为转向协调和监督AI智能体完成任务，通过规则文件和结构化代码塑造人机协作环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进式采用&lt;/strong&gt;：从小处着手逐步建立AI熟练度，先将任务交给AI模型观察表现，再结合编码助手和智能体工具形成完整的AI优先工作流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者：Addy Osmani&lt;/li&gt;
&lt;li&gt;日期：2025年7月2日&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href="https://addyo.substack.com/p/the-ai-native-software-engineer"&gt;The AI-Native Software Engineer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交互式报告：&lt;a href="https://linguage.github.io/articles/ai-native-software-engineer.html"&gt;AI原生软件工程师&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AI原生软件工程师&lt;/em&gt; 是指那些将AI深度融入日常工作流程，视其为伙伴以放大自身能力的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这需要一个根本性的&lt;strong&gt;思维转变&lt;/strong&gt;。AI原生工程师不会想“AI可能会取代我”，而是对每项任务都问自己：“&lt;em&gt;AI能帮助我更快、更好或以不同方式完成这项任务吗？&lt;/em&gt;”。&lt;/p&gt;
&lt;p&gt;这种思维模式是乐观和积极主动的——你将AI视为提高生产力和创造力的倍增器，而非威胁。采用正确的方法，&lt;strong&gt;AI可以将你作为工程师的产出提高2倍、5倍，甚至可能10倍&lt;/strong&gt;。经验丰富的开发者尤其会发现，他们的专业知识使他们能够以产生高水平结果的方式来提示AI；高级工程师可以通过适当的&lt;a href="https://x.com/karpathy/status/1937902205765607626"&gt;上下文工程&lt;/a&gt;，向AI提出正确的问题，从而获得与同行交付结果相当的答案。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!t2_Y!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ae2c5e0-27c6-4959-b37d-67f2c40b2e09_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;成为AI原生意味着拥抱&lt;strong&gt;持续学习和适应&lt;/strong&gt;——工程师从一开始就将基于AI的辅助和自动化融入软件构建中。这种思维模式会带来对可能性的兴奋而非恐惧。&lt;/p&gt;
&lt;p&gt;是的，可能会有不确定性和学习曲线——我们许多人都经历过兴奋、恐惧然后又回到兴奋的情绪过山车——但最终目标是落脚于兴奋和机遇。AI原生工程师将AI视为一种委派开发中重复或耗时部分（如样板代码、文档起草或测试生成）的方式，从而解放自己，专注于更高层次的问题解决和创新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——AI是协作者，而非替代品：&lt;/strong&gt; AI原生工程师将AI视为一个知识渊博但经验尚浅的结对编程伙伴，并且全天候可用。&lt;/p&gt;
&lt;p&gt;你仍然主导开发过程，但会不断利用AI获取想法、解决方案，甚至是警告。例如，你可能会使用AI助手来集思广益架构方案，然后凭借自己的专业知识来完善这些想法。这种协作可以显著加快开发速度，同时提高质量——&lt;em&gt;如果你能保持监督&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;重要的是，你不能将责任完全推给AI。把它想象成与一个阅读过所有StackOverflow帖子和API文档的初级开发者合作：他们拥有大量信息，可以快速生成代码，但&lt;strong&gt;你负责指导他们并验证其输出&lt;/strong&gt;。这种“&lt;a href="https://addyo.substack.com/p/the-trust-but-verify-pattern-for"&gt;信任但验证&lt;/a&gt;”的思维模式至关重要，我们稍后会再次讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!qzj1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4ff8ce3d-bcdc-45ed-933b-c0a1038c63ea_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;坦率地说：AI 生成的劣质内容是真实存在的，这不能成为&lt;a href="https://addyo.substack.com/p/vibe-coding-is-not-an-excuse-for"&gt;低质量工作&lt;/a&gt;的借口。使用这些工具的一个持续风险是草率批准的建议、微妙的幻觉和简单的懒惰相结合，这远远低于专业工程标准。这就是为什么“验证”是这个口号中不可协商的部分。作为工程师，你不仅仅是工具的使用者；你是最终的担保人。你仍然对你提交的每一行代码的质量、可读性、安全性和正确性负有全部直接责任。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!Qzt7!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F61fdf82a-2bcc-4a81-853e-779af54c24a2_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原则——现在每个工程师都是管理者：&lt;/strong&gt; 工程师的角色正在发生根本性变化。有了AI智能体，你更多地是协调工作，而不是亲力亲为地执行所有工作。&lt;/p&gt;
&lt;p&gt;你仍然对提交到主分支的每一项改动负责，但你更多地关注定义和“分配”要完成的工作。在不远的将来，我们可能会越来越多地说“&lt;a href="https://x.com/levie/status/1938647740554092586"&gt;现在每个工程师都是管理者&lt;/a&gt;”。合法的工作可以指派给Jules或Codex等后台智能体，或者你可以让Claude Code/Gemini CLI/OpenCode处理分析或代码迁移项目。工程师需要有意识地塑造代码库，使其更容易与AI协作，这可以通过使用规则文件（例如GEMINI.md）、良好的READMEs和结构良好的代码来实现。这使得工程师扮演了&lt;a href="https://www.infoworld.com/article/3994519/the-tough-task-of-making-ai-code-production-ready.html"&gt;监督者、导师和验证者&lt;/a&gt;的角色。AI优先的团队规模更小，能完成更多工作，并且能够&lt;a href="https://www.forrester.com/blogs/appgen-is-here-say-goodbye-to-software-development-as-you-know-it/"&gt;缩短SDLC的步骤&lt;/a&gt;，从而更快地交付更高质量的产品。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!wUui!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0f7cfea4-0f99-4c8d-81bd-d4c81070eee4_1024x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级优势：&lt;/strong&gt; 通过将AI完全融入你的工作流程，你可以实现显著的生产力飞跃，可能更快地发布更多功能，而不会牺牲质量（当然，这需要考虑任务复杂性等细微差别）。&lt;/p&gt;
&lt;p&gt;日常任务（从代码格式化到编写单元测试）可以在几秒钟内完成。也许更重要的是，AI可以增强你的理解：就像有一个随叫随到的专家，可以解释代码或在你专业领域之外的领域提出解决方案。结果是，AI原生工程师可以承担更雄心勃勃的项目，或者以更小的团队处理相同的工作量。从本质上讲，&lt;strong&gt;AI扩展了你的能力&lt;/strong&gt;，让你在更高的抽象层次上工作。但前提是需要有效使用它——这就是正确的思维模式和实践发挥作用的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例——思维模式的实践：&lt;/strong&gt; 想象你正在调试一个棘手的问题或评估一个新的技术栈。传统方法可能涉及大量的Google搜索或阅读文档。而AI原生方法是与支持搜索基础或深度研究的AI助手互动：描述错误或询问技术栈的优缺点，让AI提供见解甚至代码示例。&lt;/p&gt;
&lt;p&gt;你仍然负责解释和实施，但AI会加速信息收集和可能的解决方案。一旦你习惯了，这种协作式问题解决就会成为第二天性。养成习惯，问自己：“&lt;em&gt;AI如何能帮助我完成这项任务？&lt;/em&gt;”直到这成为一种反射。随着时间的推移，你将培养出AI擅长什么以及如何有效提示它的直觉。&lt;/p&gt;
&lt;p&gt;总而言之，&lt;strong&gt;成为AI原生意味着将AI内化为你思考问题和构建软件的核心方式&lt;/strong&gt;。这是一种与机器协作的思维模式：利用它们的优势（速度、知识、模式识别）来补充你自己的优势（创造力、判断力、上下文）。有了这个基础，我们就可以进入将AI融入日常工作的实用步骤。&lt;/p&gt;
&lt;p&gt;如果你对AI原生工作流程完全陌生，一开始可能会感到望而生畏。关键是&lt;strong&gt;从小处着手，逐步建立&lt;/strong&gt;你的AI熟练度。在本节中，我们将提供具体指导，帮助你在日常工程任务中从零开始，高效地使用AI。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/$s_!OGxs!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3ef50d3c-e6f1-4b5e-a850-2177e561bbc1_1536x1024.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以上是对我们最终可能在软件生命周期中实现AI的推测性展望。我仍然坚信需要人工参与（工程、设计、产品、用户体验等），以确保质量不会下降。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1：第一个改变是什么？你通常从AI开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI原生工作流程并非偶尔寻找AI可以提供帮助的任务；它通常是首先将任务交给AI模型，看看它的表现如何。&lt;a href="https://www.ignorance.ai/p/ai-at-pulley"&gt;一个团队指出&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;典型的工作流程是首先将任务交给AI模型（通过Cursor或CLI程序）……并理解很多任务仍然是“碰运气”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你是在研究一个领域还是一个竞争对手？从Gemini深度研究开始。发现自己陷入关于某个设计方面的无休止争论？当你的团队争论不休时，你可能已经用AI构建了三个原型来验证这个想法。Google员工已经&lt;a href="https://x.com/rmedranollamas/status/1938305816185966898"&gt;用它来制作幻灯片、调试生产事故等等&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当你听到“但LLM会产生幻觉，聊天机器人给出糟糕的答案”时，是时候更新你的工具链了。今天任何&lt;a href="https://fly.io/blog/youre-all-nuts/"&gt;认真使用AI编码的人都在使用智能体&lt;/a&gt;。幻觉可以通过适当的&lt;a href="https://blog.langchain.com/the-rise-of-context-engineering/"&gt;上下文工程&lt;/a&gt;和智能体反馈循环得到显著缓解和管理。思维转变是基础性的：我们所有人都应该立即成为AI优先的用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤2：准备好正确的AI工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要顺利集成AI，你需要在你的环境中至少设置一个编码助手。许多工程师从VS Code中的&lt;strong&gt;GitHub Copilot&lt;/strong&gt;开始，它具有代码自动完成和代码生成功能。如果你使用VS Code等IDE，可以考虑安装一个AI扩展（例如，&lt;strong&gt;Cursor&lt;/strong&gt;是一个专门的AI增强代码编辑器，而**&lt;a href="https://addyo.substack.com/p/why-i-use-cline-for-ai-engineering"&gt;Cline&lt;/a&gt;&lt;strong&gt;是一个用于AI智能体的VS Code插件——稍后会详细介绍这些）。这些工具非常适合初学者，因为它们在后台运行，为你正在编辑的任何文件实时提供代码建议。在编辑器之外，你还可以在单独的窗口中探索&lt;/strong&gt;ChatGPT、Gemini或Claude**，以获取问答式的帮助。从工具开始很重要，因为它降低了使用AI的摩擦。一旦安装，每当你想到“也许AI可以帮助我完成这项任务”时，AI就近在咫尺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤3：学习提示基础——具体并提供上下文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效使用AI是一项技能，这项技能的核心是**&lt;a href="https://addyo.substack.com/p/the-prompt-engineering-playbook-for"&gt;提示工程&lt;/a&gt;**。新用户常犯的一个错误是给AI一个过于模糊的指令，然后对结果感到失望。记住，AI不是读心术；它对你给出的提示做出反应。多一点上下文或清晰度会大有帮助。例如，如果你有一段代码，想要它的解释或单元测试，不要只说_“为这个写测试。”_ 相反，&lt;strong&gt;在你的提示中描述代码的预期行为和要求&lt;/strong&gt;。比较以下两个为React登录表单组件编写测试的提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;糟糕的提示：&lt;/strong&gt; “你能为我的React组件写测试吗？”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更好的提示：&lt;/strong&gt; “我有一个&lt;code&gt;LoginForm&lt;/code&gt; React组件，包含一个电子邮件字段、密码字段和提交按钮。它在成功提交时显示成功消息，在失败时显示错误消息，通过&lt;code&gt;onSubmit&lt;/code&gt;回调。&lt;strong&gt;请编写一个Jest测试文件&lt;/strong&gt;，该文件：(1) 渲染表单，(2) 填写有效和无效输入，(3) 提交表单，(4) 断言&lt;code&gt;onSubmit&lt;/code&gt;以正确数据被调用，以及 (5) 检查成功和错误状态是否正确渲染。”&lt;/p&gt;</description></item><item><title>Cursor如何利用Claude构建AI编码的未来</title><link>https://linguista.cn/rosetta/chat-notes/cursor-building-future-ai-coding-with-claude/</link><pubDate>Tue, 10 Jun 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/chat-notes/cursor-building-future-ai-coding-with-claude/</guid><description>&lt;h1 id="cursor如何利用claude构建ai编码的未来"&gt;Cursor如何利用Claude构建AI编码的未来&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Anthropic与Cursor核心团队的深度访谈，探讨AI编程工具Cursor的快速增长历程、Claude模型如何推动产品从Tab自动补全演进到多文件编辑和后台代理功能，以及AI在大型代码库理解、软件验证、代码演变和工程师角色转变等方面带来的挑战与机遇。&lt;/p&gt;
&lt;div class="video-card group relative w-full overflow-hidden rounded-2xl border border-border bg-surface shadow-sm transition hover:shadow-md "&gt;
 &lt;div style="aspect-ratio: 16/9;" class="w-full relative bg-black/5 dark:bg-white/5"&gt;
 &lt;iframe
 src="https://www.youtube-nocookie.com/embed/BGgsoIgbT_Y?rel=0&amp;amp;modestbranding=1&amp;amp;playsinline=1"
 title="Cursor如何利用Claude构建AI编码的未来"
 class="absolute inset-0 w-full h-full border-0"
 loading="lazy"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
 allowfullscreen&gt;
 &lt;/iframe&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;后台代理（Background Agent）&lt;/strong&gt;：Cursor推出的一项创新功能，允许AI在独立虚拟机环境中后台执行开发任务，开发者可在前台与后台任务间快速切换，提升并行工作效率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多文件编辑&lt;/strong&gt;：借助Claude 3.5 Sonnet等模型的推理能力提升，AI从单文件内补全进化到跨多个文件协同编辑代码的能力，是Cursor大规模采用的关键转折点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自我迭代（Dogfooding）&lt;/strong&gt;：Cursor团队使用自己的产品来开发Cursor，通过在实际使用中发现不足并持续改进，形成产品优化的递归反馈循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件验证瓶颈&lt;/strong&gt;：随着AI代码生成能力增强，如何高效验证生成代码的正确性成为制约软件工程效率提升的核心挑战&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码演变&lt;/strong&gt;：为适应大语言模型的理解和生成特性，API设计与代码结构正在发生调整，整洁代码原则对人与模型同样重要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=BGgsoIgbT_Y"&gt;How Cursor is building the future of AI coding with Claude&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方频道：&lt;a href="https://www.youtube.com/@anthropic-ai"&gt;Anthropic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="内容介绍"&gt;内容介绍&lt;/h3&gt;
&lt;p&gt;本次访谈邀请了AI编程工具Cursor的核心团队成员Jacob Jackson、Lukas Möller和Aman Sanger，与Anthropic的Alex Albert共同探讨软件开发的变革前景，特别是AI在其中的作用。对话围绕Cursor在过去一年中取得的显著增长展开，深入剖析了语言模型的进步（如Anthropic的Claude系列模型）如何推动了Cursor从最初的Tab自动补全发展到支持复杂的多文件编辑，并催生了如“后台代理”（Background Agent）这样的创新功能。&lt;/p&gt;
&lt;p&gt;访谈中，Cursor团队分享了他们“用Cursor构建Cursor”的独特开发模式，以及这种自我迭代如何加速产品优化。同时，双方就AI辅助编程面临的挑战进行了坦诚交流，包括大型生产代码库的上下文理解、软件验证的未来瓶颈，以及如何平衡自动化与工程师核心技能的培养。此外，对话还展望了代码本身可能的演化方向、Anthropic在模型开发上的理念，以及未来软件工程师角色的转变。&lt;/p&gt;
&lt;p&gt;对于希望了解AI如何重塑软件开发流程、AI编程工具的最新进展，以及顶尖AI公司如何思考行业未来的读者，这份访谈实录提供了来自实践者和模型开发者的一手见解与前瞻思考。&lt;/p&gt;
&lt;h3 id="内容纲要"&gt;内容纲要&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 引言
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 访谈嘉宾与主题介绍 (Anthropic的Alex Albert主持，Cursor的Jacob Jackson, Lukas Möller, Aman Sanger参与)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── AI将改变软件生产的各个方面
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Cursor的增长与演变
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 过去一年的快速增长与营收 ($3亿美元)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 语言模型进步与Cursor功能拓展 (如3.5 Sonnet推动多文件编辑)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 从早期功能 (Tab补全) 到多文件编辑的演进
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 模型的进步与Cursor的迭代
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 模型质量的渐进式提升与阶梯式进步
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 实验与调整在模型应用中的重要性
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── Sonnet模型与多文件交互、工具使用的实现
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 用Cursor构建Cursor：自我迭代与优势
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 团队日常使用Cursor进行开发的实践
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ │ ├── 不同场景下的功能应用 (Agent, 思考模型, Tab补全, QA功能)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ │ └── Claude 3.5/3.7在代码库研究中的作用
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 解决自身问题驱动产品迭代的理念
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 作为自身最佳客户的优势 (快速迭代、功能验证)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 功能谱系：从辅助到自主
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 不同开发者与工作场景下的AI使用差异
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 从Tab补全到Command K、Agent及后台代理的功能谱系
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 后台代理 (Background Agent) 的理念与实现
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 背景：模型能力增强但未达100%，提升开发者并行效率
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 核心理念：后台与前台任务的快速切换与控制
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 未来展望：作为新基础能力的多场景应用
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 实现机制：独立的、预装工具的虚拟机环境
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 未来的瓶颈：软件验证
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── AI生成代码能力增强带来的验证挑战
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 验证对软件工程效率提升的重要性
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 潜在解决方案：代码的不同表示形式 (如伪代码)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 大型生产代码库的挑战与解决方案探索
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 大型代码库中运行测试与依赖管理的复杂性
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 后台代理在大型代码库中的应用与环境配置
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 检索模型、上下文集成应对代码理解难题
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── “正确方式”编码的挑战 (符合代码风格、规范)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 组织知识与业务需求对编码的影响
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 代码的演变：为AI和人类优化
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── API设计与代码结构为适应LLM而调整的趋势
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 整洁代码原则对人与模型的重要性统一，品味将更重要
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 自动化浪潮下工程技能与代码质量的维系
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── AI工具的教育价值与学习辅助作用
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── AI对代码质量的双重影响与整体水平提升
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 未来工程师技能的可能演变 (细节掌握 vs 高层抽象与UX品味)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Claude新模型 (Opus 4, Sonnet 4) 的特点与集成展望
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── Cursor团队对Sonnet 4的积极评价 (修复缺陷、智能提升)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 对Opus 4作为后台代理的期待
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── Anthropic在Sonnet 3.5开发上的努力与成果
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── Anthropic的模型开发理念与未来展望
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 编码作为核心领域及其能力迁移性
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 推动模型能力边界，兼顾安全与对齐
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 模型“性格”塑造的重要性
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── 个人观点：AI赋能而非取代开发者
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;├── 未来图景：AI在软件开发中的普及与变革
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 2027年AI生成代码占比预测 (接近100%参与度)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 开发者角色将更侧重理解需求与品味
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ ├── 非软件背景人士构建自定义工具的趋势
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;│ └── “按需软件”与个性化软件体验的畅想
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;└── 给工程师的建议：选择与机遇
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; └── 创业公司在人才吸引与影响力方面的优势
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="对话实录"&gt;对话实录&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/@anthropic-ai"&gt;&lt;img src="https://yt3.ggpht.com/ux-GXUpB4PkI-qXVOpj9gGEiCkytT0Q78ka4srlxOm_Y3m1gEh5qy8Vu6vTjGSDztMT0NybtC7I=s88-c-k-c0x00ffffff-no-rj" alt=""&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>我用Python八年后学到的东西</title><link>https://linguista.cn/rosetta/technology/lessons-learned-after-8-years-of-python/</link><pubDate>Sat, 10 May 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/lessons-learned-after-8-years-of-python/</guid><description>&lt;h1 id="我用python八年后学到的东西"&gt;我用Python八年后学到的东西&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;作者基于八年Python开发经验，结合Python之禅的核心原则，系统阐述了一套实用的编程最佳实践。文章涵盖代码命名规范、简洁设计、避免过度工程、提升可读性、正确处理异常以及善用命名空间等关键要点，帮助开发者写出更优雅、更健壮的Pythonic代码。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Python之禅（Zen of Python）——由Tim Peters撰写的19条Python编程指导原则，强调优美、明确、简单和可读性，是Pythonic风格的理论基础&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过度工程（Over-engineering）——在软件开发中添加不必要的复杂性和抽象层，违背了简单胜于复杂的原则，应当避免&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常处理（Exception Handling）——通过捕获FileNotFoundException、ValueError等内置异常来应对边缘情况，确保错误不会被静默忽略&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码可读性（Code Readability）——编写清晰、扁平、逻辑隔离的代码，使团队成员能快速理解上下文，减少代码评审中的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名空间（Namespaces）——Python中用于组织代码和避免命名冲突的机制，被Python之禅称为绝妙的主意，应当多加利用&lt;/strong&gt;：&lt;/p&gt;
&lt;h3 id="python之禅示例我的建议以及其他技巧和窍门"&gt;Python之禅示例、我的建议以及其他技巧和窍门！&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原文链接： &lt;a href="https://neuralbits.substack.com/p/what-ive-learned-after-8-years-of?utm_source=multiple-personal-recommendations-email&amp;amp;utm_medium=email&amp;amp;triedRedirect=true"&gt;What I&amp;rsquo;ve learned after 8 years of Python - by Alex Razvant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日期： 2025年5月10日&lt;/li&gt;
&lt;li&gt;作者：&lt;a href="https://substack.com/@arazvant"&gt;Alex Razvant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇实用的文章中，我将阐述一套帮助我改进 Python 编程方式的最佳实践。&lt;/p&gt;
&lt;p&gt;我并非从一开始就了解这些，但随着我职业生涯的进步，它们变得显而易见，我是通过编写代码、学习 Python 中的最佳软件原则和简洁代码概念间接学到的。&lt;/p&gt;
&lt;p&gt;让我们从几个有趣的图表开始！&lt;/p&gt;
&lt;h3 id="python-的受欢迎程度"&gt;Python 的受欢迎程度&lt;/h3&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6b80e55e-60b4-4f13-807f-c15a0a4752d7_2730x878.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;2025年 TIOBE 指数记录。(&lt;a href="https://www.tiobe.com/tiobe-index/"&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;甚至在人工智能领域飞速发展之前，Python 就已经是开发者中广受欢迎的语言。它拥有清晰易懂的语法，使得各种经验水平的人都能快速学习并提高生产力。&lt;/p&gt;
&lt;p&gt;由于 Python 解释器的存在，它具有可移植性，因此跨平台开发不会涉及编译器版本或其他障碍。&lt;/p&gt;
&lt;p&gt;随着人工智能的兴起，Python 变得更加流行，谷歌的 Tensorflow 团队和 Meta 的 PyTorch 团队等大型团队都选择了 Python 优先的方法。一个快速发展的领域需要一种简化的方法，而 Python 正好适合。&lt;/p&gt;
&lt;p&gt;此外，许多其他工具、开源框架和库也积极响应，并以 Python 优先的理念进行构建。让我们看几个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pandas&lt;/li&gt;
&lt;li&gt;PyTorch (C++, Python)&lt;/li&gt;
&lt;li&gt;Tensorflow, Keras (C++, Python)&lt;/li&gt;
&lt;li&gt;Polars (后端 Rust, API Python)&lt;/li&gt;
&lt;li&gt;Bytewax (后端 Rust, API Python)&lt;/li&gt;
&lt;li&gt;HuggingFace Transformers&lt;/li&gt;
&lt;li&gt;OpenAI GPU Triton Lang&lt;/li&gt;
&lt;li&gt;Langchain, Langgraph, vLLM, SGLang, TRTLLM&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等等，不胜枚举……&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着越来越多的公司使用人工智能进行构建，寻找在驱动人工智能的技术（包括精通 Python）方面经验丰富的开发人员，就变得理所当然了。这是来自 2024 年 StackOverflow 开发者调查的另一张图表，再次印证了上述观点。&lt;/p&gt;</description></item><item><title>编码作为手艺——回归旧式健身房</title><link>https://linguista.cn/rosetta/technology/coding-as-craft-going-back-to-the-old-gym/</link><pubDate>Tue, 22 Apr 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/coding-as-craft-going-back-to-the-old-gym/</guid><description>&lt;h1 id="编码作为手艺回归旧式健身房"&gt;编码作为手艺——回归旧式健身房&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以洛奇·巴尔博亚的旧式健身房为隐喻，探讨在AI日益渗透编程工作的时代，开发者应如何保持对编码手艺的掌控。作者主张AI适合处理样板代码和文档总结等机械性工作，但编程的核心思考、架构设计和认知挣扎不应被外包，因为正是这些挣扎塑造了工程师的成长与能力。文章倡导有意识地与AI协作，而非不假思索地依赖AI。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;认知挣扎（Cognitive Struggle）——指开发者在面对难题时经历的卡顿、思考和突破过程，这一过程能形成深层记忆和技能成长，是不可被AI替代的学习路径&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动自觉使用与有意识协作（Reflexive vs. Intentional）——前者指不假思索地依赖AI完成一切，后者强调在明确场景下有选择地使用AI，并对其输出保持批判性审视&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;旧式健身房（Old Gym）——借用电影洛奇的隐喻，代表开发者直接与问题搏斗、不依赖AI缓冲的原始训练环境，象征回归手艺磨炼的本源&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码手艺（Coding as Craft）——将编程视为一门需要持续打磨的手艺而非纯粹的产出活动，强调过程中的思考、设计与学习同样重要&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI使用界限（AI Usage Boundaries）——为AI辅助设定明确边界，将其限定于样板代码生成和文档查阅等辅助性任务，核心算法和架构决策则保留由人完成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文章来源： &lt;a href="https://cekrem.github.io/posts/coding-as-craft-going-back-to-the-old-gym/"&gt;Coding as Craft: Going Back to the Old Gym&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2025年4月22日&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;近期，Shopify的CEO Tobi Lütke分享了他对AI在编码中作用的看法，指出“主动自觉地使用AI现已成为Shopify的基本要求”。他信息的核心要点是，AI正在彻底改变我们的工作方式，每个人都应该搭上这班列车，否则就有被甩下的风险。我稍微转述了一下，但大致如此——请查看原文以了解完整的背景和内容。&lt;/p&gt;
&lt;p&gt;这触动了我，但并非他所期望的那种方式。在与Elm工程师同行的Slack对话中，我发现自己输入了以下内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间点很有趣。我刚切换回vim，就是为了进一步远离AI对我编码的干扰。我上次关于AI的演讲副标题是“自动化无聊的部分”（灵感来自那本经典的Python书籍），对我来说，AI就是干这个的。&lt;/p&gt;
&lt;p&gt;然而，编码并非无聊的部分，它是我的手艺，我想享受它并保持敏锐。当然，如果你手头只有LLM（大语言模型），用它来提问和讨论话题是可以的。但“主动自觉地使用AI”听起来像是我不希望出现在我名下的诊断结果。&lt;/p&gt;
&lt;p&gt;如果人们不再经历那种偶尔的僵局——咬紧牙关、审视问题、哭泣、散步、祈祷和呐喊，直到豁然开朗（并且你学到了东西！），我会称之为严重的倒退，而非进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我对这次交流以及前辈们的其他评论反思得越多，就越意识到它关联到一些更深层次的东西，关乎我们与技术和手艺的关系。是时候谈谈回归旧式健身房了。&lt;/p&gt;
&lt;h2 id="洛奇巴尔博亚原则-the-rocky-balboa-principle"&gt;洛奇·巴尔博亚原则 (The Rocky Balboa Principle)&lt;/h2&gt;
&lt;p&gt;在电影《洛奇3》中，有一个关键时刻，米奇（Mickey）质问洛奇（Rocky）是如何失去锐气的：“你过去像超人一样，但最糟糕的事情发生在了一个拳手身上：你变得文明（安逸）了！”&lt;/p&gt;
&lt;p&gt;米奇的解决方案？“我们离开这儿，回那个旧健身房去！”&lt;/p&gt;
&lt;p&gt;这一幕一直留在我心中，因为它捕捉到了关于精通技艺和技能发展的一些深刻道理。“旧健身房”代表了真实成长发生的原始、必要条件。它不舒适，不豪华，但真正的锤炼在那里完成。&lt;/p&gt;
&lt;p&gt;在编码的语境下，我们的“旧式健身房”是我们直接与问题、算法和架构搏斗，而没有AI为我们生成解决方案这个缓冲垫的心智空间。&lt;/p&gt;
&lt;h2 id="ai作为工具而非替代品"&gt;AI作为工具，而非替代品&lt;/h2&gt;
&lt;p&gt;首先明确一点：我并非反对AI。事实上，我发现它极其有用——用于处理那些无聊的部分。&lt;/p&gt;
&lt;p&gt;AI擅长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成样板代码&lt;/li&gt;
&lt;li&gt;总结文档&lt;/li&gt;
&lt;li&gt;解释复杂概念&lt;/li&gt;
&lt;li&gt;帮助调试棘手的错误信息&lt;/li&gt;
&lt;li&gt;起草单元测试&lt;/li&gt;
&lt;li&gt;格式化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是编程的核心——思考、设计、架构决策——这些是我希望作为我的手艺加以珍视的部分。这些是我希望通过在旧式健身房训练来保持强壮的肌肉。&lt;/p&gt;
&lt;h2 id="认知挣扎的价值-the-value-of-cognitive-struggle"&gt;认知挣扎的价值 (The Value of Cognitive Struggle)&lt;/h2&gt;
&lt;p&gt;与难题搏斗的过程有其不可替代的价值。当你卡住时，完全卡住时，你可能会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沮丧地咬紧牙关&lt;/li&gt;
&lt;li&gt;离开电脑&lt;/li&gt;
&lt;li&gt;去散步&lt;/li&gt;
&lt;li&gt;向上帝祈祷和/或痛哭一场&lt;/li&gt;
&lt;li&gt;回来再尝试不同方法&lt;/li&gt;
&lt;li&gt;重复直至……突然间，豁然开朗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那个“啊哈！”的时刻会重塑你的大脑。它创建了神经通路，让你永久性地在你所做的事情上变得更强。这就是编码界的肌肉记忆，也是我们作为工程师成长的方式。&lt;/p&gt;
&lt;p&gt;当我们将这种挣扎外包给AI时，我们就剥夺了我们自身的这些成长机会。我们得到了解决方案却不理解其所以然。我们得到了代码却没有手艺的沉淀。&lt;/p&gt;
&lt;p&gt;AI可以生成代码，但它（目前）还不能理解那些使系统随着时间推移真正可维护和适应性强的细致入微的决策。它不会像拥有深厚经验和来之不易知识的人那样，用心和考量去设计你的领域层（domain layer）。并且重申：它是否在特定任务上成功不应是你唯一关心的，如果你在乎你的手艺——你是否学到了东西也应该重要！&lt;/p&gt;</description></item><item><title>软件工程师的疯狂挑战</title><link>https://linguista.cn/rosetta/technology/the-insanity-of-being-a-software-engineer/</link><pubDate>Sun, 06 Apr 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/the-insanity-of-being-a-software-engineer/</guid><description>&lt;h1 id="软件工程师的疯狂挑战"&gt;软件工程师的疯狂挑战&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以略带讽刺的口吻揭示了现代软件工程师面临的荒诞处境。从掌握多种编程语言、框架到被迫成为全栈工程师，再到学习Docker、AWS和Terraform等运维技能，工程师的职责不断膨胀。作者感叹软件行业缺乏专业分工，一个人被期望承担从前端到后端、从开发到运维甚至管理的所有角色，并以建筑行业的分工模式作为对比进行反思。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;全栈工程师&lt;/strong&gt;：指同时负责前端和后端开发的工程师，文中暗示这一角色的出现源于公司削减人力成本的决策&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DevOps&lt;/strong&gt;：开发与运维融合的实践模式，原本由系统管理员承担的基础设施工作被转嫁给开发工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术栈膨胀&lt;/strong&gt;：现代软件开发要求工程师掌握的工具和框架不断增加，从React、TypeScript到Docker、Terraform层层叠加&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专业分工缺失&lt;/strong&gt;：作者以建筑行业多工种协作为类比，批评软件行业期望单一工程师承担过多职责的不合理现象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术复杂性&lt;/strong&gt;：软件系统日趋复杂，每一层新技术的引入都有其合理性，但累积效应对个体工程师造成了巨大负担&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成为软件工程师的疯狂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://0x1.pt/2025/04/06/the-insanity-of-being-a-software-engineer/"&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;06/04/2025&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我经常思考的事情，因为我忍不住会想其他大多数工作是否也是这样。&lt;/p&gt;
&lt;p&gt;成为软件工程师很艰难。你一开始就需要掌握几种编程语言和工具。但这还不够。公司还期望你了解他们使用的特定框架。这可能是Rails、Django、Laravel或其他什么东西。你还需要懂CSS。学习CSS需要一辈子——而且你还是不知道布局为什么会崩溃——但知道足够应付的情况是可行的。&lt;/p&gt;
&lt;p&gt;你不太可能完全避开JavaScript。也许你很幸运，只需要在你维护的遗留应用程序中偶尔撒点jQuery。但事情总是在变化。&lt;/p&gt;
&lt;p&gt;在某个时候，Facebook的人开发了React。结果证明，那家拥有数万工程师的公司一直以来有两个专长：前端和后端。编程界的集体意识决定React现在是构建软件的正确方式，但与此同时，公司们决定他们雇不起更多工程师。瞧啊，全栈工程师就此诞生，而你就是那个全栈工程师。开始学习React，并在此基础上构建REST API，你已经知道后端技术了。&lt;/p&gt;
&lt;p&gt;这还不会结束。你知道你需要类型系统，对吧？加进TypeScript。你真的要在React中像个新手一样管理状态吗？加进Redux。你觉得自己很聪明，因为你避开了这两者？那就好好享受配置webpack/esbuild/rollup，再加上Prettier和ESLint的乐趣吧。&lt;/p&gt;
&lt;p&gt;“你说，‘好吧，但我可以继续按照我一直以来的方式做事。以前这样很好用，我不需要React。’”当然可以。你完全可以偏离你所在快速移动、烧钱起飞的创业公司里所有人都在做的方式。告诉你的老板，你愿意教新员工——那些只听说过React的新人——关于服务器端渲染的乐趣。&lt;/p&gt;
&lt;p&gt;哦，我们才刚刚开始。&lt;/p&gt;
&lt;p&gt;在恐龙还漫游地球的时候，有一种职业叫做系统管理员。他们的全部工作就是确保你的后端运行良好。他们处理基础设施变更、数据库升级、系统升级、保持守护进程运行、重启，一切都由他们搞定。然后来了DevOps。某个缺钱的公司在某处决定，现在所有这些都由工程师来处理，大家都同意了。现在你需要学习Docker。哦，你的整个应用只是一个静态链接的单一二进制文件，你不需要Docker？那就学学Ansible吧，我希望你能乐在其中，搞清楚需要传递给SystemD的选项。&lt;/p&gt;
&lt;p&gt;你甚至还没走到一半。现在你得学AWS。你不会像个农民一样用GUI来配置你的基础设施，所以你最好学学Terraform或Pulumi或其他什么。&lt;/p&gt;
&lt;p&gt;你干得很好。你被提拔为经理。你需要学习另一份完全不同的工作。但没关系，因为这是终极目标。幸福。从现在开始，你需要做的一些事情包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;估算截止日期&lt;/li&gt;
&lt;li&gt;给队友分配任务&lt;/li&gt;
&lt;li&gt;编写任务规格&lt;/li&gt;
&lt;li&gt;参与年度审查&lt;/li&gt;
&lt;li&gt;在产品会议上提供有价值的反馈&lt;br&gt;
你最好希望到这个时候你公司的人数已经翻了四倍，否则你将同时做管理层工作和所有上述工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事情总是可以变得更糟。几天前，一个招聘者联系我，关于一个秘密公司的工程职位。他们决定需要高级水平的Rails、Hotwire技能，还有令人难以置信的原生移动开发技能。为什么不再加上内核和编译器开发呢，干脆一起加进来吧？&lt;/p&gt;
&lt;p&gt;软件变得越来越复杂。所有这些复杂性都有其原因。但特化去哪了？当一座房子在建造时，涉及很多人：建筑师、土木工程师、管道工、电工、砖瓦工、室内设计师、屋顶工、测量员、铺路工，你能想到的都有。你不会期望一个人，甚至一个整家公司，能做所有这些事。&lt;/p&gt;
&lt;p&gt;也许一个未来，我们可以用几个提示就构建整个应用并不那么坏。&lt;/p&gt;</description></item><item><title>超越70%：最大化AI辅助编码中人类贡献的30%</title><link>https://linguista.cn/rosetta/technology/beyond-70-maximizing-human-30-in-ai-assisted-coding/</link><pubDate>Fri, 14 Mar 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/beyond-70-maximizing-human-30-in-ai-assisted-coding/</guid><description>&lt;h1 id="超越70最大化ai辅助编码中人类贡献的30"&gt;超越70%：最大化AI辅助编码中人类贡献的30%&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了AI编码助手能够完成约70%的常规编码工作，但剩余30%的关键部分仍依赖人类技能。文章深入分析了AI在处理边缘情况、系统架构和代码正确性方面的局限，并为高级和初级开发者提供了在AI时代应重点培养的持久工程技能的实用指南。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;70%问题&lt;/strong&gt;：AI编码工具可完成约七成常规开发任务，但最后三成涉及边缘情况、架构优化和可维护性的关键工作仍需人类专业判断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偶然复杂性与本质复杂性&lt;/strong&gt;：源自Fred Brooks的经典概念，AI擅长处理重复性机械性的偶然复杂性，而理解问题固有难度的本质复杂性仍需人类思维&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统设计与架构思维&lt;/strong&gt;：涵盖组件交互、数据流动、可扩展性和安全性等全局考量，是AI无法自动替代的核心工程能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后一公里差距&lt;/strong&gt;：AI生成的方案看似可行，但在边缘覆盖、性能优化和长期可维护性上往往存在缺陷，需要经验丰富的工程师介入完善&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;力量倍增器&lt;/strong&gt;：AI作为开发者的生产力放大工具而非替代品，人类判断力和良好的软件工程实践在AI时代依然不可或缺&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href="https://addyo.substack.com/p/beyond-the-70-maximizing-the-human"&gt;Beyond the 70%: Maximizing the human 30% of AI-assisted coding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href="https://substack.com/@addyosmani"&gt;Addy Osmani&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日期：Mar 14, 2025&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="为何在ai辅助编码时代持久的人类技能至关重要"&gt;为何在AI辅助编码时代，持久的人类技能至关重要&lt;/h3&gt;
&lt;p&gt;本文是我之前文章“&lt;a href="https://addyo.substack.com/p/the-70-problem-hard-truths-about"&gt;70%问题：关于AI辅助编码的残酷真相&lt;/a&gt;”的续篇&lt;/p&gt;
&lt;p&gt;像Cursor、Cline、Copilot和WindSurf这样的AI编码助手已经改变了软件的构建方式，承担了大量的繁重工作和样板代码。然而，正如经验丰富的开发者和行业领袖所指出的那样，软件工程中仍有&lt;a href="https://addyo.substack.com/p/the-70-problem-hard-truths-about"&gt;一部分关键工作&lt;/a&gt;，AI&lt;strong&gt;并不能&lt;/strong&gt;很好地处理——大约是最后那“30%”，它区分了玩具方案和生产就绪系统。这个差距包含了困难的部分：理解复杂需求、构建可维护的系统、处理边缘情况以及确保代码正确性。换句话说，虽然AI可以生成代码，但它常常在工程方面遇到困难。&lt;/p&gt;
&lt;p&gt;Tim O’Reilly在反思数十年的技术变革时&lt;a href="https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/"&gt;提醒我们&lt;/a&gt;，每一次自动化的飞跃都改变了我们编程的方式，但并未改变我们为何需要熟练程序员的原因。我们面对的不是&lt;strong&gt;编程的终结&lt;/strong&gt;，而是“我们所知的编程方式的终结”，这意味着开发者的角色正在演变，而非消失。&lt;/p&gt;
&lt;p&gt;当今工程师面临的挑战是，拥抱AI的长处（最初的70%），同时加倍投入于完成剩余30%所需的持久技能和洞见。本文深入探讨专家见解，以识别哪些人类技能仍然至关重要。我们将探讨高级开发者应继续利用什么，以及初级开发者必须投入什么才能与AI并存发展。&lt;/p&gt;
&lt;p&gt;目标是：为最大化那不可替代的30%的价值提供&lt;strong&gt;实用指南&lt;/strong&gt;，并为各个级别的工程师提供可操作的建议。&lt;/p&gt;
&lt;h2 id="70问题ai擅长什么以及它在哪里挣扎"&gt;70%问题：AI擅长什么（以及它在哪里挣扎）&lt;/h2&gt;
&lt;p&gt;基于AI的编码工具在某些任务上表现惊人。它们擅长生成样板代码、编写常规函数，并将项目推进到接近完成的状态。事实上，许多开发者发现AI助手可以实现一个覆盖大约70%需求的初始解决方案。&lt;/p&gt;
&lt;p&gt;这通常是工作中直接、模式化的部分——那种遵循成熟路径或常见框架的代码。正如一位Hacker News评论者所观察到的，AI非常擅长处理软件的**“偶然复杂性”&lt;strong&gt;（重复、机械性的东西），而&lt;/strong&gt;“本质复杂性”**——理解和管理问题固有的复杂性——仍然落在&lt;a href="https://news.ycombinator.com/item?id=42336553#:~:text=Even%20though%20Fred%20Brooks%20explained,help%20with%20the%20accidental%20tasks"&gt;人类肩上&lt;/a&gt;。用Fred Brooks的经典术语来说，AI解决了开发的偶然困难，而非内在困难。&lt;/p&gt;
&lt;p&gt;这些工具在哪里遇到困难？经验丰富的工程师一致报告存在“最后一公里”的差距。AI可以生成一个看似合理的解决方案，但&lt;strong&gt;最后的30%&lt;/strong&gt;——覆盖边缘情况、优化架构、确保可维护性——“需要严肃的人类专业知识”。&lt;/p&gt;
&lt;p&gt;例如，AI可能会给你一个在基本场景下技术上可行的函数，但除非明确告知，否则它不会自动考虑异常输入、竞态条件、性能约束或未来需求。AI可以带你走完大部分路程，但最后那关键的30%（边缘情况、保持可维护性以及稳固的架构）需要严肃的人类专业知识。&lt;/p&gt;
&lt;p&gt;此外，AI有一个已知的倾向，即生成&lt;strong&gt;看似可信但错误&lt;/strong&gt;的输出。它可能会引入微妙的错误或“幻觉”出不存在的函数和库。Steve Yegge诙谐地将当今的大型语言模型（LLMs）比作“效率极高但可能精神错乱的初级开发者”——速度惊人且充满热情，但“可能磕了致幻药”，容易编造出疯狂或根本行不通的方法。&lt;/p&gt;
&lt;p&gt;用Yegge的&lt;a href="https://itrevolution.com/articles/observing-the-impact-of-ai-on-law-firms-software-and-writing-winners-and-losers/#:~:text=When%20I%20was%20talking%20with,crazy%20and%20fundamentally%20unworkable%20approaches"&gt;话&lt;/a&gt;来说，LLM可以喷涌出初看之下很完善的代码，然而如果一个经验不足的开发者天真地说“看起来不错！”并付诸实施，接下来的几周内&lt;strong&gt;就会引（酿）发（成）笑（灾）料（难）&lt;/strong&gt;。AI并不真正理解问题；它只是将通常有意义的模式拼接在一起。只有人类才能辨别一个看似不错的解决方案是否隐藏着长期的隐患。Simon Willison在看到AI提出了一个极其巧妙的设计，但只有对问题有深刻理解的高级工程师才能识别其缺陷后，&lt;a href="https://simonwillison.net/2024/Jul/12/the-death-of-the-junior-developer/#:~:text=Also%20included%3A%20a%20story%20about,the%20problem%20space%20could%20catch"&gt;对此表示赞同&lt;/a&gt;。教训是：AI的自信远超其可靠性。&lt;/p&gt;
&lt;p&gt;至关重要的是，当前的AI&lt;a href="https://news.ycombinator.com/item?id=42954885#:~:text=Currently%2C%20LLM%20AIs%20are%20stochastic,form%20that%20can%20be%20reused"&gt;无法&lt;/a&gt;创建超越其训练数据的根本性新&lt;strong&gt;抽象或策略&lt;/strong&gt;。它们不会为你发明新颖的算法或创新的架构——它们只是重新混合已知的东西。它们也不会为决策负责。正如一位工程师指出的，“AI的想法不会比其训练数据包含的更好。它们不对自己的工作负责。”&lt;/p&gt;
&lt;p&gt;所有这一切意味着创造性和分析性思维——决定构建什么、如何构建以及为何构建——仍然牢牢掌握在人类手中。总而言之，AI是开发者的&lt;strong&gt;力量倍增器&lt;/strong&gt;，处理重复性的70%工作，并在生产力上给我们带来“涡轮增压”​​。但它 不是可以替代人类判断的银弹。软件工程剩余的30%——困难的部分——仍然需要只有训练有素、思维缜密的开发者才能带来的技能。这些是需要关注的&lt;strong&gt;持久技能&lt;/strong&gt;。正如一次&lt;a href="https://www.reddit.com/r/ChatGPTCoding/comments/1hx6cks/thisarticlestruckmeaslargelyaccuratethe70/#:~:text=In%20short%3A%20AI%20is%20a,engineering%20practices%20are%20still%20essential"&gt;讨论&lt;/a&gt;所言：“AI是一个强大的工具，但它不是万能药……人类的判断力和良好的软件工程实践仍然至关重要。”&lt;/p&gt;
&lt;h2 id="依然重要的持久工程技能"&gt;依然重要的持久工程技能&lt;/h2&gt;
&lt;p&gt;要在AI增强的开发世界中茁壮成长，工程师应加倍投入那些AI尚无法（目前）复制的持久技能和实践。无论我们的工具变得多么先进，这些能力都将保持关键。尤其要着重加强以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统设计与架构思维：&lt;/strong&gt; 设计一个连贯的系统需要理解权衡、约束以及超越编写几个函数的“大局观”。AI可以生成代码，但不会自动为复杂问题选择最佳架构。&lt;strong&gt;整体设计&lt;/strong&gt;——组件如何交互、数据如何流动、如何确保可扩展性和安全性——是那需要人类洞察力的30%的一部分。高级开发者长期以来一直在磨练这项技能，初级开发者应积极培养。从模式和原则（例如，关注点分离、模块化）的角度思考——这些能引导AI生成的解决方案走向可维护性。记住，稳固的架构不会凭空出现；它需要经验丰富的人类掌控方向盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理边缘情况与模糊性：&lt;/strong&gt; 现实世界的软件充满了奇怪的场景和不断变化的需求。AI默认倾向于解决普遍情况。开发者需要不断追问“如果……会怎样？”并探查弱点。这里的持久技能是&lt;strong&gt;批判性思维和预见性&lt;/strong&gt;——列举边缘情况、预测故障，并在代码或设计中解决它们。这可能意味着考虑空输入、网络中断、异常用户操作或与其他系统的集成。&lt;strong&gt;领域知识&lt;/strong&gt;也起着作用：了解业务背景或用户环境将揭示通用AI根本不知道的边缘情况。经验丰富的工程师习惯性地考虑这些场景；初级开发者应练习系统地测试边界和质疑假设。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码审查与质量保证：&lt;/strong&gt; 随着AI编写大量代码，严格审查和测试这些代码的能力变得更加关键。“每个人都需要更加认真地对待测试和代码审查，” Steve Yegge强调说。像对待人类初级开发者的输出一样对待AI生成的代码——你是代码审查员，负责发现错误、安全漏洞或草率的实现。这意味着在&lt;strong&gt;单元测试、集成测试和调试&lt;/strong&gt;方面拥有扎实的技能。编写好的测试是一项持久的技能，它迫使你理解规范并验证正确性。明智的做法是，在被证明之前，假设一切都无效。正如一位开发者&lt;a href="https://www.reddit.com/r/ChatGPTCoding/comments/1h6qyl0/whyaiismakingsoftwaredevskillsmore/#:~:text=AI%20made%20me%20a%20better,functional%20but%20horribly%20optimized%20code"&gt;指出&lt;/a&gt;，AI通常产生“功能正常但优化极差的代码”，直到你通过迭代改进来引导它。培养测试心态：验证每个关键逻辑路径，使用静态分析或linter，如果AI给出的代码不符合你的质量标准，不要回避重写。&lt;strong&gt;质量保证&lt;/strong&gt;不是可以外包给AI的领域——这是人类勤勉闪耀的地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调试与问题解决能力：&lt;/strong&gt; 当软件未按预期工作时，你需要真正的问题解决能力来诊断和修复它。AI可以辅助调试（例如，建议可能的原因），但它缺乏对你应用程序运行的具体上下文的真正理解。能够理清复杂错误——重现它、隔离原因、理解底层系统（操作系统、数据库、库）——是一项永恒的工程技能。这通常需要对基础知识（内存和状态如何工作、并发等）有扎实的掌握，初级开发者必须通过实践来学习。将AI用作助手（它可能会解释错误消息或建议修复方法），但不要盲目依赖它。在调试时&lt;strong&gt;有条不紊地排查问题&lt;/strong&gt;并应用第一性原理的能力，使优秀的开发者脱颖而出。这也是一个反馈循环：调试AI编写的代码将教会你下次如何更好地提示AI或避免某些模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保持上下文与全局理解：&lt;/strong&gt; 软件项目不仅仅是孤立的编码任务；它们存在于用户需求、时间表、遗留代码和团队流程的更大背景中。AI对你的项目历史或某些决策背后的理由没有天生的感知（除非你明确地将所有这些信息输入提示，这通常不切实际）。人类需要承载这些上下文。这里的持久技能是&lt;strong&gt;系统思维&lt;/strong&gt;——理解系统中一部分的变化可能如何影响另一部分，软件如何服务于业务目标，以及所有活动部件如何连接。这种整体视角让你能够恰当地使用AI的输出。例如，如果AI建议了一个巧妙的捷径，但它与法规要求或公司惯例相悖，你会因为了解上下文而发现它。初级工程师应该主动了解他们项目的背景并阅读设计文档，这样他们就能培养出判断什么合适、什么不合适的判断力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;沟通与协作：&lt;/strong&gt; 构建软件是一项团队运动。AI不会参加会议（谢天谢地）——人类仍然必须与其他人交谈以澄清需求、讨论权衡和协调工作。强大的沟通技巧一如既往地宝贵。高级开发者应利用他们解释复杂想法、指导他人和阐明愿景的能力。初级开发者应练习提出好问题并清晰地描述问题（对同事和对AI都是如此）。有趣的是，提示AI本身就是一种沟通形式；它要求你精确地表达你想要什么。这与核心工程技能重叠：&lt;strong&gt;需求分析&lt;/strong&gt;。如果你能制定一个清晰的提示或规范，这意味着你已经彻底思考过问题。此外，分享知识、编写文档和审查他人代码是AI无法取代的协作技能。未来，随着开发者“与”AI合作，团队中的人际协作——确保解决正确的问题——仍然至关重要。一个新兴趋势是，开发者可能更专注于&lt;strong&gt;高层设计讨论&lt;/strong&gt;（通常有AI作为参与者）和协调任务，本质上承担更多指挥者的角色。沟通和领导技能将使你在那个指挥者的位置上受益匪浅。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适应性与持续学习：&lt;/strong&gt; 最后，一个元技能：学习新工具和适应变化的能力。AI辅助开发领域正在迅速发展。保持开放心态并学习如何有效使用新AI功能的高级工程师将保持领先——Tim O’Reilly建议，那些“渴望学习新技能”的开发者将从AI中获得最大的生产力提升。反过来，初级开发者应该投入&lt;strong&gt;深入学习基础知识&lt;/strong&gt;，&lt;strong&gt;并&lt;/strong&gt;对新技术保持好奇心。这种结合使你能够驾驭AI作为工具，而不会对其产生依赖。这是一个平衡行为：利用AI加速你的成长，但也要偶尔在没有它的情况下练习，以确保你没有跳过核心学习（一些开发者会定期进行“&lt;a href="https://www.reddit.com/r/ChatGPTCoding/comments/1hzr495/whatareyoudoingtopreventskillatrophy/#:~:text=What%20are%20you%20doing%20to,keep%20your%20basic%20skills"&gt;AI戒断&lt;/a&gt;”，以保持他们原始的编码技能敏锐）。简而言之，成为一个不断学习的工程师——这是任何时代都能保障职业生涯的技能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些技能构成了软件工程中的人类优势。它们之所以&lt;strong&gt;持久&lt;/strong&gt;，是因为它们不会随着下一个框架或工具的变化而过期；相反，AI的崛起使它们更加突出。Simon Willison认为，AI辅助实际上使强大的编程技能更有价值，而不是更没价值，因为拥有专业知识的人可以更有效地利用这些工具。&lt;/p&gt;
&lt;p&gt;强大的机器在不熟练的人手中可能是危险的或被浪费的，但在有能力的人手中则是变革性的。在AI时代，经验丰富的工程师就像一位拥有新的先进副驾驶的经验丰富的飞行员：旅程可以更快更远，但飞行员仍然必须驾驶穿越风暴并确保安全着陆。&lt;/p&gt;
&lt;h2 id="高级开发者的优势结合经验利用ai"&gt;高级开发者的优势：结合经验利用AI&lt;/h2&gt;
&lt;p&gt;对于高级工程师来说，AI编码工具的出现应被视为放大你影响力的机会——前提是你以正确的方式利用你的经验。高级开发者通常拥有深厚的领域知识、对可能出错之处的直觉，以及做出高层技术决策的能力。&lt;/p&gt;</description></item><item><title>软件工程师职位数量跌至五年新低</title><link>https://linguista.cn/curated/henrinotes-2025_p2/software-engineering-jobs-five-year-low/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025_p2/software-engineering-jobs-five-year-low/</guid><description>&lt;h1 id="软件工程师职位数量跌至五年新低"&gt;软件工程师职位数量跌至五年新低&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于Indeed网站的数据分析，揭示了软件工程师职位数量已跌至五年新低的现状。数据显示，当前职位数量较2022年中期峰值下降65%，与2020年疫情中期水平相当。作者从利率变化、行业反应、AI工具影响等多维度分析原因，并对软件开发行业的未来发展趋势提出见解。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先通过详实的数据展示了软件开发职位市场的严峻现状。Indeed的数据显示，自2020年1月以来，软件开发职位数量下降至65%，相比2022年中期峰值减少了3.5倍。国际市场对比表明，美国和加拿大呈现相似的下降趋势，而澳大利亚是唯一一个职位数量未低于2020年水平的国家。更值得注意的是，与整体职位市场相比，软件开发职位的下降幅度远超其他行业。&lt;/p&gt;
&lt;p&gt;在原因分析部分，作者提出了三个核心因素。利率上升导致风险投资环境恶化，直接影响科技初创公司的招聘能力；科技行业对经济变化的反应过度剧烈，2022年的招聘高峰后迅速转向收缩；而AI工具的普及可能正在改变传统的开发模式，一些公司采取观望态度，暂停招聘以评估AI对生产力的实际影响。&lt;/p&gt;
&lt;p&gt;关于未来展望，作者既担忧又审慎乐观。小型团队如Linear和Bluesky的高效运作证明了精简团队的可行性，AI工具可能进一步提升开发效率。尽管行业可能出现停滞甚至萎缩，但软件开发在各行各业仍存在巨大商业机会。AI工具的普及甚至可能为开发人员创造新的机会，如优化和维护AI生成的代码。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;职位数量的结构性变化&lt;/strong&gt;：软件开发职位的下降并非周期性波动，而是结构性变化。相比2020年整体职位增长10%，软件开发职位却减少35%，这表明该行业正在经历根本性转型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI工具的替代效应&lt;/strong&gt;：大语言模型在编程领域的应用可能提高开发效率，但同时也可能减少对传统软件工程师的需求。公司暂停招聘以评估AI工具的实际效果，这种观望态度本身就反映了市场的不确定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精简团队的崛起&lt;/strong&gt;：Linear和Bluesky等案例证明，5-10人的小型团队利用AI工具可以完成以往需要更大团队才能完成的工作。这种模式可能成为未来的主流，重塑软件开发的组织形态。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://blog.pragmaticengineer.com/software-engineer-jobs-five-year-low/"&gt;Software engineering job openings hit five-year low&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Gergely Orosz&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件工程师应避免的十个行为</title><link>https://linguista.cn/curated/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</guid><description>&lt;h1 id="软件工程师应避免的十个行为"&gt;软件工程师应避免的十个行为&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;作者 Hoon Wee 基于五年以上的软件工程经验，分享了十个开发者应当避免的行为模式。这些经验涵盖了对代码质量的理解、开发流程的把控、职业心态的调整等多个维度，旨在帮助软件工程师摆脱常见误区，成长为更成熟的问题解决者。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以资深工程师的视角展开论述，首先指出了完美主义的陷阱——完美的代码并不存在，软件开发本质上是迭代的过程，专业能力体现在&amp;quot;足够好&amp;quot;而非&amp;quot;完美&amp;quot;。作者进一步强调重构应当融入日常开发流程，而非作为事后的额外请求，这体现了对工程质量的持续关注。&lt;/p&gt;
&lt;p&gt;在技术实践层面，作者重新定义了&amp;quot;遗留代码&amp;quot;的概念——它并非指旧代码，而是指缺乏测试的代码。这一观点揭示了可测试性与可维护性之间的本质联系。同时，作者警示不要盲目推崇函数式编程或遵循所谓的&amp;quot;最佳实践&amp;quot;，编程范式的选择应当基于具体场景和上下文判断，而非教条式套用。&lt;/p&gt;
&lt;p&gt;文章后半部分转向开发者工作方式和职业心态的探讨。作者反对独自挣扎解决问题，倡导利用团队智慧和现有方案；提醒在追求&amp;quot;心流&amp;quot;状态时保持自我觉察，建议采用番茄工作法避免倦怠。最后，作者强调了身体健康的重要性，并鼓励开发者保持对编程本身的热爱，从&amp;quot;码农&amp;quot;升级为用代码解决问题的&amp;quot;软件工程师&amp;quot;，以应对未来 AI 对简单编码工作的潜在替代。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;遗留代码的本质&lt;/strong&gt;：传统观点认为遗留代码等同于陈旧代码，但作者指出真正的定义是&amp;quot;没有测试的代码&amp;quot;。缺乏测试的代码无法安全重构，也无法维护；相反，即使技术栈较老（如 Next.js v10），只要测试覆盖良好，代码仍然具备可维护性。这一观点重新定义了代码质量的评判标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文驱动的技术选择&lt;/strong&gt;：函数式编程、清洁架构、SOLID 原则、TDD 等都是有力的工具，但没有放之四海而皆准的&amp;quot;最佳实践&amp;quot;。在 Clojure 或 Python 等语言中，TDD 可能并非必要；在 Flutter UI 层中，过度函数式化可能损害性能。成熟工程师的标志在于根据具体情境做出合理判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从编码者到问题解决者&lt;/strong&gt;：AI 时代正在重新定义软件开发者的价值。单纯写代码的能力（&amp;ldquo;码农&amp;rdquo;）面临被替代的风险，而运用代码解决实际问题的能力（&amp;ldquo;软件工程师&amp;rdquo;）将更加稀缺。这一转变要求开发者超越技术本身，关注业务价值和问题本质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://favtutor.com/articles/donts-for-software-engineer/"&gt;Things You Should Never Do As A Software Engineer&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Hoon Wee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>那些听起来不错但几乎行不通的系统设计想法</title><link>https://linguista.cn/curated/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</guid><description>&lt;h1 id="那些听起来不错但几乎行不通的系统设计想法"&gt;那些听起来不错但几乎行不通的系统设计想法&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程中常见的八种&amp;quot;听起来不错但几乎行不通&amp;quot;的系统设计想法，包括可插拔架构、API设计、过度抽象、异步编程、访问控制、数据同步、跨平台设计和原生逃逸机制。作者基于丰富的工程经验指出，这些想法在实际操作中往往引入不必要的复杂性和风险，建议开发者基于第一性原理解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇点明了写作背景：在软件工程实践中，许多看似简单可行的系统设计想法，在实际操作中却往往以失败告终。作者强调，工程不仅是技术问题，更涉及社会学因素，许多失败的教训源于经验不足。&lt;/p&gt;
&lt;p&gt;文章主体部分详细列举并分析了八种常见的设计陷阱。每种想法都看似合理——比如&amp;quot;让它可插拔&amp;quot;以便后续替换实现、&amp;ldquo;添加一个API&amp;quot;将产品扩展为平台、&amp;ldquo;再抽象一次&amp;quot;来解决复杂性问题。然而，作者通过具体案例指出，可插拔性需要同时开发两种实现才能保证API行为的完整性，API的维护成本往往被低估，过早的抽象会导致代码冗余。&lt;/p&gt;
&lt;p&gt;进一步的分析揭示了异步编程在框架之外可能引发难以复现的错误，访问控制如果稍后添加往往需要重写整个系统，数据同步在语义化和事务性场景中极其复杂，跨平台设计最终需要构建类似操作系统的抽象层，而原生逃逸机制会破坏框架内部状态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可插拔架构的陷阱&lt;/strong&gt;：真正的可插拔性要求在设计初期就同时开发多种实现，因为API的行为不仅包括文档定义，还包括实际运行中的各种边界情况和副作用。如果只设计一种实现，后续替换几乎无法无缝进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API的平台化误区&lt;/strong&gt;：许多产品成功后试图通过API扩展为平台，但API需要在兼容性和功能之间不断权衡，维护成本巨大。同时，开发者往往高估了第三方对API的需求，实际使用率通常远低于预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过度抽象的代价&lt;/strong&gt;：虽然&amp;quot;所有问题都可以通过增加一层间接性来解决&amp;rdquo;，但过早引入的抽象往往永远不会被真正使用，反而增加了代码冗余和维护负担。Windows NT中就有大量这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程的双刃剑&lt;/strong&gt;：异步编程在理论上的效率优势在实践中可能被难以复现的错误和数据损坏问题所抵消，特别是在框架之外的场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性的不可后置性&lt;/strong&gt;：访问控制和安全性必须在设计初期就考虑，后续添加往往面临重写整个系统的挑战。安全不是可以&amp;quot;稍后添加&amp;quot;的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据同步的复杂性&lt;/strong&gt;：即使在理想化的语义化和事务性数据存储中，同步也充满挑战，更不用说涉及非结构化数据或数据转换的场景。这是分布式系统中最难的问题之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨平台的抽象陷阱&lt;/strong&gt;：跨平台设计看似简单，但随着功能复杂化，往往需要构建类似操作系统的抽象层，这个抽象层本身会成为巨大的维护负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生逃逸的隐患&lt;/strong&gt;：框架提供的&amp;quot;逃逸到原生&amp;quot;机制虽然看似提供了灵活性，但往往会破坏框架的内部状态，导致难以维护和调试的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://hardcoresoftware.learningbyshipping.com/p/225-systems-ideas-that-sound-good?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;225. Systems Ideas that Sound Good But Almost Never Work—&amp;ldquo;Let&amp;rsquo;s just…&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Steven Sinofsky&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>长期软件开发的思考与建议</title><link>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</guid><description>&lt;h1 id="长期软件开发的思考与建议"&gt;长期软件开发的思考与建议&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者为荷兰选举委员会开发开源投票统计软件 Abacus 的实践经验，系统性地总结了长期软件开发的核心理念与方法。作者指出，与现今通过 CI/CD 持续迭代的软件服务不同，核电站、选举系统、心脏起搏器等领域的软件需要在未来数十年内保持稳定运行。文章从 Mastodon 社区收集了大量反馈，提炼出关于依赖管理、复杂性控制、测试策略、文档规范、团队建设等15个方面的实用建议，为需要长期维护的软件项目提供了全面的指导框架。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者受荷兰选举委员会邀请反思其开源投票统计软件为切入点，指出了长期软件开发与现代敏捷开发模式的本质差异。现今大多数软件作为服务提供，可以通过持续部署和持续集成来修复问题，但某些关键领域如核电站控制系统、选举软件、医疗设备等，要求软件在几十年内保持稳定运行，任何变更都需要提前规划和公告。&lt;/p&gt;
&lt;p&gt;作者在 Mastodon 社区征求意见后，收集了大量来自实践者的反馈，将这些经验整理成系统性的建议。文章的核心论点是：长期软件开发需要与传统开发模式完全不同的思维方式和技术选择。作者特别强调了依赖管理的重要性，将软件依赖分为四个层次——基础编程语言、紧密耦合的框架、数据库和可替换的辅助库，并指出越底层的依赖选择越关键。&lt;/p&gt;
&lt;p&gt;在复杂性管理方面，作者提出&amp;quot;复杂性是软件开发的最终敌人&amp;quot;这一核心观点，通过图表展示了代码复杂性与代码量之间的关系，强调必须在早期主动进行重构和简化。文章还详细讨论了测试的价值、文档的重要性、团队管理的策略以及开源的优势，并推荐了《编程实践》《人月神话》《软件设计哲学》等经典著作，最后引用了莱曼的软件进化法则来支持其观点。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;依赖层次结构&lt;/strong&gt;：软件依赖可分为四个层级——基础编程语言（最底层，最难更换）、紧密耦合的框架（深度集成，更换成本高）、数据库（数据存储核心，迁移复杂）和可替换的辅助库（最上层，相对容易替换）。长期软件开发必须格外关注底层依赖的选择，因为技术质量、使用者基数、维护状况、资金来源等因素都会影响依赖的长期稳定性。依赖可能随时间出现版本漂移、被废弃、甚至遭到劫持，因此建立定期健康检查机制至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;：复杂性会随着代码量的增加而自然增长，如果缺乏主动管理，系统最终会变得无法维护。作者强调必须在开发早期就持续进行重构和简化，而不是推迟到&amp;quot;以后&amp;quot;。简单的代码虽然可能不够&amp;quot;聪明&amp;quot;或不够高效，但更容易理解、调试和维护。在长期项目中，为了避免过早优化是万恶之源，应该优先选择编写无趣但简单的代码，而不是追求高性能但复杂的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lindy 效应与技术选择&lt;/strong&gt;：Lindy 效应指出，技术的预期寿命与其当前年龄成正比——一项技术已经存在的时间越长，它可能继续存在的时间也越长。这意味着在长期软件开发中，应该优先选择经过时间考验的技术，而不是被 LinkedIn 或社交媒体炒作的新技术。新技术的风险在于其长期价值尚未得到验证，可能在关键时刻失去支持或出现无法预见的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试的战略价值&lt;/strong&gt;：测试不仅是质量保证手段，更是长期维护的安全网。当依赖频繁变化时，完善的测试套件可以确保系统仍能正常工作；当项目暂停后重新启动时，测试可以帮助新开发者快速理解系统行为；当需要重构或移除依赖时，测试提供了变更的信心。测试的价值在长期项目中会呈指数级增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档与知识传承&lt;/strong&gt;：长期软件开发必须重视特定文档的需求，包括架构设计文档、API 文档、运维手册等。代码注释应该解释&amp;quot;为什么&amp;quot;而不是&amp;quot;做什么&amp;quot;，提交信息应该记录变更的原因。团队还需要建立内部 wiki 或知识库，记录决策过程、架构演进和故障经验。这些文档在原始开发者离开后，成为知识传承的关键载体。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://berthub.eu/articles/posts/on-long-term-software-development/"&gt;On Long Term Software Development&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Bert Hubert&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>开发者必读的计算机科学论文</title><link>https://linguista.cn/curated/henrinotes_2025_p4/essential-computer-science-papers-developers/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/essential-computer-science-papers-developers/</guid><description>&lt;h1 id="开发者必读的计算机科学论文"&gt;开发者必读的计算机科学论文&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;阅读计算机科学论文是提升开发者技术素养的重要途径。本文系统推荐了涵盖系统设计、分布式系统、数据存储、现代基础设施等领域的经典论文，这些论文构成了现代软件工程的理论基础，能够帮助开发者深入理解核心技术概念，培养批判性思维，并把握技术发展趋势。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本文按照不同技术领域分类推荐了16篇经典计算机科学论文。在系统设计与编程基础方面，推荐了Parnas的模块化设计论文、Hoare的程序验证数学基础、Moseley和Marks的复杂性管理理论，以及Hughes的函数式编程重要性论述。这些论文为现代软件架构、微服务设计和API开发奠定了理论基础。&lt;/p&gt;
&lt;p&gt;分布式系统部分重点介绍了Lamport关于时间与事件顺序的开创性工作，这是理解分布式数据库、区块链和云计算的基石。同时还推荐了反驳分布式系统旧观念的论文，以及Google文件系统等现代分布式存储系统的研究成果。&lt;/p&gt;
&lt;p&gt;数据存储与处理类别涵盖了关系型数据库的理论基础、Amazon DynamoDB的设计架构、Google Bigtable分布式存储系统，以及MapReduce编程模型等大数据处理框架的基础性工作。这些论文帮助开发者理解现代数据系统的设计原理和权衡考量。&lt;/p&gt;
&lt;p&gt;现代基础设施部分介绍了Kafka分布式消息系统、Facebook的Memcache扩展实践，以及中本聪的比特币白皮书。最后推荐了关于内存架构的经典论文，帮助开发者理解硬件架构对程序性能的影响。文章还提供了额外的论文资源平台和阅读方法指导。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;模块化设计原则&lt;/strong&gt;：Parnas的论文确立了模块化作为提高系统灵活性、可理解性和减少开发时间的核心机制，其思想直接影响现代软件架构、微服务设计和API开发实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统中的时间与顺序&lt;/strong&gt;：Lamport的论文提出了分布式系统中事件顺序的数学模型，引入了逻辑时钟和不完全排序概念，为分布式数据库一致性、区块链共识机制和云计算协调服务奠定了理论基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关系型数据模型&lt;/strong&gt;：Codd提出的关系模型解决了当时数据库系统的数据独立性和操作一致性问题，成为所有SQL数据库的理论基础，影响至今仍在持续。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程范式&lt;/strong&gt;：Hughes的论文阐述了函数式编程在模块化、组合性和推理性方面的优势，帮助开发者理解其在现代软件开发中的益处，特别是在并发处理和不可变数据结构方面的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存层次结构&lt;/strong&gt;：Drepper的论文详细解释了CPU缓存、内存层次结构及其对程序性能的影响，帮助开发者理解硬件架构与软件性能之间的关系，写出更高效的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://newsletter.techworld-with-milan.com/p/computer-science-papers-every-developer"&gt;Computer Science Papers Every Developer Should Read&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Milan&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-18&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>强工程师与弱工程师的能力差异分析</title><link>https://linguista.cn/curated/henrinotes-2025-p1/strong-vs-weak-engineers-differences/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/strong-vs-weak-engineers-differences/</guid><description>&lt;h1 id="强工程师与弱工程师的能力差异分析"&gt;强工程师与弱工程师的能力差异分析&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程领域中强工程师与弱工程师之间的本质区别。作者指出，强工程师的核心能力在于能够完成其他工程师无法完成的任务，这种能力差异在某些情况下甚至是无限的。文章详细分析了三类工程师的特征，并提供了与弱工程师合作的实用建议。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先明确了强工程师与弱工程师的核心区别在于能力范围的不同。强工程师能够胜任复杂项目的交付、解决跨多个服务的竞态条件等困难bug、对遗留代码库进行有意义的改进，以及进行需要大规模架构重构的变更。这种能力不是线性的差异，而是质的飞跃——有些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。&lt;/p&gt;
&lt;p&gt;普通工程师构成了团队的稳定力量。他们能够解决大部分bug、完成大多数JIRA任务，并在大多数情况下解决开发环境问题。虽然他们可能不追求在下一个晋升周期中表现出色，但他们是团队日常运作的中坚力量。&lt;/p&gt;
&lt;p&gt;弱工程师则面临严重的能力缺失。即使是正常到容易的任务对他们来说也过于困难。在高级职位中，弱工程师通过频繁的单向配对编程来完成任务，依赖其他工程师的帮助。他们还可能在工作讨论中表现得非常活跃，以掩盖其实际工作能力不足。这种现象对团队的影响尤为严重，尤其是对初级工程师的时间和精力占用。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;能力无限差异&lt;/strong&gt;：强工程师与弱工程师之间的差异不是程度上的，而是种类上的。某些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。这种差异在某些情况下是无限的，意味着弱工程师可能永远无法完成某些任务，无论投入多少时间和努力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单向配对编程&lt;/strong&gt;：弱工程师的主要生存策略之一。他们频繁地与其他工程师进行&amp;quot;配对编程&amp;quot;，但实际上这种配对是单向的——其他工程师在为他们完成工作。这种策略掩盖了弱工程师的实际能力不足，但同时也占用了团队中其他工程师的宝贵时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;善意与边界保护&lt;/strong&gt;：文章建议在与弱工程师合作时保持善意，理解他们可能面临的个人困难，但同时也要保护自己的时间和团队的时间。可以通过快速回应而不是提供完整解决方案来避免时间不对称的帮助，并确保管理层了解情况，防止弱工程师利用初级工程师。&lt;/p&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.seangoedecke.com/weak-engineers/"&gt;What can strong engineers do that weak engineers can&amp;rsquo;t?&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Sean Goedecke&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-04&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>数据库模拟的局限性与真实数据库测试的重要性</title><link>https://linguista.cn/curated/henrinotes-2025-p1/database-mocks-vs-real-testing/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/database-mocks-vs-real-testing/</guid><description>&lt;h1 id="数据库模拟的局限性与真实数据库测试的重要性"&gt;数据库模拟的局限性与真实数据库测试的重要性&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;在软件开发过程中，使用数据库模拟进行测试看似快速便捷，但实际上可能掩盖许多潜在问题。本文通过对比分析，阐述了真实数据库测试在发现数据完整性问题、适应架构变化、处理并发场景等方面的显著优势，并提出了分层测试策略，帮助开发团队在测试效率与质量之间取得平衡。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先指出了一个常见现象：许多开发团队在测试中倾向于使用数据库模拟，因为这种方式执行速度快且实现简单。然而，作者通过实际案例对比，揭示了这种做法的风险。当使用模拟的用户仓库进行测试时，虽然能够验证基本的创建逻辑，但却无法暴露数据完整性、约束条件等在生产环境中可能出现的问题。&lt;/p&gt;
&lt;p&gt;文章进一步强调了真实数据库测试在&amp;quot;面向未来&amp;quot;方面的重要性。随着应用程序的演进，数据库架构不可避免地会发生变化，包括新的验证规则、数据类型调整、时间戳精度修改等。这些变化往往会引发意想不到的错误，而模拟数据库根本无法捕捉到这些问题。使用真实数据库进行测试，可以让团队在开发阶段就发现这些隐患，避免在生产环境中浪费宝贵的调试时间。&lt;/p&gt;
&lt;p&gt;在测试策略部分，作者提出了分层测试的理念。应用程序通常包含多个层次，如控制器、服务、仓库等，每一层都有其特定的职责。对于数据访问层和服务层，应该使用真实数据库进行测试，以确保外键约束、引用完整性、事务处理等核心机制的正确性。而对于控制器层，则可以适当地模拟服务调用，专注于测试请求处理和响应编排。这种分层策略既保证了关键逻辑的测试覆盖，又维持了合理的测试执行速度。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据完整性验证&lt;/strong&gt;：模拟数据库无法真实反映生产环境中的约束条件和完整性规则。真实数据库测试能够揭示外键冲突、唯一性约束、级联删除等潜在问题，这些在模拟环境中往往被忽略，但会在生产环境中造成严重后果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构演进的适应性&lt;/strong&gt;：应用程序的数据库架构会随着业务需求的变化而演进。新特性的添加、验证规则的调整、数据类型的修改都可能引入错误。真实数据库测试能够及时捕捉这些由架构变化引起的问题，而模拟数据库则无法反映这些变化，导致测试与实际运行环境脱节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发与事务处理&lt;/strong&gt;：在涉及账户余额、交易总额等业务场景时，并发访问、隔离级别和聚合计算的正确性至关重要。真实数据库测试可以暴露并发竞争条件、死锁、事务隔离等问题，确保业务逻辑的准确性和数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层测试策略&lt;/strong&gt;：应用程序的架构分层为测试策略提供了清晰的指导。数据访问层需要真实数据库来验证SQL执行和数据库交互；服务层需要真实数据库来检验业务逻辑与数据的交互；控制器层则可以通过模拟服务来专注于请求处理和响应编排的测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试效率与质量的平衡&lt;/strong&gt;：真实数据库测试确实会增加测试执行时间，但这种投入在保证应用程序质量方面是值得的。对于复杂的数据关系、性能敏感的场景以及关键业务逻辑，真实数据库测试是不可或缺的。模拟仍然适用于验证高层次的编排逻辑和外部服务交互，两者结合使用才能构建全面的测试体系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.shayon.dev/post/2024/365/database-mocks-are-just-not-worth-it/"&gt;Database mocks are just not worth it&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Shayon Mukherjee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年12月30日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>为你的软件工程职业生涯做好未来规划</title><link>https://linguista.cn/rosetta/technology/future-proofing-software-engineering-career/</link><pubDate>Tue, 24 Dec 2024 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/future-proofing-software-engineering-career/</guid><description>&lt;h1 id="为你的软件工程职业生涯做好未来规划"&gt;为你的软件工程职业生涯做好未来规划&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文以务实视角分析了大型语言模型对软件工程职业的实际影响。作者指出AI工具正在增强而非取代工程师，并针对初级、中级工程师分别提出适应策略。文章给出六项未来保障建议，包括深化计算机基础、发展系统设计能力、建立领域专长、精通开发运维、提升沟通技巧以及积极使用AI工具，同时强调设计思维和产品意识的重要性。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LLM编码助手的能力边界&lt;/strong&gt;：当前AI工具擅长生成样板代码和实现文档完善的算法，但在处理复杂遗留系统重构、隐含业务逻辑和微妙边缘情况时仍存在明显局限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初级工程师的角色转变&lt;/strong&gt;：入门级岗位不会消失但门槛将提高，核心技能从编写基础代码转向理解系统架构、审查AI输出、识别安全隐患和编写全面测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中级工程师的提升方向&lt;/strong&gt;：传统实现类任务日益自动化，工程师需向系统设计与架构、组件边界管理、性能优化和跨职能沟通等高价值领域发展&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思维与产品意识&lt;/strong&gt;：随着AI降低实现门槛，理解用户需求、工作流程和痛点的能力变得更加关键，工程师需要培养更强的产品思维和与设计团队的协作能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI增强型工作流&lt;/strong&gt;：将AI视为工作流的组成部分而非威胁，用于代码搭建、快速原型、结对调试和优化建议，同时保持人类在架构和设计层面的主导判断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原文链接：&lt;a href="https://addyo.substack.com/p/future-proofing-your-software-engineering"&gt;Future-proofing your Software Engineering career&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href="https://substack.com/@addyosmani"&gt;Addy Osmani&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日期：Dec 24, 2024&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="未来工程职业生涯的实用策略"&gt;未来工程职业生涯的实用策略&lt;/h3&gt;
&lt;p&gt;今天，我们正面临大型语言模型（LLM）带来的新一轮自动化浪潮。围绕这些工具的讨论常常在两个极端之间摇摆——要么预示着我们所知的编程时代的终结，要么将其贬低为仅仅是复杂的自动完成工具。这两种观点都失之偏颇。&lt;/p&gt;
&lt;p&gt;让我们以务实的视角，基于当前的技术能力和行业演变的历史模式，来审视AI对软件工程职业生涯影响的现实情况。&lt;/p&gt;
&lt;h2 id="理解当前llm的能力"&gt;理解当前LLM的能力&lt;/h2&gt;
&lt;p&gt;在讨论职业策略之前，我们需要准确评估LLM能做什么和不能做什么。过去几年，我一直在将各种AI编码助手集成到我的工作中，结果&lt;a href="https://addyo.substack.com/p/the-70-problem-hard-truths-about"&gt;颇具启发性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这些工具在某些任务上表现出色。它们可以快速生成样板代码，在编程语言之间进行翻译，并实现文档完善的算法。在使用像React这样的流行框架时，它们通常能生成只需少量修改即可使用的代码。例如，让Claude Sonnet或GPT-4o创建一个基本的REST API和前端，通常会得到一个可行的实现，并带有错误处理和基本验证。你可能正通过Cursor、Copilot或Cline等工具层来完成这些工作。&lt;/p&gt;
&lt;p&gt;然而，在更复杂的场景中，它们的局限性就显现出来了。最近，我尝试使用各种LLM来帮助重构一个遗留系统，该系统复杂的业务逻辑分布在多个服务中。这些工具始终无法掌握组件之间隐含的关系以及现有代码处理的微妙边缘情况。它们生成了看似合理但根本上存在缺陷的解决方案，如果不经过仔细审查就实施，会引入严重的错误。&lt;/p&gt;
&lt;p&gt;我观察到的一个特别令人担忧的模式是，这些工具会自信地产生错误或过于复杂的解决方案。初级开发者渴望利用AI辅助，有时会在没有充分审查的情况下接受这些输出，导致技术债务或安全漏洞。我亲身经历过一些案例，初级工程师要么因为盲目听从AI建议而实现了完全无法工作的解决方案，要么创建了不必要的复杂实现，原因在于他们缺乏充分的理解。这再次强调了扎实的基础知识和批判性审查技能的重要性。&lt;/p&gt;
&lt;h2 id="ai已经开始取代软件工程师了吗"&gt;AI已经开始取代软件工程师了吗？&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa7c79bf0-a360-4b54-a736-27d86b4b55a1_1026x1368.jpeg" alt=""&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;最近在旧金山拍摄的一张真实照片，“AI即将抢走你的工作”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在深入探讨职业影响之前，让我们先解决那个显而易见的问题：在AI辅助开发工具出现大约两年后，实际发生了什么变化？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI辅助开发已经存在约2年多了，但&lt;strong&gt;没有&lt;/strong&gt;出现AI取代工作的广泛案例&lt;/li&gt;
&lt;li&gt;众多旨在创建“AI工程师”的初创公司正在涌现（如Devin、Magic.dev等）&lt;/li&gt;
&lt;li&gt;GitHub Copilot、Claude和Google的IDX等工具正变得主流&lt;/li&gt;
&lt;li&gt;像Bolt.new和Lovable.dev这样的平台服务于特定用例，但并未取代传统开发&lt;/li&gt;
&lt;li&gt;重要的是，&lt;strong&gt;没有&lt;/strong&gt;经验证据表明大规模采用导致工程师被取代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理解这个背景对于如何在不过度反应的情况下适应至关重要。现实情况是，虽然AI工具正在改变我们的工作方式，但它们更多是在增强而非取代人类工程师。&lt;/p&gt;
&lt;h2 id="初级工程师的困境"&gt;初级工程师的困境&lt;/h2&gt;
&lt;p&gt;与普遍猜测相反，初级工程岗位不太可能完全消失。然而，它们将发生显著转变。通过实现基本的CRUD应用程序和简单功能来学习的传统路径将会演变，因为这些任务正变得日益自动化。&lt;/p&gt;
&lt;p&gt;这种演变给处于职业生涯早期的开发者带来了挑战和机遇。入门级职位的门槛可能会提高，需要更强的基础知识才能有效地审查和验证AI生成的代码。然而，这种转变也意味着初级工程师可能在职业生涯早期就能接触到更有趣的问题。&lt;/p&gt;
&lt;p&gt;考虑一个典型的初级任务：按照现有模式实现一个新的API端点。以前，这可能需要一天的编码和测试。有了AI辅助，实现时间可能缩短到一个小时，但关键技能变成了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;充分理解现有系统架构，以便正确指定需求&lt;/li&gt;
&lt;li&gt;审查生成的代码，检查安全隐患和边缘情况&lt;/li&gt;
&lt;li&gt;确保实现与现有模式保持一致性&lt;/li&gt;
&lt;li&gt;编写全面的测试来验证业务逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些技能无法单纯通过看教程或提示AI来学习——它们需要实际操作生产系统的经验和高级工程师的指导。&lt;/p&gt;
&lt;h2 id="中级工程师适应的必要性"&gt;中级工程师：适应的必要性&lt;/h2&gt;
&lt;p&gt;中级工程师可能面临着最大的演变压力。许多传统上占据他们时间的任务——实现功能、编写测试、调试直接的问题——正变得越来越可自动化。&lt;/p&gt;
&lt;p&gt;这并不意味着过时；这意味着提升。焦点从编写代码转向：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;系统设计与架构&lt;/strong&gt; 与其花费数天实现一个新功能，中级工程师可能会将这些时间用于设计能够优雅处理规模和故障模式的健壮系统。这需要深入理解分布式系统原理、数据库内部机制和云基础设施——这些领域目前LLM提供的价值有限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集成与边界&lt;/strong&gt; 随着系统变得越来越复杂，理解和管理组件之间的边界变得至关重要。这包括API设计、事件模式和数据模型——所有这些都需要仔细考虑业务需求和未来的灵活性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt; 虽然LLM可以建议基本的优化，但识别和解决系统范围的性能问题需要深入理解整个技术栈，从数据库查询模式到前端渲染策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨职能沟通&lt;/strong&gt; 随着实现时间的缩短，在业务需求和技术解决方案之间进行转换的能力变得更有价值。能够与产品经理、设计师和其他利益相关者有效沟通的工程师将变得越来越有价值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="职业生涯未来保障的实用步骤"&gt;职业生涯未来保障的实用步骤&lt;/h2&gt;
&lt;p&gt;基于这些观察，以下是在AI增强的未来中维持和提升工程职业生涯的具体步骤：&lt;/p&gt;
&lt;h3 id="1-深化你的计算机科学基础"&gt;1. 深化你的计算机科学基础&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;超越基础的数据结构和算法&lt;/li&gt;
&lt;li&gt;分布式系统原理&lt;/li&gt;
&lt;li&gt;数据库内部原理和查询优化&lt;/li&gt;
&lt;li&gt;网络协议和安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些知识有助于你理解AI生成代码的影响，并做出更好的架构决策。&lt;/p&gt;
&lt;h3 id="2-发展系统设计专业知识"&gt;2. 发展系统设计专业知识&lt;/h3&gt;
&lt;p&gt;练习设计能够大规模解决实际问题的系统。这包括：&lt;/p&gt;</description></item><item><title>缔造谷歌庞大帝国的友谊</title><link>https://linguista.cn/rosetta/technology/the-friendship-that-built-google/</link><pubDate>Mon, 03 Dec 2018 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/the-friendship-that-built-google/</guid><description>&lt;h1 id="缔造谷歌庞大帝国的友谊"&gt;缔造谷歌庞大帝国的友谊&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文讲述了谷歌两位顶尖工程师Jeff Dean和Sanjay Ghemawat长达数十年的合作友谊。他们通过在同一台电脑前共同编程的独特方式，解决了谷歌早期面临的索引崩溃、硬件故障和系统扩展等关键难题，重写了公司核心基础设施，推动谷歌从一家初创公司成长为互联网巨头。两人是谷歌仅有的十一级高级院士，被誉为公司一个大脑的两半。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;结对编程（Pair Programming）&lt;/strong&gt;：两位程序员共用一台电脑协同开发的工作方式，Jeff Dean和Sanjay Ghemawat以此模式完成了谷歌多项核心系统的构建&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可扩展性（Scalability）&lt;/strong&gt;：系统应对规模增长的能力，谷歌早期代码无法支撑快速膨胀的网络索引，必须通过架构重写来实现扩展&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宇宙射线比特翻转（Cosmic Ray Bit Flip）&lt;/strong&gt;：超新星爆炸产生的高能粒子击中芯片导致数据位从0变为1的罕见物理现象，在大规模廉价硬件集群中成为不可忽视的故障来源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谷歌工程师等级体系（Google Engineering Levels）&lt;/strong&gt;：从一级IT支持到十一级高级院士的层级制度，反映了工程师的技术影响力和贡献规模&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统容错（Distributed System Fault Tolerance）&lt;/strong&gt;：在大规模计算集群中通过软件手段应对硬件故障，使系统在部件不断失效的情况下仍能稳定运行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过在同一台电脑前共同编程，Jeff Dean 和 Sanjay Ghemawat 改变了公司乃至互联网的进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者：James Somers
2018年12月3日&lt;/p&gt;
&lt;p&gt;&lt;img src="https://media.newyorker.com/photos/5c0040d75cc0c92d353cfc9c/master/w_2240,c_limit/181210_r33377.jpg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Jeff Dean 和 Sanjay Ghemawat 的插画&lt;/em&gt;
&lt;em&gt;公司顶尖的程序员们如同一个大脑的两半。插画：David Plunkert&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2000年3月的一天，谷歌最优秀的六名工程师聚集在一个临时的作战室里。公司正面临前所未有的紧急状况。去年10月，其核心系统——负责抓取网页以建立“索引”的系统——停止了工作。尽管用户仍然可以在 google.com 上输入查询，但他们得到的结果是五个月前的旧数据。工程师们当时并未意识到，事情的风险远比他们想象的更大。谷歌的联合创始人拉里·佩奇（Larry Page）和谢尔盖·布林（Sergey Brin）正在谈判一项为雅虎（Yahoo）提供搜索引擎支持的交易，他们承诺交付一个比当时大十倍的索引——一个能够跟上万维网发展速度的索引，而万维网在去年规模已翻了一番。如果他们失败了，google.com 将继续停留在过去，雅虎的交易很可能泡汤，公司也将面临耗尽资金直至湮灭的风险。&lt;/p&gt;
&lt;p&gt;在一个靠近楼梯的会议室里，工程师们把门板架在锯木架上，摆好了电脑。克雷格·西尔弗斯坦（Craig Silverstein），一个身材瘦小、声音尖细的二十七岁年轻人，坐在靠远墙的位置。西尔弗斯坦是谷歌的第一位员工：他在公司办公室还在布林的客厅时就加入了，并亲自重写了大部分代码。经过四天四夜的奋战，他和一位名叫波格丹·科科塞尔（Bogdan Cocosel）的罗马尼亚系统工程师一无所获。“我们做的所有分析都毫无意义，”西尔弗斯坦回忆道。“一切都坏了，我们不知道为什么。”&lt;/p&gt;
&lt;p&gt;西尔弗斯坦几乎没有注意到他左后方桑杰·格玛沃特（Sanjay Ghemawat）的存在。桑杰是一位安静的三十三岁麻省理工学院毕业生，浓眉，鬓角已开始发灰。桑杰几个月前，也就是12月份才加入公司。他是跟随他的同事——一位名叫杰夫·迪恩（Jeff Dean）的高个子、精力充沛的三十一岁年轻人——从数字设备公司（Digital Equipment Corporation, DEC）过来的。杰夫比桑杰早十个月离开DEC。他们关系异常密切，并且喜欢一起写代码。在作战室里，杰夫把椅子滑到桑杰的桌旁，留下自己的空位。桑杰操作键盘，而杰夫则靠在他身边，像新闻主播耳边的制作人一样纠正和引导。&lt;/p&gt;
&lt;p&gt;杰夫和桑杰开始仔细研究那个停滞的索引。他们发现有些词丢失了——搜索“mailbox”（邮箱）却没有任何结果——而另一些词则顺序混乱。几天来，他们一直在代码中寻找缺陷，沉浸在其逻辑中。逐段检查，一切似乎都没问题。他们找不到那个错误（bug）。&lt;/p&gt;
&lt;p&gt;程序员有时会将他们的软件概念化为一个层次结构，从顶层的用户界面，向下延伸到越来越基础的层面。深入到这个结构的底层，即软件与硬件交汇之处，意味着从柏拉图式的代码秩序转向其所依赖的电力和硅的元素世界。在作战室的第五天，杰夫和桑杰开始怀疑他们寻找的问题并非逻辑上的，而是物理上的。他们将混乱的索引文件转换为其最原始的表示形式：二进制代码。他们想看看他们的机器看到了什么。&lt;/p&gt;
&lt;p&gt;在桑杰的显示器上，出现了一列密集的1和0，每一行代表一个索引词。桑杰指着：一个本应是0的数字变成了1。当杰夫和桑杰把所有排序错误的词放在一起时，他们看到了一个模式——每个词都出现了同一种小故障。他们机器的内存芯片不知何故损坏了。&lt;/p&gt;
&lt;p&gt;桑杰看着杰夫。几个月来，谷歌经历的硬件故障越来越多。问题在于，随着谷歌的发展，其计算基础设施也在扩张。计算机硬件很少出故障，除非你拥有足够多的硬件——那时它就会一直出故障。电线磨损，硬盘崩溃，主板过热。许多机器从一开始就不能工作；有些会莫名其妙地变慢。奇怪的环境因素也开始起作用。当超新星爆炸时，冲击波会产生高能粒子并向四面八方散射；科学家认为，这些被称为宇宙射线的迷途粒子有极小的概率击中地球上的计算机芯片，将0翻转为1。世界上最稳健的计算机系统，如NASA、金融公司等，使用能够容忍单位比特翻转的特殊硬件。但谷歌，当时仍像初创公司一样运作，购买的是缺乏该功能的廉价计算机。公司已经到达了一个拐点。它的计算集群变得如此庞大，以至于即使是罕见的硬件故障也变得不可避免。&lt;/p&gt;
&lt;p&gt;杰夫和桑杰一起编写了代码来补偿那些出问题的机器。不久之后，新的索引完成了，作战室也解散了。西尔弗斯坦感到困惑。他是一个优秀的调试者；找到错误的关​​键在于探究问题的根源。杰夫和桑杰则探究得更深。&lt;/p&gt;
&lt;p&gt;在三月份索引崩溃事件之前，谷歌的系统根植于其创始人在斯坦福大学读研究生时编写的代码。佩奇和布林并非专业的软件工程师。他们是进行搜索技术实验的学者。当他们的网络爬虫崩溃时，没有提供信息的诊断消息——只有一句“Whoa, horsey!”（喔唷，小马！）。早期员工将佩奇和布林编写的一个名为 BigFiles 的软件称为 BugFiles（充满错误的文件）。他们至关重要的索引代码需要数天才能完成，并且如果遇到问题，就必须从头开始。用硅谷的行话来说，谷歌当时不具备“可扩展性”（scalable）。&lt;/p&gt;
&lt;p&gt;我们说我们“搜索网络”，但实际上并非如此；我们的搜索引擎遍历的是网络的索引——一张地图。当谷歌在1996年还叫BackRub时，它的地图小到可以装在佩奇宿舍里的电脑上。到了2000年3月，已经没有足够大的超级计算机来处理它了。谷歌能够跟上发展的唯一方法是购买消费级机器并将它们连接成一个集群。由于这些计算机一半的成本在于谷歌认为是垃圾的部件——软盘驱动器、金属机箱——公司会订购裸露的主板和硬盘，并将它们像三明治一样叠在一起。谷歌在加利福尼亚州圣克拉拉的一栋建筑里，将一千五百台这样的设备堆叠成六英尺高的塔架；由于硬件故障，只有一千二百台能工作。故障似乎随机发生，不断破坏系统。为了生存，谷歌必须将其计算机联合成一个无缝、有弹性的整体。&lt;/p&gt;
&lt;p&gt;杰夫和桑杰并肩负责了这项工作。韦恩·罗辛（Wayne Rosing）曾在苹果公司参与麦金塔电脑前身的工作，于2000年11月加入谷歌，负责管理其百人工程师团队。“他们是领导者，”他说。他们每周工作九十个小时，编写代码，使得单个硬盘故障不会导致整个系统瘫痪。他们在爬取过程中添加了检查点，以便可以在中途重新启动。通过开发新的编码和压缩方案，他们有效地将系统容量翻了一番。他们是无情的优化者。当汽车转弯时，外侧轮子必须覆盖更多地面；同样，旋转硬盘的外边缘比内边缘移动得更快。谷歌已将最常访问的数据移到外部，以便数据位可以在读写头下更快地流动，但内部一半是空的；杰夫和桑杰利用这个空间存储了常见搜索查询的预处理数据。在2001年的四天里，他们证明了谷歌的索引可以使用快速的随机存取存储器（RAM）而不是相对较慢的硬盘来存储；这一发现重塑了公司的经济模式。佩奇和布林知道用户会涌向能够即时提供答案的服务。问题在于速度需要计算能力，而计算能力需要花钱。杰夫和桑杰用软件巧妙地解决了这个问题。&lt;/p&gt;
&lt;p&gt;艾伦·尤斯塔斯（Alan Eustace）在罗辛于2005年离开后成为工程团队的负责人。“要解决规模化问题，矛盾的是，你必须了解最微小的细节，”尤斯塔斯说。杰夫和桑杰在比特层面上理解计算机。杰夫曾分发过一份名为“每个程序员都应知道的延迟数字”的列表。事实上，这是一份几乎没有程序员知道的数字列表：L1缓存引用通常需要半纳秒，或者从内存中顺序读取一兆字节需要二百五十微秒。这些数字已深深烙印在杰夫和桑杰的大脑中。在他们帮助引领谷歌核心软件的几次重写过程中，系统的容量按数量级扩展。与此同时，在公司庞大的数据中心里，技术人员现在沿着蛇形路线行走，遵循软件生成的指令更换硬盘驱动器、电源和内存条。即使其部件磨损和失效，系统依然蓬勃发展。&lt;/p&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/paul_graham/essays_zh/progbot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/paul_graham/essays_zh/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/paul_graham/essays_en/progbot/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;
&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;
&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;
&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;
&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;
&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;
&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;
&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;
&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;
&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;
&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;
&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description></item></channel></rss>