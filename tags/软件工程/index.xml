<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>软件工程 on Linguista</title><link>https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 软件工程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 13 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读</title><link>https://linguista.cn/curated/summary-2025-p1/devin-ai-intern-software-team-scott-wu/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/summary-2025-p1/devin-ai-intern-software-team-scott-wu/</guid><description>&lt;h1 id="让ai实习生成为软件团队的无限力量devin产品与ai工程协作深度解读"&gt;让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Cognition Labs联合创始人兼CEO Scott Wu详细介绍了AI代理产品Devin如何以&amp;quot;实习生&amp;quot;角色融入软件开发团队。Devin能独立承接明确定义的工程任务，支持异步多线程并行推进，覆盖前端修复、依赖升级、文档生成、故障响应和自动化测试五大核心场景，极大提升团队吞吐量与协作效率。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;Scott Wu在本次访谈中系统阐述了Devin的产品定位与工作方式。Devin并非传统的智能IDE式代码补全工具，而是一位可被委派具体任务、能独立开展工作的AI团队成员。它定位于初级工程师角色，擅长处理明确定义的操作型任务，而非需要深度推理的复杂架构决策。&lt;/p&gt;
&lt;p&gt;在实际工作流方面，Scott演示了从任务触发到AI执行再到成果交付的完整闭环。任务通常由Slack或Linear等平台发起，Devin通过DeepWiki等工具分析代码库，自动生成Pull Request并附带截图与前后对比。团队成员可同时分派多项任务让AI并行推进，遇到瓶颈时人类即时补充指导，形成高效的人机协作Debug闭环。&lt;/p&gt;
&lt;p&gt;Scott还总结了AI融入团队的关键心智模型：异步并行与自动化协同、知识共享与公共学习、精准的Prompt工程方法论，以及人机混合的Debug复盘机制。这些框架帮助团队将AI从工具升级为真正的组织成员，实现持续成长的多智能体协作生态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异步AI实习生成员制&lt;/strong&gt;：将AI定位为团队的&amp;quot;异步无限实习生&amp;quot;，分派明确可交付的任务由AI全程自动推进。人类成员无需同步等待，可并行开展更高价值事务。这一模式的核心在于&amp;quot;任务而非问题&amp;quot;导向——AI擅长执行精准描述的操作型任务，而人类专注于需要深度推理和综合判断的复杂问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务导向的Prompt方法论&lt;/strong&gt;：所有给AI的任务需做到&amp;quot;背景充分＋指令明确&amp;quot;。Scott强调应先用DeepWiki等工具沉淀需求和背景，再生成精确Prompt输入给AI，而非直接甩给AI一句话。良好的Prompt习惯直接提升AI完成质量，减少后续返工，也推动AI产品向自动理解半成品需求的方向演进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五大黄金应用场景&lt;/strong&gt;：前端修复与微调、依赖与版本升级、文档自动生成与完善、故障响应与分析（作为第一道防线）、自动化测试与CI流程辅助。这五类任务具有明确定义、重复性高、对创造性要求较低的特点，是AI工程代理最能发挥价值的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机混合Debug闭环&lt;/strong&gt;：团队成员可追踪AI执行日志，实时发现问题并补充信息，通过多轮交互持续提升AI表现。公共频道中的协作讨论让AI不断积累组织知识，反哺后续新成员，将AI代理运营成学习型组织的核心成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多端融合协作界面&lt;/strong&gt;：AI代理可集成到Slack、Linear、IDE等多种工具中，适配不同角色和团队协作习惯。未来趋势是人类只需与AI交流需求，AI在后台自动完成所有实现细节，人类关注输出而非每一步流程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=7m_xKFqSxTo"&gt;How Devin replaces your junior engineers with infinite AI interns that never sleep&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;How I AI（Claire Vo对话Scott Wu，Cognition Labs CEO）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>专有技术困境与AI代码生成</title><link>https://linguista.cn/static/ai-know-how-dilemma/</link><pubDate>Thu, 03 Jul 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/static/ai-know-how-dilemma/</guid><description>深入探讨 AI 在软件工程中的“专有技术困境”。尽管 AI 擅长处理可编码的事实知识，但在涉及经验、直觉和情境理解的复杂任务中，其局限性暴露无遗。本分析通过交互式图表，揭示了 AI 代码生成中存在的复合错误累积、安全漏洞风险以及领域性能衰减等核心问题，并对比了人类专家与 AI 在知识处理机制上的本质差异。</description></item><item><title>强工程师与弱工程师的能力差异分析</title><link>https://linguista.cn/curated/summary-2025-p1/strong-vs-weak-engineers-differences/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/summary-2025-p1/strong-vs-weak-engineers-differences/</guid><description>&lt;h1 id="强工程师与弱工程师的能力差异分析"&gt;强工程师与弱工程师的能力差异分析&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程领域中强工程师与弱工程师之间的本质区别。作者指出，强工程师的核心能力在于能够完成其他工程师无法完成的任务，这种能力差异在某些情况下甚至是无限的。文章详细分析了三类工程师的特征，并提供了与弱工程师合作的实用建议。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先明确了强工程师与弱工程师的核心区别在于能力范围的不同。强工程师能够胜任复杂项目的交付、解决跨多个服务的竞态条件等困难bug、对遗留代码库进行有意义的改进，以及进行需要大规模架构重构的变更。这种能力不是线性的差异，而是质的飞跃——有些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。&lt;/p&gt;
&lt;p&gt;普通工程师构成了团队的稳定力量。他们能够解决大部分bug、完成大多数JIRA任务，并在大多数情况下解决开发环境问题。虽然他们可能不追求在下一个晋升周期中表现出色，但他们是团队日常运作的中坚力量。&lt;/p&gt;
&lt;p&gt;弱工程师则面临严重的能力缺失。即使是正常到容易的任务对他们来说也过于困难。在高级职位中，弱工程师通过频繁的单向配对编程来完成任务，依赖其他工程师的帮助。他们还可能在工作讨论中表现得非常活跃，以掩盖其实际工作能力不足。这种现象对团队的影响尤为严重，尤其是对初级工程师的时间和精力占用。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;能力无限差异&lt;/strong&gt;：强工程师与弱工程师之间的差异不是程度上的，而是种类上的。某些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。这种差异在某些情况下是无限的，意味着弱工程师可能永远无法完成某些任务，无论投入多少时间和努力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单向配对编程&lt;/strong&gt;：弱工程师的主要生存策略之一。他们频繁地与其他工程师进行&amp;quot;配对编程&amp;quot;，但实际上这种配对是单向的——其他工程师在为他们完成工作。这种策略掩盖了弱工程师的实际能力不足，但同时也占用了团队中其他工程师的宝贵时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;善意与边界保护&lt;/strong&gt;：文章建议在与弱工程师合作时保持善意，理解他们可能面临的个人困难，但同时也要保护自己的时间和团队的时间。可以通过快速回应而不是提供完整解决方案来避免时间不对称的帮助，并确保管理层了解情况，防止弱工程师利用初级工程师。&lt;/p&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.seangoedecke.com/weak-engineers/"&gt;What can strong engineers do that weak engineers can&amp;rsquo;t?&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Sean Goedecke&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-04&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>数据库模拟的局限性与真实数据库测试的重要性</title><link>https://linguista.cn/curated/summary-2025-p1/database-mocks-vs-real-testing/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/summary-2025-p1/database-mocks-vs-real-testing/</guid><description>&lt;h1 id="数据库模拟的局限性与真实数据库测试的重要性"&gt;数据库模拟的局限性与真实数据库测试的重要性&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;在软件开发过程中，使用数据库模拟进行测试看似快速便捷，但实际上可能掩盖许多潜在问题。本文通过对比分析，阐述了真实数据库测试在发现数据完整性问题、适应架构变化、处理并发场景等方面的显著优势，并提出了分层测试策略，帮助开发团队在测试效率与质量之间取得平衡。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先指出了一个常见现象：许多开发团队在测试中倾向于使用数据库模拟，因为这种方式执行速度快且实现简单。然而，作者通过实际案例对比，揭示了这种做法的风险。当使用模拟的用户仓库进行测试时，虽然能够验证基本的创建逻辑，但却无法暴露数据完整性、约束条件等在生产环境中可能出现的问题。&lt;/p&gt;
&lt;p&gt;文章进一步强调了真实数据库测试在&amp;quot;面向未来&amp;quot;方面的重要性。随着应用程序的演进，数据库架构不可避免地会发生变化，包括新的验证规则、数据类型调整、时间戳精度修改等。这些变化往往会引发意想不到的错误，而模拟数据库根本无法捕捉到这些问题。使用真实数据库进行测试，可以让团队在开发阶段就发现这些隐患，避免在生产环境中浪费宝贵的调试时间。&lt;/p&gt;
&lt;p&gt;在测试策略部分，作者提出了分层测试的理念。应用程序通常包含多个层次，如控制器、服务、仓库等，每一层都有其特定的职责。对于数据访问层和服务层，应该使用真实数据库进行测试，以确保外键约束、引用完整性、事务处理等核心机制的正确性。而对于控制器层，则可以适当地模拟服务调用，专注于测试请求处理和响应编排。这种分层策略既保证了关键逻辑的测试覆盖，又维持了合理的测试执行速度。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据完整性验证&lt;/strong&gt;：模拟数据库无法真实反映生产环境中的约束条件和完整性规则。真实数据库测试能够揭示外键冲突、唯一性约束、级联删除等潜在问题，这些在模拟环境中往往被忽略，但会在生产环境中造成严重后果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构演进的适应性&lt;/strong&gt;：应用程序的数据库架构会随着业务需求的变化而演进。新特性的添加、验证规则的调整、数据类型的修改都可能引入错误。真实数据库测试能够及时捕捉这些由架构变化引起的问题，而模拟数据库则无法反映这些变化，导致测试与实际运行环境脱节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发与事务处理&lt;/strong&gt;：在涉及账户余额、交易总额等业务场景时，并发访问、隔离级别和聚合计算的正确性至关重要。真实数据库测试可以暴露并发竞争条件、死锁、事务隔离等问题，确保业务逻辑的准确性和数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层测试策略&lt;/strong&gt;：应用程序的架构分层为测试策略提供了清晰的指导。数据访问层需要真实数据库来验证SQL执行和数据库交互；服务层需要真实数据库来检验业务逻辑与数据的交互；控制器层则可以通过模拟服务来专注于请求处理和响应编排的测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试效率与质量的平衡&lt;/strong&gt;：真实数据库测试确实会增加测试执行时间，但这种投入在保证应用程序质量方面是值得的。对于复杂的数据关系、性能敏感的场景以及关键业务逻辑，真实数据库测试是不可或缺的。模拟仍然适用于验证高层次的编排逻辑和外部服务交互，两者结合使用才能构建全面的测试体系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.shayon.dev/post/2024/365/database-mocks-are-just-not-worth-it/"&gt;Database mocks are just not worth it&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Shayon Mukherjee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年12月30日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/paul_graham/essays_zh/progbot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/paul_graham/essays_zh/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/paul_graham/essays_en/progbot/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;
&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;
&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;
&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;
&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;
&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;
&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;
&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;
&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;
&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;
&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;
&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description></item></channel></rss>