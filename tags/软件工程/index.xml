<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>软件工程 on Linguista</title><link>https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link><description>Recent content in 软件工程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 27 Sep 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>AI编程时代之后软件工程的未来演进</title><link>https://linguista.cn/curated/henrinotes-2025_p2/ai-coding-future-software-engineering-scott-wu/</link><pubDate>Sat, 27 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025_p2/ai-coding-future-software-engineering-scott-wu/</guid><description>&lt;h1 id="ai编程时代之后软件工程的未来演进"&gt;AI编程时代之后软件工程的未来演进&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于AI&amp;amp;I播客对Cognition Labs CEO Scott Wu的深度访谈，探讨了AI编程代理（如Devin）的崛起如何重塑软件工程的本质。Wu认为，AGI已在经济意义上部分到来，AI代理的自主时间正像孩子成长一样逐步延长。未来软件工程将呈现人机协作新范式：AI负责重复性编码任务，人类工程师专注于架构设计、需求拆解和技术决策等高阶抽象工作。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;对话围绕六大核心主题展开。首先关于AGI是否已到来，Wu提出&amp;quot;经济价值标准&amp;quot;——当AI代理能够持续自主运作并创造经济价值时，即意味着AGI实质到来。他强调社会对AGI的定义是动态演进的，自动化水平提升后，人类又会转向剩余未被自动化的工作。&lt;/p&gt;
&lt;p&gt;在软件工程变革方面，Wu认为AI正在重塑编程的&amp;quot;基本单元&amp;quot;。未来工程师将分化为两类：通过AI提升效率的传统工程师，以及以人机协作为本的AI优先型工程师。后者仅在特殊情况下手动编码，更多承担决策与调度角色。&lt;/p&gt;
&lt;p&gt;关于工具形态演化，Wu描述了从同步IDE工具（Tab补全）到异步智能体（Devin）再到CLI智能体（Cloud Code）的演进路径。未来将形成同步-异步无缝切换的混合开发流程：人类主导项目决策和需求拆解，AI执行具体编码、测试、调试等流程化任务。&lt;/p&gt;
&lt;p&gt;在技术实现层面，Cognition Labs不自研基础模型，但专注于后训练和强化学习环境打造。代码场景独特的可验证反馈回路使其成为理想的RL训练环境。Wu预判长远来看，AI的在线持续学习将成为主流提升路径。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AGI的经济价值标准&lt;/strong&gt;：Wu提出判断AGI到来的实用标准不是抽象的智能指标，而是&amp;quot;长期开启AI代理成为一种盈利模式&amp;quot;。当AI能够始终处于运作状态并持续创造经济价值时，就可认为AGI实质到来。这一标准将技术能力与实际应用紧密挂钩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件工程的分层认知框架&lt;/strong&gt;：第一层为基础技能与自动化，由AI负责重复性底层工作；第二层为中阶抽象与架构设计，人类专注把控需求拆分、系统架构等决策；第三层为跨界思维与协作，激发创造性解决方案。人类需向&amp;quot;系统性专家&amp;quot;身份转型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机协作型工程师&lt;/strong&gt;：具备试错迭代心态，不断尝试新工具并坦然面对不成熟性；拥有团队归属感，强调长期事业意义高于短期收益；善于运用多终端接入点，根据需求在CLI、IDE、IM等接口间切换，适时向AI代理放权。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可验证反馈回路&lt;/strong&gt;：代码场景的独特优势在于能够提供清晰的奖励信号（运行结果、错误追踪），这使其成为理想的强化学习训练环境。训练AI软件工程师的核心是抽象设计有代表性的真实问题环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理自主时间的成长类比&lt;/strong&gt;：Wu将AI代理的发展比作儿童成长的自理能力提升——从最初只能执行Tab补全，到可连续自主运行十多分钟的长链代理，自主性持续增强。这种类比形象描述了AI能力进化的渐进性质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=ectyyex0IBo"&gt;Cognition&amp;rsquo;s CEO on What Comes After Code&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Scott Wu (采访者: Dan Shipper)&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;来源&lt;/td&gt;
 &lt;td&gt;Every AI&amp;amp;I 播客&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读</title><link>https://linguista.cn/curated/henrinotes-2025-p1/devin-ai-intern-software-team-scott-wu/</link><pubDate>Sat, 13 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/devin-ai-intern-software-team-scott-wu/</guid><description>&lt;h1 id="让ai实习生成为软件团队的无限力量devin产品与ai工程协作深度解读"&gt;让AI实习生成为软件团队的无限力量——Devin产品与AI工程协作深度解读&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Cognition Labs联合创始人兼CEO Scott Wu详细介绍了AI代理产品Devin如何以&amp;quot;实习生&amp;quot;角色融入软件开发团队。Devin能独立承接明确定义的工程任务，支持异步多线程并行推进，覆盖前端修复、依赖升级、文档生成、故障响应和自动化测试五大核心场景，极大提升团队吞吐量与协作效率。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;Scott Wu在本次访谈中系统阐述了Devin的产品定位与工作方式。Devin并非传统的智能IDE式代码补全工具，而是一位可被委派具体任务、能独立开展工作的AI团队成员。它定位于初级工程师角色，擅长处理明确定义的操作型任务，而非需要深度推理的复杂架构决策。&lt;/p&gt;
&lt;p&gt;在实际工作流方面，Scott演示了从任务触发到AI执行再到成果交付的完整闭环。任务通常由Slack或Linear等平台发起，Devin通过DeepWiki等工具分析代码库，自动生成Pull Request并附带截图与前后对比。团队成员可同时分派多项任务让AI并行推进，遇到瓶颈时人类即时补充指导，形成高效的人机协作Debug闭环。&lt;/p&gt;
&lt;p&gt;Scott还总结了AI融入团队的关键心智模型：异步并行与自动化协同、知识共享与公共学习、精准的Prompt工程方法论，以及人机混合的Debug复盘机制。这些框架帮助团队将AI从工具升级为真正的组织成员，实现持续成长的多智能体协作生态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异步AI实习生成员制&lt;/strong&gt;：将AI定位为团队的&amp;quot;异步无限实习生&amp;quot;，分派明确可交付的任务由AI全程自动推进。人类成员无需同步等待，可并行开展更高价值事务。这一模式的核心在于&amp;quot;任务而非问题&amp;quot;导向——AI擅长执行精准描述的操作型任务，而人类专注于需要深度推理和综合判断的复杂问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务导向的Prompt方法论&lt;/strong&gt;：所有给AI的任务需做到&amp;quot;背景充分＋指令明确&amp;quot;。Scott强调应先用DeepWiki等工具沉淀需求和背景，再生成精确Prompt输入给AI，而非直接甩给AI一句话。良好的Prompt习惯直接提升AI完成质量，减少后续返工，也推动AI产品向自动理解半成品需求的方向演进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五大黄金应用场景&lt;/strong&gt;：前端修复与微调、依赖与版本升级、文档自动生成与完善、故障响应与分析（作为第一道防线）、自动化测试与CI流程辅助。这五类任务具有明确定义、重复性高、对创造性要求较低的特点，是AI工程代理最能发挥价值的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机混合Debug闭环&lt;/strong&gt;：团队成员可追踪AI执行日志，实时发现问题并补充信息，通过多轮交互持续提升AI表现。公共频道中的协作讨论让AI不断积累组织知识，反哺后续新成员，将AI代理运营成学习型组织的核心成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多端融合协作界面&lt;/strong&gt;：AI代理可集成到Slack、Linear、IDE等多种工具中，适配不同角色和团队协作习惯。未来趋势是人类只需与AI交流需求，AI在后台自动完成所有实现细节，人类关注输出而非每一步流程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=7m_xKFqSxTo"&gt;How Devin replaces your junior engineers with infinite AI interns that never sleep&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;How I AI（Claire Vo对话Scott Wu，Cognition Labs CEO）&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;-&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件复杂性的本质与偶然：AI 时代的工程变革</title><link>https://linguista.cn/curated/henrinotes_2025_p4/software-complexity-essential-vs-accidental/</link><pubDate>Thu, 04 Sep 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/software-complexity-essential-vs-accidental/</guid><description>&lt;h1 id="软件复杂性的本质与偶然ai-时代的工程变革"&gt;软件复杂性的本质与偶然：AI 时代的工程变革&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Cognition CEO Scott Wu 在访谈中提出了软件复杂性的核心框架：本质复杂性与偶然复杂性。本质复杂性指业务逻辑、架构设计等需要人类决策的核心问题；偶然复杂性则是代码规范、环境配置等技术实现细节。他认为，AI 工具如 Devin 能够大幅削减偶然复杂性，让工程师从 80%&lt;del&gt;90% 的重复性工作中解放出来，实现 8&lt;/del&gt;15 倍的效率提升。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;访谈围绕软件复杂性的双重展开。Scott 首先明确区分了本质复杂性与偶然复杂性：前者关乎&amp;quot;做什么&amp;quot;的战略决策，如系统架构、业务逻辑处理、特殊场景应对；后者涉及&amp;quot;怎么做&amp;quot;的技术实现，如代码规范、环境配置、兼容性处理。&lt;/p&gt;
&lt;p&gt;他强调，传统软件工程中存在一个悖论：工程师的核心价值在于决策（本质复杂性），却花费 80%&lt;del&gt;90% 的时间在执行（偶然复杂性）。AI 工具的介入正在打破这一困局。Scott 以 Cognition 的 Devin 为例，展示了 AI 代理在代码迁移、版本升级、批量重构等场景下的实战表现——企业客户获得 8&lt;/del&gt;15 倍效率提升。&lt;/p&gt;
&lt;p&gt;未来工作模式将呈现&amp;quot;同步+异步&amp;quot;混合特征。同步部分，工程师在 IDE 中直接参与高层决策、架构设计、关键逻辑制定；异步部分，AI 代理根据人类指令自动完成具体实现、测试、文档等工作。Scott 预测，工程师的核心能力将从&amp;quot;记忆细节、语法&amp;quot;转向&amp;quot;高层决策、产品理解、架构设计&amp;quot;。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本质复杂性（Essential Complexity）&lt;/strong&gt;：软件开发的战略层面，指必须由人类工程师做出的核心决策，包括系统架构设计、业务逻辑处理、特殊场景应对（如余额为负时的处理方式）。Scott 认为，&amp;ldquo;软件工程师的本质就是在代码的语境下解决问题，做出各种决策&amp;rdquo;，这部分工作是 AI 无法替代的人类价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偶然复杂性（Accidental Complexity）&lt;/strong&gt;：软件开发的战术层面，指为实现和维护软件而产生的额外工作，包括代码规范、环境配置、兼容性处理等。Scott 指出，这部分工作占据工程师 80%~90% 的时间，但并不创造直接价值，正是 AI 工具应该自动化的领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步+异步混合模式&lt;/strong&gt;：未来人机协作的工作范式。同步部分指工程师直接参与的高层决策、架构设计、关键逻辑制定；异步部分指 AI 代理自动完成的具体实现、测试、文档等工作。Scott 强调，&amp;ldquo;任何需要你参与的环节你都同步介入，纯执行的部分则可以异步交给 AI&amp;rdquo;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.youtube.com/watch?v=MmKkNmnoEvw"&gt;A Cheeky Pint with Cognition CEO Scott Wu&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Stripe&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-08-27&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>AI优先与零公交因子的风险</title><link>https://linguista.cn/curated/henrinotes_2025_p4/ai-first-zero-bus-factor-risk/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/ai-first-zero-bus-factor-risk/</guid><description>&lt;h1 id="ai优先与零公交因子的风险"&gt;AI优先与零公交因子的风险&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文深入分析了生成式AI时代&amp;quot;公交因子&amp;quot;概念的根本性变化。随着ChatGPT等工具的普及，越来越多的开发者采用&amp;quot;AI优先&amp;quot;的工作方式，导致项目知识掌握者可能为零。这种现象带来了严重的知识断层、维护困境和安全风险，亟需行业重新审视AI辅助开发的边界与责任。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先回顾了公交因子的历史演变，指出这一指标长期以来用于衡量项目的知识分布风险。在最坏情况下，公交因子为1，即唯一的知识掌握者离开会导致项目无法维护。为应对这一风险，人类社会建立了完整的知识传承体系，包括内部培训、文档编写、视频教程等多种机制。&lt;/p&gt;
&lt;p&gt;然而，2022年11月ChatGPT的发布标志着这一格局的彻底改变。三年后的今天，&amp;ldquo;AI优先&amp;quot;理念逐渐成型，越来越多的开发者开始依赖大语言模型生成代码，甚至将整个项目的开发外包给AI。这种趋势导致团队成员主动或被动放弃对代码库的深度理解，形成了&amp;quot;零公交因子&amp;quot;的危险局面。&lt;/p&gt;
&lt;p&gt;作者进一步阐述了AI生成代码带来的维护困境。即使AI生成的代码质量较高，团队成员也难以快速掌握其原理和细节。传统的导师制度和文档支持体系逐渐消失，开发者只能依赖自己解读不完美系统产出的能力。在这种环境下，修复bug、添加新功能、修补安全漏洞都变得异常困难，因为没有任何人真正了解代码的来龙去脉。&lt;/p&gt;
&lt;p&gt;最后，文章从安全角度警示了这一趋势的风险。当用户将个人文件、信用卡信息、隐私数据上传到无人知晓其构建原理的软件时，数据安全和隐私保障变得极为脆弱。这不仅是技术问题，更是整个行业需要面对的责任与伦理挑战。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;公交因子&lt;/strong&gt;：衡量项目知识分布的指标，指有多少关键人员离开后项目就无法维护。传统软件工程中，公交因子的最低值是1，而在AI优先时代可能降为0，意味着无人真正掌握项目知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI优先&lt;/strong&gt;：并非让人类退居第二，而是让人类在知识掌握上彻底消失的开发理念。开发者依赖AI生成函数、特性甚至完整项目，主动放弃对代码的深入理解，导致知识断层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随性编程&lt;/strong&gt;：指在AI辅助下，开发者不关心代码实现细节，仅依赖AI生成代码的工作方式。这种方式减少了人工参与和知识积累，使项目维护和升级面临极高风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识传承体系&lt;/strong&gt;：包括内部讲座、文档、视频教程、交接、演示等传统知识分享机制。在AI主导开发的时代，这些体系逐渐被边缘化，加剧了零公交因子问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全责任断层&lt;/strong&gt;：当AI生成的代码出现安全漏洞或隐私问题时，由于无人理解代码原理，责任认定和问题修复都变得极其困难，用户数据安全面临严峻挑战。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.mindflash.org/coding/ai/ai-and-the-bus-factor-of-0-1608"&gt;AI First and the Bus Factor of 0&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;MindFlash&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>为什么大语言模型无法真正构建软件</title><link>https://linguista.cn/curated/henrinotes_2025_p3/why-llms-cant-really-build-software/</link><pubDate>Sun, 17 Aug 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p3/why-llms-cant-really-build-software/</guid><description>&lt;h1 id="为什么大语言模型无法真正构建软件"&gt;为什么大语言模型无法真正构建软件&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者丰富的软件工程师面试经验，深入分析了大语言模型在软件开发领域的现状与局限。虽然LLM在代码生成方面表现出色，但缺乏人类工程师最核心的能力——构建和维护清晰的心智模型。这使得LLM在面对复杂、非线性的问题时，难以像人类一样有效地迭代和解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先阐述了软件工程师的核心工作循环，即从理解需求、编写代码、构建代码行为的心智模型，到识别差异并持续修正的完整过程。作者强调，优秀工程师的关键在于能够持续维护清晰的心智模型，并在测试失败时做出合理判断。&lt;/p&gt;
&lt;p&gt;接着，文章分析了LLM的能力与局限。虽然LLM能够生成代码、运行测试、使用调试工具，但它们无法维护清晰的心智模型。当测试失败时，LLM往往无法判断是代码还是测试有问题，只能猜测如何修复，甚至会选择推倒重来而非有针对性地调整。&lt;/p&gt;
&lt;p&gt;最后，作者探讨了LLM未来的可能性。人类在解决问题时能够灵活管理上下文，在全局与局部之间自由切换，而当前LLM存在新近性偏见和幻觉等问题。虽然业界正在尝试为模型增加记忆能力，但LLM仍无法真正理解全局，也无法像人类一样判断是该修改代码还是需求。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;心智模型&lt;/strong&gt;：这是软件工程师最核心的能力，包括对需求的理解和对代码实际行为的把握。工程师通过不断构建和维护清晰的心智模型，能够在复杂系统中准确判断问题所在并做出合理调整。LLM缺乏这种能力，容易混淆自己生成的代码与实际需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求-实现-验证-修正循环&lt;/strong&gt;：这是软件工程师的核心工作流程。从理解需求、编写代码、构建对代码行为的心智模型，到识别差异并持续修正，这是一个不断迭代的非线性过程。LLM在这个循环中只能完成部分环节，缺乏对全局的理解和判断能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文管理&lt;/strong&gt;：人类在解决问题时能够灵活管理上下文，可以暂时搁置细节专注于当前问题，也能在全局与局部之间自由切换。而当前LLM存在新近性偏见，更关注最近输入的信息，容易忽略前文重要内容，也无法像人类一样避免信息过载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新近性偏见与幻觉&lt;/strong&gt;：这是LLM面临的两个主要问题。新近性偏见使模型更关注最近输入的信息，幻觉则让模型凭空编造不存在的细节。这些问题限制了LLM在复杂任务中的表现，使其难以准确维护足够的上下文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人机协作&lt;/strong&gt;：尽管LLM存在局限，但它们在快速生成代码片段、合成文档、处理简单明确需求等方面仍然很有价值。现阶段，工程师必须承担起确保需求清晰、代码正确的责任，主导权仍掌握在工程师手中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://zed.dev/blog/why-llms-cant-build-software"&gt;Why LLMs Can&amp;rsquo;t Really Build Software&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Zed Blog 团队&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>专有技术困境与AI代码生成</title><link>https://linguista.cn/static/ai-know-how-dilemma/</link><pubDate>Thu, 03 Jul 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/static/ai-know-how-dilemma/</guid><description>深入探讨 AI 在软件工程中的“专有技术困境”。尽管 AI 擅长处理可编码的事实知识，但在涉及经验、直觉和情境理解的复杂任务中，其局限性暴露无遗。本分析通过交互式图表，揭示了 AI 代码生成中存在的复合错误累积、安全漏洞风险以及领域性能衰减等核心问题，并对比了人类专家与 AI 在知识处理机制上的本质差异。</description></item><item><title>软件工程师职位数量跌至五年新低</title><link>https://linguista.cn/curated/henrinotes-2025_p2/software-engineering-jobs-five-year-low/</link><pubDate>Sat, 22 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025_p2/software-engineering-jobs-five-year-low/</guid><description>&lt;h1 id="软件工程师职位数量跌至五年新低"&gt;软件工程师职位数量跌至五年新低&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于Indeed网站的数据分析，揭示了软件工程师职位数量已跌至五年新低的现状。数据显示，当前职位数量较2022年中期峰值下降65%，与2020年疫情中期水平相当。作者从利率变化、行业反应、AI工具影响等多维度分析原因，并对软件开发行业的未来发展趋势提出见解。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先通过详实的数据展示了软件开发职位市场的严峻现状。Indeed的数据显示，自2020年1月以来，软件开发职位数量下降至65%，相比2022年中期峰值减少了3.5倍。国际市场对比表明，美国和加拿大呈现相似的下降趋势，而澳大利亚是唯一一个职位数量未低于2020年水平的国家。更值得注意的是，与整体职位市场相比，软件开发职位的下降幅度远超其他行业。&lt;/p&gt;
&lt;p&gt;在原因分析部分，作者提出了三个核心因素。利率上升导致风险投资环境恶化，直接影响科技初创公司的招聘能力；科技行业对经济变化的反应过度剧烈，2022年的招聘高峰后迅速转向收缩；而AI工具的普及可能正在改变传统的开发模式，一些公司采取观望态度，暂停招聘以评估AI对生产力的实际影响。&lt;/p&gt;
&lt;p&gt;关于未来展望，作者既担忧又审慎乐观。小型团队如Linear和Bluesky的高效运作证明了精简团队的可行性，AI工具可能进一步提升开发效率。尽管行业可能出现停滞甚至萎缩，但软件开发在各行各业仍存在巨大商业机会。AI工具的普及甚至可能为开发人员创造新的机会，如优化和维护AI生成的代码。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;职位数量的结构性变化&lt;/strong&gt;：软件开发职位的下降并非周期性波动，而是结构性变化。相比2020年整体职位增长10%，软件开发职位却减少35%，这表明该行业正在经历根本性转型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI工具的替代效应&lt;/strong&gt;：大语言模型在编程领域的应用可能提高开发效率，但同时也可能减少对传统软件工程师的需求。公司暂停招聘以评估AI工具的实际效果，这种观望态度本身就反映了市场的不确定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精简团队的崛起&lt;/strong&gt;：Linear和Bluesky等案例证明，5-10人的小型团队利用AI工具可以完成以往需要更大团队才能完成的工作。这种模式可能成为未来的主流，重塑软件开发的组织形态。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://blog.pragmaticengineer.com/software-engineer-jobs-five-year-low/"&gt;Software engineering job openings hit five-year low&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Gergely Orosz&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件工程师应避免的十个行为</title><link>https://linguista.cn/curated/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</guid><description>&lt;h1 id="软件工程师应避免的十个行为"&gt;软件工程师应避免的十个行为&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;作者 Hoon Wee 基于五年以上的软件工程经验，分享了十个开发者应当避免的行为模式。这些经验涵盖了对代码质量的理解、开发流程的把控、职业心态的调整等多个维度，旨在帮助软件工程师摆脱常见误区，成长为更成熟的问题解决者。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以资深工程师的视角展开论述，首先指出了完美主义的陷阱——完美的代码并不存在，软件开发本质上是迭代的过程，专业能力体现在&amp;quot;足够好&amp;quot;而非&amp;quot;完美&amp;quot;。作者进一步强调重构应当融入日常开发流程，而非作为事后的额外请求，这体现了对工程质量的持续关注。&lt;/p&gt;
&lt;p&gt;在技术实践层面，作者重新定义了&amp;quot;遗留代码&amp;quot;的概念——它并非指旧代码，而是指缺乏测试的代码。这一观点揭示了可测试性与可维护性之间的本质联系。同时，作者警示不要盲目推崇函数式编程或遵循所谓的&amp;quot;最佳实践&amp;quot;，编程范式的选择应当基于具体场景和上下文判断，而非教条式套用。&lt;/p&gt;
&lt;p&gt;文章后半部分转向开发者工作方式和职业心态的探讨。作者反对独自挣扎解决问题，倡导利用团队智慧和现有方案；提醒在追求&amp;quot;心流&amp;quot;状态时保持自我觉察，建议采用番茄工作法避免倦怠。最后，作者强调了身体健康的重要性，并鼓励开发者保持对编程本身的热爱，从&amp;quot;码农&amp;quot;升级为用代码解决问题的&amp;quot;软件工程师&amp;quot;，以应对未来 AI 对简单编码工作的潜在替代。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;遗留代码的本质&lt;/strong&gt;：传统观点认为遗留代码等同于陈旧代码，但作者指出真正的定义是&amp;quot;没有测试的代码&amp;quot;。缺乏测试的代码无法安全重构，也无法维护；相反，即使技术栈较老（如 Next.js v10），只要测试覆盖良好，代码仍然具备可维护性。这一观点重新定义了代码质量的评判标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文驱动的技术选择&lt;/strong&gt;：函数式编程、清洁架构、SOLID 原则、TDD 等都是有力的工具，但没有放之四海而皆准的&amp;quot;最佳实践&amp;quot;。在 Clojure 或 Python 等语言中，TDD 可能并非必要；在 Flutter UI 层中，过度函数式化可能损害性能。成熟工程师的标志在于根据具体情境做出合理判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从编码者到问题解决者&lt;/strong&gt;：AI 时代正在重新定义软件开发者的价值。单纯写代码的能力（&amp;ldquo;码农&amp;rdquo;）面临被替代的风险，而运用代码解决实际问题的能力（&amp;ldquo;软件工程师&amp;rdquo;）将更加稀缺。这一转变要求开发者超越技术本身，关注业务价值和问题本质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://favtutor.com/articles/donts-for-software-engineer/"&gt;Things You Should Never Do As A Software Engineer&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Hoon Wee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>那些听起来不错但几乎行不通的系统设计想法</title><link>https://linguista.cn/curated/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</guid><description>&lt;h1 id="那些听起来不错但几乎行不通的系统设计想法"&gt;那些听起来不错但几乎行不通的系统设计想法&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程中常见的八种&amp;quot;听起来不错但几乎行不通&amp;quot;的系统设计想法，包括可插拔架构、API设计、过度抽象、异步编程、访问控制、数据同步、跨平台设计和原生逃逸机制。作者基于丰富的工程经验指出，这些想法在实际操作中往往引入不必要的复杂性和风险，建议开发者基于第一性原理解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇点明了写作背景：在软件工程实践中，许多看似简单可行的系统设计想法，在实际操作中却往往以失败告终。作者强调，工程不仅是技术问题，更涉及社会学因素，许多失败的教训源于经验不足。&lt;/p&gt;
&lt;p&gt;文章主体部分详细列举并分析了八种常见的设计陷阱。每种想法都看似合理——比如&amp;quot;让它可插拔&amp;quot;以便后续替换实现、&amp;ldquo;添加一个API&amp;quot;将产品扩展为平台、&amp;ldquo;再抽象一次&amp;quot;来解决复杂性问题。然而，作者通过具体案例指出，可插拔性需要同时开发两种实现才能保证API行为的完整性，API的维护成本往往被低估，过早的抽象会导致代码冗余。&lt;/p&gt;
&lt;p&gt;进一步的分析揭示了异步编程在框架之外可能引发难以复现的错误，访问控制如果稍后添加往往需要重写整个系统，数据同步在语义化和事务性场景中极其复杂，跨平台设计最终需要构建类似操作系统的抽象层，而原生逃逸机制会破坏框架内部状态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可插拔架构的陷阱&lt;/strong&gt;：真正的可插拔性要求在设计初期就同时开发多种实现，因为API的行为不仅包括文档定义，还包括实际运行中的各种边界情况和副作用。如果只设计一种实现，后续替换几乎无法无缝进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API的平台化误区&lt;/strong&gt;：许多产品成功后试图通过API扩展为平台，但API需要在兼容性和功能之间不断权衡，维护成本巨大。同时，开发者往往高估了第三方对API的需求，实际使用率通常远低于预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过度抽象的代价&lt;/strong&gt;：虽然&amp;quot;所有问题都可以通过增加一层间接性来解决&amp;rdquo;，但过早引入的抽象往往永远不会被真正使用，反而增加了代码冗余和维护负担。Windows NT中就有大量这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程的双刃剑&lt;/strong&gt;：异步编程在理论上的效率优势在实践中可能被难以复现的错误和数据损坏问题所抵消，特别是在框架之外的场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性的不可后置性&lt;/strong&gt;：访问控制和安全性必须在设计初期就考虑，后续添加往往面临重写整个系统的挑战。安全不是可以&amp;quot;稍后添加&amp;quot;的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据同步的复杂性&lt;/strong&gt;：即使在理想化的语义化和事务性数据存储中，同步也充满挑战，更不用说涉及非结构化数据或数据转换的场景。这是分布式系统中最难的问题之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨平台的抽象陷阱&lt;/strong&gt;：跨平台设计看似简单，但随着功能复杂化，往往需要构建类似操作系统的抽象层，这个抽象层本身会成为巨大的维护负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生逃逸的隐患&lt;/strong&gt;：框架提供的&amp;quot;逃逸到原生&amp;quot;机制虽然看似提供了灵活性，但往往会破坏框架的内部状态，导致难以维护和调试的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://hardcoresoftware.learningbyshipping.com/p/225-systems-ideas-that-sound-good?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;225. Systems Ideas that Sound Good But Almost Never Work—&amp;ldquo;Let&amp;rsquo;s just…&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Steven Sinofsky&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>长期软件开发的思考与建议</title><link>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/long-term-software-development-guidance/</guid><description>&lt;h1 id="长期软件开发的思考与建议"&gt;长期软件开发的思考与建议&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者为荷兰选举委员会开发开源投票统计软件 Abacus 的实践经验，系统性地总结了长期软件开发的核心理念与方法。作者指出，与现今通过 CI/CD 持续迭代的软件服务不同，核电站、选举系统、心脏起搏器等领域的软件需要在未来数十年内保持稳定运行。文章从 Mastodon 社区收集了大量反馈，提炼出关于依赖管理、复杂性控制、测试策略、文档规范、团队建设等15个方面的实用建议，为需要长期维护的软件项目提供了全面的指导框架。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者受荷兰选举委员会邀请反思其开源投票统计软件为切入点，指出了长期软件开发与现代敏捷开发模式的本质差异。现今大多数软件作为服务提供，可以通过持续部署和持续集成来修复问题，但某些关键领域如核电站控制系统、选举软件、医疗设备等，要求软件在几十年内保持稳定运行，任何变更都需要提前规划和公告。&lt;/p&gt;
&lt;p&gt;作者在 Mastodon 社区征求意见后，收集了大量来自实践者的反馈，将这些经验整理成系统性的建议。文章的核心论点是：长期软件开发需要与传统开发模式完全不同的思维方式和技术选择。作者特别强调了依赖管理的重要性，将软件依赖分为四个层次——基础编程语言、紧密耦合的框架、数据库和可替换的辅助库，并指出越底层的依赖选择越关键。&lt;/p&gt;
&lt;p&gt;在复杂性管理方面，作者提出&amp;quot;复杂性是软件开发的最终敌人&amp;quot;这一核心观点，通过图表展示了代码复杂性与代码量之间的关系，强调必须在早期主动进行重构和简化。文章还详细讨论了测试的价值、文档的重要性、团队管理的策略以及开源的优势，并推荐了《编程实践》《人月神话》《软件设计哲学》等经典著作，最后引用了莱曼的软件进化法则来支持其观点。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;依赖层次结构&lt;/strong&gt;：软件依赖可分为四个层级——基础编程语言（最底层，最难更换）、紧密耦合的框架（深度集成，更换成本高）、数据库（数据存储核心，迁移复杂）和可替换的辅助库（最上层，相对容易替换）。长期软件开发必须格外关注底层依赖的选择，因为技术质量、使用者基数、维护状况、资金来源等因素都会影响依赖的长期稳定性。依赖可能随时间出现版本漂移、被废弃、甚至遭到劫持，因此建立定期健康检查机制至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;：复杂性会随着代码量的增加而自然增长，如果缺乏主动管理，系统最终会变得无法维护。作者强调必须在开发早期就持续进行重构和简化，而不是推迟到&amp;quot;以后&amp;quot;。简单的代码虽然可能不够&amp;quot;聪明&amp;quot;或不够高效，但更容易理解、调试和维护。在长期项目中，为了避免过早优化是万恶之源，应该优先选择编写无趣但简单的代码，而不是追求高性能但复杂的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lindy 效应与技术选择&lt;/strong&gt;：Lindy 效应指出，技术的预期寿命与其当前年龄成正比——一项技术已经存在的时间越长，它可能继续存在的时间也越长。这意味着在长期软件开发中，应该优先选择经过时间考验的技术，而不是被 LinkedIn 或社交媒体炒作的新技术。新技术的风险在于其长期价值尚未得到验证，可能在关键时刻失去支持或出现无法预见的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试的战略价值&lt;/strong&gt;：测试不仅是质量保证手段，更是长期维护的安全网。当依赖频繁变化时，完善的测试套件可以确保系统仍能正常工作；当项目暂停后重新启动时，测试可以帮助新开发者快速理解系统行为；当需要重构或移除依赖时，测试提供了变更的信心。测试的价值在长期项目中会呈指数级增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档与知识传承&lt;/strong&gt;：长期软件开发必须重视特定文档的需求，包括架构设计文档、API 文档、运维手册等。代码注释应该解释&amp;quot;为什么&amp;quot;而不是&amp;quot;做什么&amp;quot;，提交信息应该记录变更的原因。团队还需要建立内部 wiki 或知识库，记录决策过程、架构演进和故障经验。这些文档在原始开发者离开后，成为知识传承的关键载体。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://berthub.eu/articles/posts/on-long-term-software-development/"&gt;On Long Term Software Development&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Bert Hubert&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>开发者必读的计算机科学论文</title><link>https://linguista.cn/curated/henrinotes_2025_p4/essential-computer-science-papers-developers/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes_2025_p4/essential-computer-science-papers-developers/</guid><description>&lt;h1 id="开发者必读的计算机科学论文"&gt;开发者必读的计算机科学论文&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;阅读计算机科学论文是提升开发者技术素养的重要途径。本文系统推荐了涵盖系统设计、分布式系统、数据存储、现代基础设施等领域的经典论文，这些论文构成了现代软件工程的理论基础，能够帮助开发者深入理解核心技术概念，培养批判性思维，并把握技术发展趋势。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本文按照不同技术领域分类推荐了16篇经典计算机科学论文。在系统设计与编程基础方面，推荐了Parnas的模块化设计论文、Hoare的程序验证数学基础、Moseley和Marks的复杂性管理理论，以及Hughes的函数式编程重要性论述。这些论文为现代软件架构、微服务设计和API开发奠定了理论基础。&lt;/p&gt;
&lt;p&gt;分布式系统部分重点介绍了Lamport关于时间与事件顺序的开创性工作，这是理解分布式数据库、区块链和云计算的基石。同时还推荐了反驳分布式系统旧观念的论文，以及Google文件系统等现代分布式存储系统的研究成果。&lt;/p&gt;
&lt;p&gt;数据存储与处理类别涵盖了关系型数据库的理论基础、Amazon DynamoDB的设计架构、Google Bigtable分布式存储系统，以及MapReduce编程模型等大数据处理框架的基础性工作。这些论文帮助开发者理解现代数据系统的设计原理和权衡考量。&lt;/p&gt;
&lt;p&gt;现代基础设施部分介绍了Kafka分布式消息系统、Facebook的Memcache扩展实践，以及中本聪的比特币白皮书。最后推荐了关于内存架构的经典论文，帮助开发者理解硬件架构对程序性能的影响。文章还提供了额外的论文资源平台和阅读方法指导。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;模块化设计原则&lt;/strong&gt;：Parnas的论文确立了模块化作为提高系统灵活性、可理解性和减少开发时间的核心机制，其思想直接影响现代软件架构、微服务设计和API开发实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统中的时间与顺序&lt;/strong&gt;：Lamport的论文提出了分布式系统中事件顺序的数学模型，引入了逻辑时钟和不完全排序概念，为分布式数据库一致性、区块链共识机制和云计算协调服务奠定了理论基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关系型数据模型&lt;/strong&gt;：Codd提出的关系模型解决了当时数据库系统的数据独立性和操作一致性问题，成为所有SQL数据库的理论基础，影响至今仍在持续。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程范式&lt;/strong&gt;：Hughes的论文阐述了函数式编程在模块化、组合性和推理性方面的优势，帮助开发者理解其在现代软件开发中的益处，特别是在并发处理和不可变数据结构方面的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存层次结构&lt;/strong&gt;：Drepper的论文详细解释了CPU缓存、内存层次结构及其对程序性能的影响，帮助开发者理解硬件架构与软件性能之间的关系，写出更高效的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://newsletter.techworld-with-milan.com/p/computer-science-papers-every-developer"&gt;Computer Science Papers Every Developer Should Read&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Milan&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-18&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>强工程师与弱工程师的能力差异分析</title><link>https://linguista.cn/curated/henrinotes-2025-p1/strong-vs-weak-engineers-differences/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/strong-vs-weak-engineers-differences/</guid><description>&lt;h1 id="强工程师与弱工程师的能力差异分析"&gt;强工程师与弱工程师的能力差异分析&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程领域中强工程师与弱工程师之间的本质区别。作者指出，强工程师的核心能力在于能够完成其他工程师无法完成的任务，这种能力差异在某些情况下甚至是无限的。文章详细分析了三类工程师的特征，并提供了与弱工程师合作的实用建议。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先明确了强工程师与弱工程师的核心区别在于能力范围的不同。强工程师能够胜任复杂项目的交付、解决跨多个服务的竞态条件等困难bug、对遗留代码库进行有意义的改进，以及进行需要大规模架构重构的变更。这种能力不是线性的差异，而是质的飞跃——有些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。&lt;/p&gt;
&lt;p&gt;普通工程师构成了团队的稳定力量。他们能够解决大部分bug、完成大多数JIRA任务，并在大多数情况下解决开发环境问题。虽然他们可能不追求在下一个晋升周期中表现出色，但他们是团队日常运作的中坚力量。&lt;/p&gt;
&lt;p&gt;弱工程师则面临严重的能力缺失。即使是正常到容易的任务对他们来说也过于困难。在高级职位中，弱工程师通过频繁的单向配对编程来完成任务，依赖其他工程师的帮助。他们还可能在工作讨论中表现得非常活跃，以掩盖其实际工作能力不足。这种现象对团队的影响尤为严重，尤其是对初级工程师的时间和精力占用。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;能力无限差异&lt;/strong&gt;：强工程师与弱工程师之间的差异不是程度上的，而是种类上的。某些任务对强工程师来说是可行的，但对弱工程师来说则完全无法完成。这种差异在某些情况下是无限的，意味着弱工程师可能永远无法完成某些任务，无论投入多少时间和努力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单向配对编程&lt;/strong&gt;：弱工程师的主要生存策略之一。他们频繁地与其他工程师进行&amp;quot;配对编程&amp;quot;，但实际上这种配对是单向的——其他工程师在为他们完成工作。这种策略掩盖了弱工程师的实际能力不足，但同时也占用了团队中其他工程师的宝贵时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;善意与边界保护&lt;/strong&gt;：文章建议在与弱工程师合作时保持善意，理解他们可能面临的个人困难，但同时也要保护自己的时间和团队的时间。可以通过快速回应而不是提供完整解决方案来避免时间不对称的帮助，并确保管理层了解情况，防止弱工程师利用初级工程师。&lt;/p&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.seangoedecke.com/weak-engineers/"&gt;What can strong engineers do that weak engineers can&amp;rsquo;t?&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Sean Goedecke&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-04&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>数据库模拟的局限性与真实数据库测试的重要性</title><link>https://linguista.cn/curated/henrinotes-2025-p1/database-mocks-vs-real-testing/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/curated/henrinotes-2025-p1/database-mocks-vs-real-testing/</guid><description>&lt;h1 id="数据库模拟的局限性与真实数据库测试的重要性"&gt;数据库模拟的局限性与真实数据库测试的重要性&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;在软件开发过程中，使用数据库模拟进行测试看似快速便捷，但实际上可能掩盖许多潜在问题。本文通过对比分析，阐述了真实数据库测试在发现数据完整性问题、适应架构变化、处理并发场景等方面的显著优势，并提出了分层测试策略，帮助开发团队在测试效率与质量之间取得平衡。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先指出了一个常见现象：许多开发团队在测试中倾向于使用数据库模拟，因为这种方式执行速度快且实现简单。然而，作者通过实际案例对比，揭示了这种做法的风险。当使用模拟的用户仓库进行测试时，虽然能够验证基本的创建逻辑，但却无法暴露数据完整性、约束条件等在生产环境中可能出现的问题。&lt;/p&gt;
&lt;p&gt;文章进一步强调了真实数据库测试在&amp;quot;面向未来&amp;quot;方面的重要性。随着应用程序的演进，数据库架构不可避免地会发生变化，包括新的验证规则、数据类型调整、时间戳精度修改等。这些变化往往会引发意想不到的错误，而模拟数据库根本无法捕捉到这些问题。使用真实数据库进行测试，可以让团队在开发阶段就发现这些隐患，避免在生产环境中浪费宝贵的调试时间。&lt;/p&gt;
&lt;p&gt;在测试策略部分，作者提出了分层测试的理念。应用程序通常包含多个层次，如控制器、服务、仓库等，每一层都有其特定的职责。对于数据访问层和服务层，应该使用真实数据库进行测试，以确保外键约束、引用完整性、事务处理等核心机制的正确性。而对于控制器层，则可以适当地模拟服务调用，专注于测试请求处理和响应编排。这种分层策略既保证了关键逻辑的测试覆盖，又维持了合理的测试执行速度。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据完整性验证&lt;/strong&gt;：模拟数据库无法真实反映生产环境中的约束条件和完整性规则。真实数据库测试能够揭示外键冲突、唯一性约束、级联删除等潜在问题，这些在模拟环境中往往被忽略，但会在生产环境中造成严重后果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构演进的适应性&lt;/strong&gt;：应用程序的数据库架构会随着业务需求的变化而演进。新特性的添加、验证规则的调整、数据类型的修改都可能引入错误。真实数据库测试能够及时捕捉这些由架构变化引起的问题，而模拟数据库则无法反映这些变化，导致测试与实际运行环境脱节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发与事务处理&lt;/strong&gt;：在涉及账户余额、交易总额等业务场景时，并发访问、隔离级别和聚合计算的正确性至关重要。真实数据库测试可以暴露并发竞争条件、死锁、事务隔离等问题，确保业务逻辑的准确性和数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层测试策略&lt;/strong&gt;：应用程序的架构分层为测试策略提供了清晰的指导。数据访问层需要真实数据库来验证SQL执行和数据库交互；服务层需要真实数据库来检验业务逻辑与数据的交互；控制器层则可以通过模拟服务来专注于请求处理和响应编排的测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试效率与质量的平衡&lt;/strong&gt;：真实数据库测试确实会增加测试执行时间，但这种投入在保证应用程序质量方面是值得的。对于复杂的数据关系、性能敏感的场景以及关键业务逻辑，真实数据库测试是不可或缺的。模拟仍然适用于验证高层次的编排逻辑和外部服务交互，两者结合使用才能构建全面的测试体系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.shayon.dev/post/2024/365/database-mocks-are-just-not-worth-it/"&gt;Database mocks are just not worth it&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Shayon Mukherjee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年12月30日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/paul_graham/essays_zh/progbot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/paul_graham/essays_zh/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/paul_graham/essays_en/progbot/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;
&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;
&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;
&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;
&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;
&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;
&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;
&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;
&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;
&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;
&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;
&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description></item></channel></rss>