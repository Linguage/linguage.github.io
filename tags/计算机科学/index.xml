<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机科学 on Linguista</title>
    <link>https://linguage.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link>
    <description>Recent content in 计算机科学 on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 22 Apr 2024 18:08:18 +0800</lastBuildDate>
    <atom:link href="https://linguage.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>评论：《黑客与画家》</title>
      <link>https://linguage.github.io/post/comment_hacker_painter/</link>
      <pubDate>Mon, 22 Apr 2024 18:08:18 +0800</pubDate>
      <guid>https://linguage.github.io/post/comment_hacker_painter/</guid>
      <description>&lt;p&gt;本文将围绕Paul Graham的《黑客与画家》展开评论，探讨黑客与艺术家的共通之处，以及黑客在工程科学等领域中所面临的现实困境与生存之道。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lisp的不同之处</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/diff/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/diff/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/diff/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/diff.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/diff.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/diff.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;lisp的不同之处&#34;&gt;Lisp的不同之处&lt;/h1&gt;&#xA;&lt;p&gt;2001年12月（修订于2002年5月）&lt;/p&gt;&#xA;&lt;p&gt;（本文是回应LL1邮件列表上一些问题而产生的。现在已收录在《书呆子的复仇》中。）&lt;/p&gt;&#xA;&lt;p&gt;当McCarthy在1950年代末设计Lisp时，它是对现有语言的彻底突破，其中最重要的是Fortran。&lt;/p&gt;&#xA;&lt;p&gt;Lisp体现了九个新思想：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;条件语句。&lt;/strong&gt; 条件语句是if-then-else结构。现在我们认为这是理所当然的。它们是McCarthy在开发Lisp过程中发明的。（当时的Fortran只有条件goto，紧密基于底层硬件的分支指令。）McCarthy是Algol委员会的成员，他将条件语句引入Algol，随后传播到大多数其他语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;函数类型。&lt;/strong&gt; 在Lisp中，函数是一等对象——它们是一种数据类型，就像整数、字符串等，并且有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;递归。&lt;/strong&gt; 递归当然在Lisp之前作为数学概念存在，但Lisp是第一个支持递归的编程语言。（可以说这在使函数成为一等对象中是隐含的。）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;变量的新概念。&lt;/strong&gt; 在Lisp中，所有变量实际上都是指针。具有类型的是值，而不是变量，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;垃圾回收。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;由表达式组成的程序。&lt;/strong&gt; Lisp程序是表达式的树，每个表达式都返回一个值。（在某些Lisp中，表达式可以返回多个值。）这与Fortran和大多数后续语言形成对比，后者区分表达式和语句。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在Fortran中有这种区别是很自然的，因为（在输入格式为打孔卡的语言中不足为奇）该语言是面向行的。你不能嵌套语句。因此，虽然你需要表达式来进行数学运算，但让其他任何东西返回值都没有意义，因为不可能有任何东西在等待它。&lt;/p&gt;&#xA;&lt;p&gt;随着块结构语言的出现，这个限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们的后代。&lt;/p&gt;&#xA;&lt;p&gt;当一种语言完全由表达式构成时，你可以任意组合表达式。你可以说（使用Arc语法）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(if foo (= x 1) (= x 2))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(= x (if foo 1 2))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;符号类型。&lt;/strong&gt; 符号与字符串的不同在于你可以通过比较指针来测试相等性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;使用符号树表示代码的记号。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;整个语言始终可用。&lt;/strong&gt; 读取时间、编译时间和运行时间之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp用作扩展语言的基础，如在Emacs等程序中；在运行时读取使程序能够使用s表达式进行通信，这个想法最近被重新发明为XML。&lt;/p&gt;&#xA;&lt;p&gt;当Lisp首次发明时，所有这些想法都与当时的普通编程实践相去甚远，后者主要由1950年代末可用的硬件决定。&lt;/p&gt;&#xA;&lt;p&gt;随着时间的推移，体现在一系列流行语言中的默认语言逐渐向Lisp演变。1-5现在已经广泛传播。6开始出现在主流中。Python具有7的一种形式，尽管似乎没有任何语法支持它。8（与9一起）是使Lisp宏成为可能的特性，到目前为止仍然是Lisp独有的，也许是因为（a）它需要那些括号，或者同样糟糕的东西，（b）如果你添加这最后的力量增量，你不能再声称发明了一种新语言，而只是设计了一种新的Lisp方言 ;-)&lt;/p&gt;&#xA;&lt;p&gt;虽然对当今的程序员有用，但通过描述Lisp与其他语言采用的随机权宜之计的差异来描述它是很奇怪的。这可能不是McCarthy对它的看法。Lisp不是设计来修复Fortran中的错误；它更像是试图将计算公理化的副产品。&lt;/p&gt;&#xA;&lt;p&gt;相关链接：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lisp的根源</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/rootsoflisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/rootsoflisp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/rootsoflisp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/rootsoflisp.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/rootsoflisp.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/rootsoflisp.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;lisp的根源&#34;&gt;Lisp的根源&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（我写这篇文章是为了帮助自己准确理解McCarthy的发现。你不需要知道这些东西来用Lisp编程，但对于想要理解Lisp本质的人来说——无论是从起源还是语义核心的角度——这应该是有帮助的。Lisp拥有这样一个核心是其区别于其他语言的特征之一，也是为什么与其他语言不同，Lisp有方言的原因。）&lt;/p&gt;&#xA;&lt;p&gt;1960年，John McCarthy发表了一篇非凡的论文，他在编程领域做了类似于欧几里得对几何学所做的事情。他展示了，给定一些简单的操作符和函数表示法，如何构建一个完整的编程语言。他称这种语言为Lisp，即&amp;quot;列表处理&amp;quot;，因为他的一个关键想法是使用一种称为列表的简单数据结构来同时表示代码和数据。&lt;/p&gt;&#xA;&lt;p&gt;值得理解McCarthy的发现，不仅作为计算机史上的里程碑，而且作为我们时代编程发展方向的模型。在我看来，迄今为止有两个真正干净、一致的编程模型：C模型和Lisp模型。这两个模型似乎像是高地，之间是沼泽般的低地。随着计算机变得越来越强大，正在开发的新语言一直在稳步向Lisp模型移动。过去20年来，新编程语言的一个流行配方是采用C计算模型，然后零散地添加从Lisp模型中提取的部分，如运行时类型和垃圾收集。&lt;/p&gt;&#xA;&lt;p&gt;在这篇文章中，我将尝试用最简单的术语解释McCarthy的发现。重点不仅仅是了解某人40年前想出的一个有趣的理论结果，而是展示语言的发展方向。Lisp的不寻常之处——事实上，Lisp的定义性特征——是它可以用自身来编写。要理解McCarthy的意思，我们将追溯他的步骤，将他的数学表示法转换为运行的Common Lisp代码。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;注意：这似乎是一篇较长文章的介绍或摘要。全文可能作为PostScript文件提供，在原始来源中链接为&amp;quot;Complete Article (Postscript)&amp;quot;。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What Made Lisp Different&lt;/li&gt;&#xA;&lt;li&gt;The Code&lt;/li&gt;&#xA;&lt;li&gt;中文翻译&lt;/li&gt;&#xA;&lt;li&gt;日语翻译&lt;/li&gt;&#xA;&lt;li&gt;葡萄牙语翻译&lt;/li&gt;&#xA;&lt;li&gt;韩语翻译&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>关于语言设计的五个问题</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/langdes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/langdes/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/langdes/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/langdes.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/langdes.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/langdes.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;关于语言设计的五个问题&#34;&gt;关于语言设计的五个问题&lt;/h1&gt;&#xA;&lt;p&gt;2001年5月&lt;/p&gt;&#xA;&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-编程语言是为人设计的&#34;&gt;1. 编程语言是为人设计的。&lt;/h2&gt;&#xA;&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;&#xA;&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;&#xA;&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;&#xA;&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;&#xA;&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-为自己和你的朋友设计&#34;&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;&#xA;&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;&#xA;&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;&#xA;&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;&#xA;&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;&#xA;&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-给程序员尽可能多的控制权&#34;&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;&#xA;&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;&#xA;&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-追求简洁&#34;&gt;4. 追求简洁。&lt;/h2&gt;&#xA;&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;&#xA;&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;&#xA;&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;5-承认黑客的本质&#34;&gt;5. 承认黑客的本质。&lt;/h2&gt;&#xA;&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开放性问题&#34;&gt;开放性问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-如何组织大型库&#34;&gt;1. 如何组织大型库？&lt;/h3&gt;&#xA;&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-人们真的害怕前缀语法吗&#34;&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;&#xA;&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-基于服务器的软件需要什么&#34;&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;&#xA;&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;&#xA;&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;&#xA;&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;&#xA;&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-还有什么新的抽象有待发现&#34;&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;&#xA;&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;</description>
    </item>
    <item>
      <title>黑客与画家</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/hp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/hp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/hp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div&#xA;  class=&#34;link-card group relative my-3 w-full overflow-hidden rounded-xl border border-[var(--lc-border,rgba(15,23,42,0.12))] bg-[var(--lc-bg,var(--card-bg,var(--surface,#ffffff))))] transition-shadow duration-150 hover:shadow-[var(--lc-shadow-hover,0_14px_30px_-18px_rgba(15,23,42,0.35))]&#34;&#xA;  data-url=&#34;https://www.paulgraham.com/hp.html&#34;&#xA;&gt;&#xA;  &lt;a&#xA;    class=&#34;link-card__fallback block px-4 py-3 text-sm font-medium text-[var(--lc-url,var(--link-color,#0e6a85))] underline-offset-4 hover:underline&#34;&#xA;    href=&#34;https://www.paulgraham.com/hp.html&#34;&#xA;    target=&#34;_blank&#34;&#xA;    rel=&#34;noopener&#34;&#xA;  &gt;&#xA;    https://www.paulgraham.com/hp.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;黑客与画家&#34;&gt;黑客与画家&lt;/h1&gt;&#xA;&lt;p&gt;2003年5月&lt;/p&gt;&#xA;&lt;p&gt;（本文源于在哈佛大学的一次客座讲座，该讲座整合了之前在东北大学的一次演讲。）&lt;/p&gt;&#xA;&lt;p&gt;当我完成计算机科学研究生学业后，我去艺术学院学习绘画。很多人似乎对感兴趣于计算机的人也会对绘画感兴趣感到惊讶。他们似乎认为黑客和绘画是截然不同的工作类型——黑客工作是冷酷、精确、有条理的，而绘画则是某种原始冲动的狂热表达。&lt;/p&gt;&#xA;&lt;p&gt;这两种形象都是错误的。黑客和绘画有很多共同之处。事实上，在我认识的所有不同类型的人中，黑客和画家是最相似的。&lt;/p&gt;&#xA;&lt;p&gt;黑客和画家的共同点是他们都是创造者。与作曲家、建筑师和作家一样，黑客和画家试图做的是创造好东西。他们本身并不是在做研究，尽管在试图创造好东西的过程中他们发现了一些新技术，那就更好了。&lt;/p&gt;&#xA;&lt;p&gt;我从来不喜欢&amp;quot;计算机科学&amp;quot;这个词。我不喜欢它的主要原因是没有这样的东西。计算机科学是一堆关系不大的领域的拼凑，因历史的偶然而被组合在一起，就像南斯拉夫一样。一端是实际上是数学家的人，但他们称自己做的事情为计算机科学，以便获得DARPA资助。中间是从事类似计算机自然史工作的人——例如研究通过网络路由数据的算法行为。然后在另一端是黑客，他们试图编写有趣的软件，对他们来说，计算机只是表达媒介，就像对建筑师来说是混凝土，对画家来说是颜料一样。这就像是数学家、物理学家和建筑师都必须在同一个系里一样。&lt;/p&gt;&#xA;&lt;p&gt;有时黑客所做的事情被称为&amp;quot;软件工程&amp;quot;，但这个术语同样具有误导性。优秀的软件设计师并不比建筑师更像工程师。建筑和工程之间的界限并没有明确界定，但它是存在的。它在于做什么和如何做之间：建筑师决定做什么，工程师弄清楚如何做。&lt;/p&gt;&#xA;&lt;p&gt;做什么和如何做不应过于分离。如果你试图在不知道如何做的情况下决定做什么，那是在自找麻烦。但黑客工作绝不仅仅是决定如何实现某个规范。在最好的情况下，它是创建规范——但事实证明做到这一点的最好方法是实现它。&lt;/p&gt;&#xA;&lt;p&gt;也许有一天&amp;quot;计算机科学&amp;quot;会像南斯拉夫一样被分解成其组成部分。这可能是件好事。特别是如果这意味着我自己的领域——黑客的独立。&lt;/p&gt;&#xA;&lt;p&gt;将所有这些不同类型的工作捆绑在一个部门可能在行政上很方便，但在智力上是混乱的。这是我不喜欢&amp;quot;计算机科学&amp;quot;这个名字的另一个原因。可以说，中间的人在做类似实验科学的事情。但两端的人，黑客和数学家，实际上并不是在做科学。&lt;/p&gt;&#xA;&lt;p&gt;数学家似乎并不为此困扰。他们很高兴地开始证明定理，就像数学系的数学家一样，并且很快就会停止注意到他们工作的建筑外面写着&amp;quot;计算机科学&amp;quot;。但对黑客来说，这个标签是个问题。如果他们所做的事情被称为科学，这让他们觉得他们应该表现得科学。因此，大学和研究实验室里的黑客不做他们真正想做的事情，即设计美丽的软件，而是觉得他们应该写研究论文。&lt;/p&gt;&#xA;&lt;p&gt;在最好的情况下，论文只是一种形式。黑客编写很酷的软件，然后写一篇关于它的论文，论文就成为了软件所代表成就的代理。但这种不匹配经常导致问题。很容易从创造美丽的东西转向创造丑陋的东西，而这些东西更适合作为研究论文的题材。&lt;/p&gt;&#xA;&lt;p&gt;不幸的是，美丽的东西并不总是最好的论文主题。首先，研究必须是原创的——正如任何写过博士论文的人所知，确保你在探索未知领域的方法是占据一块没有人想要的地盘。其次，研究必须是实质性的——笨拙的系统会产生更丰富的论文，因为你可以写为了完成工作而必须克服的障碍。没有什么比从错误假设开始更能产生丰富的问题了。大多数人工智能都是这个规则的例子；如果你假设知识可以表示为谓词逻辑表达式的列表，其参数代表抽象概念，你将有很多论文要写关于如何使其工作。正如里奇·里卡多常说的：&amp;ldquo;露西，你有很多解释要做。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;创造美丽东西的方法往往是对现有事物进行微妙的调整，或者以稍新的方式组合现有的想法。这种工作很难在研究论文中传达。&lt;/p&gt;&#xA;&lt;p&gt;那么为什么大学和研究实验室继续用出版物来判断黑客呢？原因与&amp;quot;学术能力&amp;quot;用简单的标准化测试衡量，或者程序员的生产力用代码行数衡量是一样的。这些测试很容易应用，没有什么比一个勉强有效的简单测试更诱人的了。&lt;/p&gt;&#xA;&lt;p&gt;衡量黑客真正试图做的事情，设计美丽的软件，会困难得多。你需要良好的设计感来判断好的设计。人们识别好设计的能力与他们对自己能做到的信心之间没有任何相关性，除了可能是负相关。&lt;/p&gt;&#xA;&lt;p&gt;唯一的外部测试是时间。随着时间的推移，美丽的东西往往会繁荣，丑陋的东西往往会被抛弃。不幸的是，所涉及的时间可能比人类寿命还长。塞缪尔·约翰逊说，作家的声誉需要一百年才能收敛。你必须等待作家有影响力的朋友死去，然后他们所有的追随者都死去。&lt;/p&gt;&#xA;&lt;p&gt;我认为黑客只能接受自己声誉中有很大的随机成分。在这方面，他们与其他创造者没有什么不同。事实上，相比之下，他们是幸运的。时尚在黑客中的影响力远不如在绘画中那么大。&lt;/p&gt;&#xA;&lt;p&gt;有比被人误解你的作品更糟糕的事情。更危险的是你会自己误解你的作品。相关领域是你寻找想法的地方。如果你发现自己身处计算机科学系，自然会有一种诱惑，例如认为黑客是理论计算机科学理论的应用版本。我在研究生院的整个时间里，脑海中总有一种不安的感觉，觉得我应该知道更多理论，而且在期末考试后三周内忘记所有东西是非常疏忽的。&lt;/p&gt;&#xA;&lt;p&gt;现在我意识到我错了。黑客需要了解计算理论的程度，与画家需要了解颜料化学的程度差不多。你需要知道如何计算时间和空间复杂性以及图灵完备性。你可能还想记住至少状态机的概念，以防你不得不编写解析器或正则表达式库。事实上，画家必须记住的颜料化学知识比这多得多。&lt;/p&gt;&#xA;&lt;p&gt;我发现，最好的想法来源不是名字中有&amp;quot;计算机&amp;quot;一词的其他领域，而是创造者居住的其他领域。绘画比计算理论是更丰富的想法来源。&lt;/p&gt;&#xA;&lt;p&gt;例如，我在大学里学到的是，一个人应该在完全接触计算机之前在纸上完整地构思一个程序。我发现我不是这样编程的。我发现我喜欢坐在计算机前编程，而不是在纸上。更糟糕的是，我不是耐心地写出完整的程序并确保它是正确的，而是倾向于只是喷出完全没有希望的代码，然后逐渐把它塑造成形。我学到的是，调试是一种最后阶段，你捕捉打字错误和疏忽。按照我的工作方式，编程似乎就是由调试组成的。&lt;/p&gt;&#xA;&lt;p&gt;很长时间以来，我对此感觉很糟糕，就像我曾经因为小学时握铅笔的方式和他们教我的不一样而感到难过一样。如果我看过其他创造者，画家或建筑师，我会意识到我所做的事情有一个名字：素描。据我所知，他们在大学教我的编程方法完全是错的。你应该在编写程序时构思程序，就像作家、画家和建筑师所做的那样。&lt;/p&gt;&#xA;&lt;p&gt;意识到这一点对软件设计有实际意义。这意味着编程语言最重要的特性应该是可塑的。编程语言是用来思考程序的，而不是表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果人们真的像他们在大学教我的那样写程序，静态类型会是个好主意。但这不是我认识的任何黑客写程序的方式。我们需要一种让我们能够涂鸦、涂抹和弄脏的语言，而不是一种你必须用一杯类型平衡在膝盖上与严格的老婶婶编译器礼貌交谈的语言。&lt;/p&gt;&#xA;&lt;p&gt;既然我们在讨论静态类型，认同创造者将使我们免于困扰科学的另一个问题：数学嫉妒。科学界的每个人都秘密认为数学家比他们聪明。我认为数学家也相信这一点。无论如何，结果是科学家倾向于使他们的工作看起来尽可能数学化。在像物理学这样的领域，这可能不会造成太大伤害，但离自然科学越远，这个问题就越大。&lt;/p&gt;&#xA;&lt;p&gt;一页公式看起来非常令人印象深刻。（提示：为了更加令人印象深刻，使用希腊变量。）因此，有很大的诱惑去做你可以正式处理的问题，而不是那些重要的，比如说，重要的问题。&lt;/p&gt;&#xA;&lt;p&gt;如果黑客认同其他创造者，比如作家和画家，他们就不会感到诱惑去做这种事情。作家和画家不遭受数学嫉妒。他们觉得他们在做完全不相关的事情。我认为黑客也是如此。&lt;/p&gt;&#xA;&lt;p&gt;如果大学和研究实验室阻止黑客做他们想做的工作，也许他们的位置是在公司。不幸的是，大多数公司也不会让黑客做他们想做的事情。大学和研究实验室强迫黑客成为科学家，公司强迫他们成为工程师。&lt;/p&gt;&#xA;&lt;p&gt;我自己直到最近才发现这一点。当雅虎收购Viaweb时，他们问我想做什么。我从来不太喜欢商业方面，说我只想黑客。当我到雅虎时，我发现黑客对他们来说意味着实现软件，而不是设计它。程序员被视为技术人员，将产品经理的愿景（如果那算是的话）翻译成代码。&lt;/p&gt;&#xA;&lt;p&gt;这似乎是大公司的默认计划。他们这样做是因为它减少了结果的标准差。只有一小部分黑客能够真正设计软件，公司经营者很难挑选出这些人。因此，大多数公司不将软件的未来委托给一个才华横溢的黑客，而是设置成由委员会设计，黑客只实现设计。&lt;/p&gt;&#xA;&lt;p&gt;如果你想赚钱，记住这一点，因为这是创业公司获胜的原因之一。大公司希望减少设计结果的标准差，因为他们想避免灾难。但当你抑制波动时，你既失去了高点，也失去了低点。这对大公司来说不是问题，因为他们不是靠做出伟大的产品获胜的。大公司靠比其他大公司少些糟糕获胜。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你能找到一种方法与一家大公司进行设计战争，大到其软件是由产品经理设计的，他们将永远无法跟上你。不过，这些机会并不容易找到。很难让大公司参与设计战争，就像很难让城堡内的对手进行肉搏战一样。例如，编写一个比微软Word更好的文字处理器会很容易，但微软在其操作系统垄断的城堡内，即使你做到了，可能甚至不会注意到。&lt;/p&gt;&#xA;&lt;p&gt;进行设计战争的地方是新市场，在那里还没有人设法建立任何防御工事。在那里，你可以通过大胆的设计方法，以及让同样的人既设计又实现产品而大获全胜。微软自己一开始就是这样做的。苹果也是如此。惠普也是如此。我怀疑几乎所有成功的创业公司都是如此。&lt;/p&gt;&#xA;&lt;p&gt;所以构建伟大软件的一种方法是创办自己的创业公司。然而，这有两个问题。一是在创业公司，你必须做很多编程以外的事情。在Viaweb，如果我能有四分之一的时间黑客，我就觉得自己很幸运。我在其他四分之三的时间里不得不做的事情从乏味到可怕不等。我对此有一个基准，因为我曾经不得不离开董事会会议去补牙。我记得坐在牙医的椅子上，等待钻头，感觉就像在度假。&lt;/p&gt;&#xA;&lt;p&gt;创业公司的另一个问题是，赚钱的软件和有趣的软件之间没有太多重叠。编程语言写起来很有趣，微软的第一个产品确实是，但现在没有人会为编程语言付钱。如果你想赚钱，你往往被迫从事对任何人来说都太麻烦而无法免费解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;所有创造者都面临这个问题。价格由供求关系决定，对有趣工作的需求不如解决个人客户日常问题的需求多。在外百老汇戏剧中表演不如在贸易展上穿着大猩猩服装在别人的展位工作赚钱。写小说不如为垃圾处理器写广告文案赚钱。黑客编程语言不如想办法将某公司的遗留数据库连接到他们的Web服务器赚钱。&lt;/p&gt;&#xA;&lt;p&gt;我认为这个问题的答案，在软件的情况下，是一个几乎所有创造者都知道的概念：日常工作。这个词始于音乐家，他们晚上表演。更一般地说，这意味着你做一种工作是为了钱，做另一种是为了爱。&lt;/p&gt;&#xA;&lt;p&gt;几乎所有创造者在职业生涯早期都有日常工作。画家和作家尤其如此。如果你幸运，你可以找到与你真正工作密切相关的日常工作。音乐家似乎经常在唱片店工作。从事某种编程语言或操作系统工作的黑客同样可能能够使用它获得日常工作。[1]&lt;/p&gt;&#xA;&lt;p&gt;当我说答案是为黑客提供日常工作，并在业余时间从事美丽软件工作时，我并不是在提出一个新想法。这就是开源黑客的全部内容。我要说的是，开源可能是正确的模式，因为它已经被所有其他创造者独立证实。&lt;/p&gt;&#xA;&lt;p&gt;任何雇主都不愿让黑客从事开源项目，这让我感到惊讶。在Viaweb，我们不愿意雇佣任何不这样做的人。当我们面试程序员时，我们主要关心的是他们在业余时间编写什么样的软件。除非你热爱它，否则你不能真正做好任何事情，如果你热爱黑客，你将不可避免地从事自己的项目。[2]&lt;/p&gt;&#xA;&lt;p&gt;因为黑客是创造者而不是科学家，寻找隐喻的正确地方不是科学，而是其他类型的创造者。绘画还能教给我们什么关于黑客的知识？&lt;/p&gt;&#xA;&lt;p&gt;我们可以从绘画的例子中学到的一件事，或者至少确认的是，如何学习黑客。你主要通过做来学习绘画。黑客也是如此。大多数黑客不是通过上大学编程课程来学习黑客的。他们在十三岁时通过编写自己的程序来学习黑客。即使在大学课程中，你也主要通过黑客来学习黑客。[3]&lt;/p&gt;&#xA;&lt;p&gt;因为画家在他们身后留下了作品的痕迹，你可以看着他们通过做来学习。如果你按时间顺序看一位画家的作品，你会发现每幅画都建立在以前画中学到的东西的基础上。当一幅画中有某个东西效果很好时，你通常可以在一些早期绘画中以较小的形式找到它的版本1。&lt;/p&gt;&#xA;&lt;p&gt;我认为大多数创造者都是这样工作的。作家和建筑师似乎也是如此。也许黑客应该更像画家，定期从头开始，而不是继续在一个项目上工作多年，并试图将他们以后的想法作为修订纳入其中。&lt;/p&gt;&#xA;&lt;p&gt;黑客通过做来学习黑客这一事实是黑客与科学不同的另一个标志。科学家不是通过做科学来学习科学，而是通过做实验和解决问题集。科学家开始做的工作是完美的，在这个意义上说，他们只是试图重现别人已经为他们做过的工作。最终，他们达到可以做原创工作的地步。而黑客从一开始就在做原创工作；只是非常糟糕。所以黑客从原创开始，然后变好，科学家从好开始，然后变原创。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
