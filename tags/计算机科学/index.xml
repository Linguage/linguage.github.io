<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机科学 on Linguista</title><link>https://linguista.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link><description>Recent content in 计算机科学 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 04 Feb 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>棋盘游戏中的科学——从简单规则到复杂行为</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/board-games-simple-rules-complex-science/</link><pubDate>Tue, 04 Feb 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/board-games-simple-rules-complex-science/</guid><description>&lt;h1 id="棋盘游戏中的科学从简单规则到复杂行为"&gt;棋盘游戏中的科学——从简单规则到复杂行为&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文由 Quanta Magazine 撰稿人 Ben Brubaker 撰写，探讨了棋盘游戏与数学、计算机科学之间的深层联系。文章指出，从国际象棋到围棋，从康威的生命游戏到 AlphaGo，简单规则如何衍生出复杂行为，这一特性使游戏成为数学研究和人工智能发展的重要试验场，同时也揭示了 AI 在现实世界应用中面临的挑战。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从棋盘游戏与科学研究的联系切入，指出棋盘游戏的复杂行为往往源自简单的规则。不同类型的棋盘游戏展现出不同层次的复杂性，其中&amp;quot;组合游戏&amp;quot;（如国际象棋和围棋）在简单规则与复杂策略之间达到了微妙的平衡，玩家可以在数年的实践中不断发现新策略。&lt;/p&gt;
&lt;p&gt;文章进一步阐述了游戏与数学、计算机科学研究的交叉领域。对于数学家而言，游戏不仅是消遣，更是研究的重要组成部分；理论计算机科学家通过量化游戏难度，将其与传统计算问题联系起来；人工智能研究者则利用游戏作为测试问题解决系统的试验场。&lt;/p&gt;
&lt;p&gt;文章通过多个经典案例深入分析，包括康威的生命游戏、组合游戏与计算复杂性的关系，以及 AI 在游戏中的里程碑事件。最后，文章讨论了游戏研究对现实世界的启示，指出尽管现实远比游戏复杂，但游戏研究为解决现实问题提供了重要的方法论基础和灵感来源。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单规则与复杂行为&lt;/strong&gt;：棋盘游戏的核心魅力在于简单规则能够产生复杂行为。国际象棋和围棋的规则可以在几分钟内掌握，但其策略空间几乎是无穷的。这一现象与数学和科学中的许多问题具有相似性，使得游戏成为研究复杂性的理想模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;康威的生命游戏&lt;/strong&gt;：约翰·康威发明的生命游戏是简单规则产生复杂行为的经典范例。它通过简单的细胞演化规则在网格上模拟出极其多样的行为模式。尽管已发明超过 50 年，研究人员仍在不断发现新的模式，展示了简单系统中蕴含的无限可能性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工智能与游戏的共同进化&lt;/strong&gt;：AI 系统在游戏领域取得了标志性突破——1990 年代超越人类国际象棋选手，2016 年 AlphaGo 击败围棋世界冠军。AlphaGo 通过学习人类专家的游戏模式并进行自我对战来掌握围棋，展示了基于学习的方法在 AI 发展中的巨大潜力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合游戏与计算复杂性&lt;/strong&gt;：计算机科学家通过研究组合游戏探讨计算复杂性理论，揭示了游戏内在难度与计算问题之间的深层关联。这一研究方向将游戏从娱乐领域提升为理解计算本质的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从游戏到现实的鸿沟&lt;/strong&gt;：尽管 AI 在游戏环境中表现出色，但现实世界远比任何游戏复杂。强化学习在游戏中的成功依赖于明确的奖励信号，而现实中这种信号往往不可用。研究人员正在探索基于好奇心驱动的 AI 系统，试图弥合游戏与现实之间的差距。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mailchi.mp/quantamagazine.org/why-colliding-particles-reveal-reality-4866024?e=49edf04b1c"&gt;Silly Games Can Make Serious Science&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Ben Brubaker&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未明确提及&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>图灵机从理论到实践</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/turing-machines-theory-to-practice/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/turing-machines-theory-to-practice/</guid><description>&lt;h1 id="图灵机从理论到实践"&gt;图灵机从理论到实践&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;图灵机是现代计算机科学的理论基石，由艾伦·图灵于1936年提出，用于回答希尔伯特提出的决策问题。本文全面介绍了图灵机的组成结构、工作原理，深入探讨了可计算性理论、停机问题以及图灵完备性等核心概念。文章不仅提供了理论解释，还包含大量示例程序和交互式开发环境，帮助读者从实践角度理解这一基础理论模型。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从1928年希尔伯特提出的决策问题切入，阐述了图灵机产生的时代背景和科学意义。图灵和丘奇分别在1936年证明了不存在一种通用算法可以判断任意数学命题的真伪，这一结论催生了图灵机这一抽象计算模型。&lt;/p&gt;
&lt;p&gt;在定义部分，文章详细介绍了图灵机的四个核心组成部分：无限长的磁带用于存储数据、读写头用于读取和写入符号、程序控制机器行为、状态跟踪当前执行位置。基本指令包括打印符号、左右移动磁头、停止运行和状态跳转，这些看似简单的操作却构成了通用计算的基础。&lt;/p&gt;
&lt;p&gt;关于可计算性，文章解释了如果一个算法能够从给定输入产生预期输出，则该问题是可计算的。通过二进制与十进制的对比，展示了不同表示方法对程序复杂度的影响。停机问题部分揭示了一个深刻的数学真理：不存在通用算法能够判断任意程序在给定输入上是否会终止，这是计算理论的根本性限制。&lt;/p&gt;
&lt;p&gt;图灵完备性概念指出，任何能够模拟图灵机的系统都具有相同的计算能力。文章最后将理论与现实联系，说明现代计算机的寄存器架构本质上与图灵机等价，并提供了在线开发环境供读者实践。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图灵机的组成&lt;/strong&gt;：图灵机由磁带、读写头、程序和状态四部分组成。磁带是无限长的存储介质，读写头可以在磁带上移动并读写符号，程序定义了机器的行为规则，状态则记录当前执行位置。这种看似简单的装置却能模拟任何算法过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;停机问题&lt;/strong&gt;：这是计算理论中最著名的不可计算问题。它问是否存在一个程序能够判断另一个程序在特定输入上是否会停止运行。图灵通过自指论证证明了这样的判断程序不存在，这一结论划定了计算的理论边界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图灵完备性&lt;/strong&gt;：如果一个系统能够模拟图灵机，它就是图灵完备的。这意味着该系统具有通用计算能力，能够执行任何可计算的算法。现代编程语言、计算机架构都属于图灵完备系统，这一概念为计算能力提供了统一的衡量标准。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://samwho.dev/turing-machines/"&gt;Turing Machines&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;SamWho&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>计算机科学中的好点子</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/good-ideas-computer-science/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/good-ideas-computer-science/</guid><description>&lt;h1 id="计算机科学中的好点子"&gt;计算机科学中的好点子&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了计算机科学中那些被普遍认为是好的想法，这些想法不被争论且广泛有效。作者指出，虽然程序员们喜欢争论他们喜欢的技术，但这些争论掩盖了计算机科学的胜利。文章列举了从16世纪到20世纪70年代的多个好点子，包括二进制数、可编程计算机、布尔代数、浮点数、数组、哈希表、调用栈、结构化编程、虚拟地址空间、内存保护、版本控制、公钥加密和图形用户界面等，并解释了为何到1974年我们已经拥有了大部分现代计算的基础。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从程序员喜欢争论技术偏好的现象入手，指出这些争论往往掩盖了计算机科学的真正成就。作者在Twitter上提出了一个问题：计算机科学中有哪些想法被普遍认为是好的？这些想法的特点是不被争论、广泛且有效，重点在于想法本身而非具体实现。&lt;/p&gt;
&lt;p&gt;文章的主体部分按照时间顺序列举了从1500年代到1973年的好点子。这些想法构成了现代计算的基础，从数学基础（二进制数、布尔代数）到硬件架构（可编程计算机、浮点数），再到编程概念（数组、哈希表、调用栈、结构化编程），最后到系统级概念（进程、虚拟地址空间、内存保护、版本控制、公钥加密）和用户界面（图形用户界面）。&lt;/p&gt;
&lt;p&gt;作者还特意说明了哪些想法没有被包括在内，如垃圾回收（因为性能考虑）、数据库（因为不是单一想法）、面向对象编程（因为存在争议）等，并解释了排除的原因。文章最后指出，到1974年，我们已经拥有了大部分现代计算的基础，今天的基础与1974年相同，并希望在未来50年内有新的好想法被普遍认为是好的。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;普遍认为的好想法&lt;/strong&gt;：这些想法的特点是不被争论、广泛且有效，重点在于想法本身而非具体实现。例如，Unix包含许多好想法，但不在列表中，因为它是一个实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间分布&lt;/strong&gt;：从文章列举的好点子来看，绝大多数出现在1974年之前。这表明到20世纪70年代中期，现代计算的基础已经基本建立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有意排除的想法&lt;/strong&gt;：垃圾回收因为性能问题被排除，数据库因为不是单一想法而被排除，面向对象编程因为存在争议而被排除。这些排除反映了作者对&amp;quot;普遍认为是好的&amp;quot;这一标准的坚持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;历史连续性&lt;/strong&gt;：从二进制数（1500年代）到图形用户界面（1973年），这些好点子展示了计算机科学发展的连续性和累积性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未来展望&lt;/strong&gt;：作者希望在未来50年内有新的好想法被普遍认为是好的，这表明计算机科学仍然有发展和创新的空间。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://danielchasehooper.com/posts/good-ideas-in-cs/"&gt;Good Ideas in Computer Science&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Daniel Chase Hooper&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>开发者必读的计算机科学论文</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/essential-computer-science-papers-developers/</link><pubDate>Sat, 18 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/essential-computer-science-papers-developers/</guid><description>&lt;h1 id="开发者必读的计算机科学论文"&gt;开发者必读的计算机科学论文&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;阅读计算机科学论文是提升开发者技术素养的重要途径。本文系统推荐了涵盖系统设计、分布式系统、数据存储、现代基础设施等领域的经典论文，这些论文构成了现代软件工程的理论基础，能够帮助开发者深入理解核心技术概念，培养批判性思维，并把握技术发展趋势。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;本文按照不同技术领域分类推荐了16篇经典计算机科学论文。在系统设计与编程基础方面，推荐了Parnas的模块化设计论文、Hoare的程序验证数学基础、Moseley和Marks的复杂性管理理论，以及Hughes的函数式编程重要性论述。这些论文为现代软件架构、微服务设计和API开发奠定了理论基础。&lt;/p&gt;
&lt;p&gt;分布式系统部分重点介绍了Lamport关于时间与事件顺序的开创性工作，这是理解分布式数据库、区块链和云计算的基石。同时还推荐了反驳分布式系统旧观念的论文，以及Google文件系统等现代分布式存储系统的研究成果。&lt;/p&gt;
&lt;p&gt;数据存储与处理类别涵盖了关系型数据库的理论基础、Amazon DynamoDB的设计架构、Google Bigtable分布式存储系统，以及MapReduce编程模型等大数据处理框架的基础性工作。这些论文帮助开发者理解现代数据系统的设计原理和权衡考量。&lt;/p&gt;
&lt;p&gt;现代基础设施部分介绍了Kafka分布式消息系统、Facebook的Memcache扩展实践，以及中本聪的比特币白皮书。最后推荐了关于内存架构的经典论文，帮助开发者理解硬件架构对程序性能的影响。文章还提供了额外的论文资源平台和阅读方法指导。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;模块化设计原则&lt;/strong&gt;：Parnas的论文确立了模块化作为提高系统灵活性、可理解性和减少开发时间的核心机制，其思想直接影响现代软件架构、微服务设计和API开发实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统中的时间与顺序&lt;/strong&gt;：Lamport的论文提出了分布式系统中事件顺序的数学模型，引入了逻辑时钟和不完全排序概念，为分布式数据库一致性、区块链共识机制和云计算协调服务奠定了理论基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关系型数据模型&lt;/strong&gt;：Codd提出的关系模型解决了当时数据库系统的数据独立性和操作一致性问题，成为所有SQL数据库的理论基础，影响至今仍在持续。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程范式&lt;/strong&gt;：Hughes的论文阐述了函数式编程在模块化、组合性和推理性方面的优势，帮助开发者理解其在现代软件开发中的益处，特别是在并发处理和不可变数据结构方面的价值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存层次结构&lt;/strong&gt;：Drepper的论文详细解释了CPU缓存、内存层次结构及其对程序性能的影响，帮助开发者理解硬件架构与软件性能之间的关系，写出更高效的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://newsletter.techworld-with-milan.com/p/computer-science-papers-every-developer"&gt;Computer Science Papers Every Developer Should Read&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Milan&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-18&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>唐纳德克努斯与TeX系统的传奇历程</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/donald-knuth-tex-legend-yakshave/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/donald-knuth-tex-legend-yakshave/</guid><description>&lt;h1 id="唐纳德克努斯与tex系统的传奇历程"&gt;唐纳德克努斯与TeX系统的传奇历程&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文详细介绍了计算机科学先驱唐纳德克努斯与TeX排版系统的传奇故事。克努斯为排版其巨著《计算机编程艺术》第二版而发明TeX，在实现过程中展现了极致的&amp;quot;牦牛剃须&amp;quot;精神——为解决核心问题而创造了一系列相关工具和系统，包括WEB编程语言、文学编程范式、布局算法、Computer Modern字体、METAFONT字体描述语言等。文章不仅展现了克努斯在计算机科学多个领域的卓越成就，也探讨了TeX系统如何通过社区贡献持续演进，成为至今仍在广泛使用的排版系统。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以幽默的方式称克努斯为&amp;quot;牦牛剃须刀的守护神&amp;quot;，这一称呼源于他实现的TeX系统——一个完美且运行时间长的&amp;quot;牦牛剃须刀&amp;quot;项目。文章首先介绍了TeX的起源：克努斯在1970年代准备出版《计算机编程艺术》第二版时，对当时的排版质量极为不满，决定发明自己的排版系统。这套著作本身就是一个巨大的&amp;quot;牦牛剃须&amp;quot;项目，克努斯甚至为说明程序而发明了自己的计算机MIX和MIX汇编语言。&lt;/p&gt;
&lt;p&gt;文章的核心部分详细列举了TeX实现过程中的八重&amp;quot;牦牛剃须&amp;quot;：克努斯不仅发明了WEB编程语言（可转换为PASCAL），还创造了文学编程范式；他不仅实现了文本布局功能，还与Michael Plass共同提出了全新的布局算法；他不仅需要字体，还亲自设计了Computer Modern字体系列；他不仅需要字体创作工具，还编写了METAFONT字体描述语言及解释器；他提出了独特的版本控制方案，并避免了使用它；他实现了DVI输出格式。每一层都是为解决上一层问题而创造的新的&amp;quot;牦牛剃须&amp;quot;。&lt;/p&gt;
&lt;p&gt;文章后半部分探讨了社区对TeX的贡献和延续。Leslie Lamport创建了LaTeX，分离了表示和内容；后来又出现了ConTeXt等变体。面对现代技术需求（Unicode、现代字体格式、PDF输出等），社区创建了专门的TeX解释器，如pdflatex、xelatex、lualatex等。文章最后强调，TeX系统凝聚了克努斯多年的工作和知识，其特殊性质使其难以被简单替代，这也正是克努斯作为&amp;quot;牦牛剃须刀守护神&amp;quot;的真正意义。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;牦牛剃须&lt;/strong&gt;：源自Unix文化，比喻为了解决一个看似简单的问题，最终需要完成一系列先决任务，层层递进，仿佛要剃须得先养牦牛。克努斯的TeX项目是这一概念的极致体现——为排版一本书而创造了编程语言、编程范式、布局算法、字体、字体工具、输出格式等完整生态系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文学编程&lt;/strong&gt;：克努斯发明的编程范式，强调代码应像文学作品一样组织，便于人类阅读理解。WEB语言将Pascal代码和TeX文档混合在一起，源代码既是可执行程序又是技术文档，这一思想深刻影响了后来的文档生成工具和 literate programming 实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本控制哲学&lt;/strong&gt;：克努斯为TeX设计了独特的版本编号方案——从版本3开始，每次更新逼近π的下一个数字位（当前为3.141592653），以此象征TeX已趋于稳定，不再有重大修改。这一创意性的版本控制方式体现了克努斯对TeX完成度的自信，也避免了使用者陷入版本升级的困扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社区剃须&lt;/strong&gt;：文章提出的概念，指社区在开源项目基础上的持续&amp;quot;牦牛剃须&amp;quot;工作。TeX原版用WEB编写，社区将其转换为C；TeX只支持ASCII，社区创建支持UTF-8的XeTeX和LuaTeX；TeX输出DVI，社区实现直接输出PDF的pdfTeX。这些延续性工作让TeX在保持核心稳定的同时适应了现代技术需求。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://yakshav.es/the-patron-saint-of-yakshaves/"&gt;唐纳德克努斯——牦牛剃须的守护神&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;唐纳德克努斯&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-11&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>蒙日安培方程在技术爆炸中的应用前景</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/monge-ampere-equation-technology-applications/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/monge-ampere-equation-technology-applications/</guid><description>&lt;h1 id="蒙日安培方程在技术爆炸中的应用前景"&gt;蒙日安培方程在技术爆炸中的应用前景&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文由数学家顾险峰撰写，深入探讨了蒙日安培方程这一经典数学理论在现代科技革命中的重要作用。文章从历史脉络出发，梳理了法国、俄罗斯、中国三个数学传统对该理论的贡献，重点阐述了蒙日安培方程在最优传输理论中的核心地位。作者结合2019年澳大利亚Kiama学术会议的见闻，展望了该方程在医学图像、无线通信、汽车工业和深度学习等前沿领域的应用前景，认为这一艰深的数学理论正迎来前所未有的普及和发展机遇。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;蒙日安培方程是完全非线性、退化椭圆型偏微分方程，在数学理论中以其高度的非线性和技巧性著称。文章从作者与丘成桐先生的交流谈起，回顾了这一理论从被忽视到备受重视的历程。自然界中的大多数几何问题本质上都是非线性的，蒙日安培方程与闵可夫斯基问题、Weyl问题、仿射几何以及几何光学中的反射曲面、折射透镜设计等问题密切相关。&lt;/p&gt;
&lt;p&gt;在最优传输理论中，当传输代价函数为欧式距离的平方时，存在Brenier势能函数满足蒙日安培方程。这一理论框架为我们理解和解决实际工程问题提供了强有力的数学工具。从历史维度看，法国数学家蒙日于1781年提出最优传输问题，俄罗斯数学家Kantorovich通过线性规划方法证明了解的存在性并获诺贝尔奖，而中国数学家在丘成桐先生带领下也在正则性理论方面做出了杰出贡献。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最优传输理论&lt;/strong&gt;：最优传输问题可直观理解为设计传输方案实现供需平衡且传输代价最小，其映射称为最优传输映射，总代价称为Wasserstein距离。这一理论不仅在数学理论中具有重要地位，更在现代工程应用中展现出巨大价值，从医学图像配准到深度生成模型的设计都离不开这一理论框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;蒙日安培方程的正则性理论&lt;/strong&gt;：这一理论关注解的光滑性质，对于理解模型的稳定性和收敛性具有重要意义。汪徐家院士等学者在Ma-Trudinger-Wang条件方面的工作，厘清了反射曲面设计、自由曲面透镜设计与球面上最优传输问题的等价性，为工程应用奠定了坚实的理论基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度学习与最优传输的结合&lt;/strong&gt;：自然数据可视为高维空间中低维流形上的概率分布，深度学习的核心就是学习流形结构。对抗生成模型中的判别器计算真实分布和生成分布之间的Wasserstein距离，生成器计算从隐空间白噪声到生成分布的传输映射。这一理论框架可以解释GAN模式崩溃的内在原因，提高训练稳定性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mp.weixin.qq.com/s/qf_lL4Wl5P9nAKv2fGklRQ"&gt;技术爆炸中的蒙日-安培方程&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;顾险峰&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2019年&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>计算机科学家如何重新定义数学证明</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/computer-scientists-reimagined-mathematical-proof/</link><pubDate>Tue, 07 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/computer-scientists-reimagined-mathematical-proof/</guid><description>&lt;h1 id="计算机科学家如何重新定义数学证明"&gt;计算机科学家如何重新定义数学证明&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文讲述了计算机科学家如何在过去几十年中重新定义数学证明的概念。传统的数学证明方法已有2000多年历史，依赖于逐步推理和验证。然而，随着计算机科学的发展，出现了交互式证明、零知识证明、概率可验证证明等创新方法。这些方法不仅改变了数学证明的面貌，还对密码学、网络安全、量子物理等领域产生了深远影响。文章还介绍了Curry-Howard对应关系，以及证明助手程序如何促进数学研究的合作与创新。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先介绍了传统数学证明的基本概念和历史背景。传统的数学证明依赖于数学家在舒适的椅子上思考，逐步撰写论证来发现新的真理。这种证明方法已经延续了2000多年，是数学研究的核心方法。&lt;/p&gt;
&lt;p&gt;接着，文章详细阐述了计算机科学如何改变这一传统范式。20世纪80年代，计算机科学家开始探索交互式证明的概念，这种方法允许验证者通过与提供解决方案的一方交互来验证问题的解决方案。与传统证明不同，交互式证明被证明比普通证明更强大，能够验证更复杂的问题。&lt;/p&gt;
&lt;p&gt;文章进一步介绍了零知识证明和概率可验证证明。零知识证明允许证明者证明某个陈述是正确的，而无需透露任何关于该陈述的信息，这在密码学和网络安全领域有重要应用。概率可验证证明则允许验证者只需检查证明的一小部分即可确信其正确性，大大提高了验证效率。&lt;/p&gt;
&lt;p&gt;文章还探讨了多证明者交互式证明和量子证明的概念。多证明者交互式证明涉及多个证明者之间的互动，可以验证更复杂的问题。量子证明结合了量子计算与交互式证明，能够验证任何可想象的计算结果。这些发现对数学和物理学中的许多问题产生了影响。&lt;/p&gt;
&lt;p&gt;最后，文章介绍了Curry-Howard对应关系，这是证明与计算机程序之间的精确等价关系。基于此关系开发的证明助手程序帮助数学家验证证明的正确性，促进了数学研究的合作与创新，使数学领域对非传统学术背景的研究者更加开放。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;交互式证明&lt;/strong&gt;：这是一种创新的证明方法，验证者通过与提供解决方案的一方进行互动来验证解决方案的有效性。类似于数学家之间的互动讨论，这种方法可以验证比传统证明更复杂的数学问题。交互式证明的概念是计算机科学对数学证明的重要贡献之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;零知识证明&lt;/strong&gt;：这是一种特殊的证明方法，证明者可以证明某个陈述是正确的，而无需透露任何关于该陈述的具体信息。这个概念在密码学和网络安全等领域有重要应用，因为它可以在不泄露敏感信息的情况下验证某些属性的真实性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概率可验证证明&lt;/strong&gt;：这种方法允许验证者只需检查证明的一小部分即可确信其正确性。通过随机抽样和概率验证，可以在保证高可信度的同时大大减少验证工作量，提高了验证效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多证明者交互式证明&lt;/strong&gt;：这种证明方法涉及多个证明者之间的互动，可以验证更复杂的问题。通过多个证明者之间的信息交换和协作，能够处理单证明者无法解决的复杂问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Curry-Howard对应&lt;/strong&gt;：这是证明与计算机程序之间的精确等价关系，表明数学证明和计算机程序在本质上是相同的。基于此关系开发的证明助手程序帮助数学家验证证明的正确性，促进了数学研究的合作与创新。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mailchi.mp/quantamagazine.org/why-colliding-particles-reveal-reality-4865899?e=49edf04b1c"&gt;How Computer Scientists Reimagined Mathematical Proof&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Ben Brubaker&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年10月4日&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>2024年AI对世界的颠覆性影响</title><link>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/ai-disrupting-world-2024-annual-review/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes-2025-p1/ai-disrupting-world-2024-annual-review/</guid><description>&lt;h1 id="2024年ai对世界的颠覆性影响"&gt;2024年AI对世界的颠覆性影响&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文是顾险峰教授对2024年人工智能发展的年终总结。文章从计算机科学、数学研究、艺术创作、工业应用和社会影响五个维度，系统梳理了AI在这一年中对世界带来的颠覆性变化，指出2024年是AI真正开始改变世界的关键一年，并展望了人类与AI共存的未来图景。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者在计算几何领域的深厚学术背景为出发点，结合2024年的亲身经历和观察，全面审视了人工智能对多个领域的冲击。在计算机科学层面，AI已能自动设计基本数据结构和算法，约70%的C++代码可由AI高效完成，这直接推动了计算机科学教育方向的转变——从底层编程训练转向更注重基础数学和物理素养的培养。&lt;/p&gt;
&lt;p&gt;在数学与科研领域，文章分析了生成模型和逻辑推理模型的进展与局限。基于概率统计的生成模型因数据耗尽面临Scaling Law失效的困境，而基于思维链的ChatGPT 4o模型虽在数学问题求解上取得突破，但对复杂问题仍力有不逮。AI在基础数学研究中更多扮演辅助角色，无法替代人类的抽象思维和理论创新能力。&lt;/p&gt;
&lt;p&gt;文章还融入了作者游历意大利的艺术感悟，从米开朗基罗的大卫雕塑反思数字几何处理对传统艺术的影响。在工业领域，作者关注到中国新能源汽车产业对CAD/CAE等工业软件的强劲需求，以及其团队在黎曼-罗赫理论计算框架上的研究进展。最后，文章以对社会影响的深层思考作结，指出AI正在淘汰部分职业群体，人类智力的尊严正退守到基础科学理论领域。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AI重塑计算机科学教育&lt;/strong&gt;：AI已具备自动设计链表、树、图等基本数据结构和算法的能力，70%的常规编程工作可由AI完成。这意味着未来计算机教育的重心将从编程技能训练转向数学和物理等基础学科素养，工程师需要具备跨学科知识以胜任顶层算法设计和系统优化等高层次工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成模型的瓶颈与推理模型的崛起&lt;/strong&gt;：基于概率统计的生成模型已近乎耗尽可用数据，Scaling Law面临失效。与此同时，基于思维链的逻辑推理模型（如ChatGPT 4o）展现出在数学问题求解等结构化任务中的新潜力，预示着AI发展路径可能从&amp;quot;数据驱动&amp;quot;转向&amp;quot;推理驱动&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI对工业软件的推动&lt;/strong&gt;：中国新能源汽车产业的蓬勃发展催生了对计算机辅助几何设计（CAD）和计算机辅助工程（CAE）等工业软件的迫切需求。作者团队在黎曼-罗赫理论计算框架方面的突破，展示了基础数学研究如何转化为工业软件创新的驱动力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人类智力尊严的退守&lt;/strong&gt;：AI正在快速取代艺术家和底层软件开发人员的工作，同时引发知识产权溯源等复杂问题。作者认为，人类智力的独特价值正在退守到基础科学理论领域，这是目前AI尚无法触及的最后堡垒，未来需要建立相应的法律和制度框架来保障人类权益。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2025年展望与不确定性&lt;/strong&gt;：文章预判2025年世界格局将更加动荡，计算机科学将迎来颠覆式革命。人类与AI的关系充满不确定性，如何在技术飞速发展中保持人文价值和社会公平，将成为未来的核心议题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://mp.weixin.qq.com/s/EzPCYwtSyD4llb8-ttE4rQ"&gt;2024年终总结：AI开始颠覆世界&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;顾险峰&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024-12-31&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>评论：《黑客与画家》</title><link>https://linguista.cn/post/comment_hacker_painter/</link><pubDate>Mon, 22 Apr 2024 18:08:18 +0800</pubDate><guid>https://linguista.cn/post/comment_hacker_painter/</guid><description>&lt;p&gt;本文将围绕Paul Graham的《黑客与画家》展开评论，探讨黑客与艺术家的共通之处，以及黑客在工程科学等领域中所面临的现实困境与生存之道。&lt;/p&gt;</description></item><item><title>黑客与画家</title><link>https://linguista.cn/person/paul_graham/essays_zh/hp/</link><pubDate>Thu, 01 May 2003 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/hp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/hp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="黑客与画家"&gt;黑客与画家&lt;/h1&gt;
&lt;p&gt;2003年5月&lt;/p&gt;
&lt;p&gt;（本文源于在哈佛大学的一次客座讲座，该讲座整合了之前在东北大学的一次演讲。）&lt;/p&gt;
&lt;p&gt;当我完成计算机科学研究生学业后，我去艺术学院学习绘画。很多人似乎对感兴趣于计算机的人也会对绘画感兴趣感到惊讶。他们似乎认为黑客和绘画是截然不同的工作类型——黑客工作是冷酷、精确、有条理的，而绘画则是某种原始冲动的狂热表达。&lt;/p&gt;
&lt;p&gt;这两种形象都是错误的。黑客和绘画有很多共同之处。事实上，在我认识的所有不同类型的人中，黑客和画家是最相似的。&lt;/p&gt;
&lt;p&gt;黑客和画家的共同点是他们都是创造者。与作曲家、建筑师和作家一样，黑客和画家试图做的是创造好东西。他们本身并不是在做研究，尽管在试图创造好东西的过程中他们发现了一些新技术，那就更好了。&lt;/p&gt;
&lt;p&gt;我从来不喜欢&amp;quot;计算机科学&amp;quot;这个词。我不喜欢它的主要原因是没有这样的东西。计算机科学是一堆关系不大的领域的拼凑，因历史的偶然而被组合在一起，就像南斯拉夫一样。一端是实际上是数学家的人，但他们称自己做的事情为计算机科学，以便获得DARPA资助。中间是从事类似计算机自然史工作的人——例如研究通过网络路由数据的算法行为。然后在另一端是黑客，他们试图编写有趣的软件，对他们来说，计算机只是表达媒介，就像对建筑师来说是混凝土，对画家来说是颜料一样。这就像是数学家、物理学家和建筑师都必须在同一个系里一样。&lt;/p&gt;
&lt;p&gt;有时黑客所做的事情被称为&amp;quot;软件工程&amp;quot;，但这个术语同样具有误导性。优秀的软件设计师并不比建筑师更像工程师。建筑和工程之间的界限并没有明确界定，但它是存在的。它在于做什么和如何做之间：建筑师决定做什么，工程师弄清楚如何做。&lt;/p&gt;
&lt;p&gt;做什么和如何做不应过于分离。如果你试图在不知道如何做的情况下决定做什么，那是在自找麻烦。但黑客工作绝不仅仅是决定如何实现某个规范。在最好的情况下，它是创建规范——但事实证明做到这一点的最好方法是实现它。&lt;/p&gt;
&lt;p&gt;也许有一天&amp;quot;计算机科学&amp;quot;会像南斯拉夫一样被分解成其组成部分。这可能是件好事。特别是如果这意味着我自己的领域——黑客的独立。&lt;/p&gt;
&lt;p&gt;将所有这些不同类型的工作捆绑在一个部门可能在行政上很方便，但在智力上是混乱的。这是我不喜欢&amp;quot;计算机科学&amp;quot;这个名字的另一个原因。可以说，中间的人在做类似实验科学的事情。但两端的人，黑客和数学家，实际上并不是在做科学。&lt;/p&gt;
&lt;p&gt;数学家似乎并不为此困扰。他们很高兴地开始证明定理，就像数学系的数学家一样，并且很快就会停止注意到他们工作的建筑外面写着&amp;quot;计算机科学&amp;quot;。但对黑客来说，这个标签是个问题。如果他们所做的事情被称为科学，这让他们觉得他们应该表现得科学。因此，大学和研究实验室里的黑客不做他们真正想做的事情，即设计美丽的软件，而是觉得他们应该写研究论文。&lt;/p&gt;
&lt;p&gt;在最好的情况下，论文只是一种形式。黑客编写很酷的软件，然后写一篇关于它的论文，论文就成为了软件所代表成就的代理。但这种不匹配经常导致问题。很容易从创造美丽的东西转向创造丑陋的东西，而这些东西更适合作为研究论文的题材。&lt;/p&gt;
&lt;p&gt;不幸的是，美丽的东西并不总是最好的论文主题。首先，研究必须是原创的——正如任何写过博士论文的人所知，确保你在探索未知领域的方法是占据一块没有人想要的地盘。其次，研究必须是实质性的——笨拙的系统会产生更丰富的论文，因为你可以写为了完成工作而必须克服的障碍。没有什么比从错误假设开始更能产生丰富的问题了。大多数人工智能都是这个规则的例子；如果你假设知识可以表示为谓词逻辑表达式的列表，其参数代表抽象概念，你将有很多论文要写关于如何使其工作。正如里奇·里卡多常说的：&amp;ldquo;露西，你有很多解释要做。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;创造美丽东西的方法往往是对现有事物进行微妙的调整，或者以稍新的方式组合现有的想法。这种工作很难在研究论文中传达。&lt;/p&gt;
&lt;p&gt;那么为什么大学和研究实验室继续用出版物来判断黑客呢？原因与&amp;quot;学术能力&amp;quot;用简单的标准化测试衡量，或者程序员的生产力用代码行数衡量是一样的。这些测试很容易应用，没有什么比一个勉强有效的简单测试更诱人的了。&lt;/p&gt;
&lt;p&gt;衡量黑客真正试图做的事情，设计美丽的软件，会困难得多。你需要良好的设计感来判断好的设计。人们识别好设计的能力与他们对自己能做到的信心之间没有任何相关性，除了可能是负相关。&lt;/p&gt;
&lt;p&gt;唯一的外部测试是时间。随着时间的推移，美丽的东西往往会繁荣，丑陋的东西往往会被抛弃。不幸的是，所涉及的时间可能比人类寿命还长。塞缪尔·约翰逊说，作家的声誉需要一百年才能收敛。你必须等待作家有影响力的朋友死去，然后他们所有的追随者都死去。&lt;/p&gt;
&lt;p&gt;我认为黑客只能接受自己声誉中有很大的随机成分。在这方面，他们与其他创造者没有什么不同。事实上，相比之下，他们是幸运的。时尚在黑客中的影响力远不如在绘画中那么大。&lt;/p&gt;
&lt;p&gt;有比被人误解你的作品更糟糕的事情。更危险的是你会自己误解你的作品。相关领域是你寻找想法的地方。如果你发现自己身处计算机科学系，自然会有一种诱惑，例如认为黑客是理论计算机科学理论的应用版本。我在研究生院的整个时间里，脑海中总有一种不安的感觉，觉得我应该知道更多理论，而且在期末考试后三周内忘记所有东西是非常疏忽的。&lt;/p&gt;
&lt;p&gt;现在我意识到我错了。黑客需要了解计算理论的程度，与画家需要了解颜料化学的程度差不多。你需要知道如何计算时间和空间复杂性以及图灵完备性。你可能还想记住至少状态机的概念，以防你不得不编写解析器或正则表达式库。事实上，画家必须记住的颜料化学知识比这多得多。&lt;/p&gt;
&lt;p&gt;我发现，最好的想法来源不是名字中有&amp;quot;计算机&amp;quot;一词的其他领域，而是创造者居住的其他领域。绘画比计算理论是更丰富的想法来源。&lt;/p&gt;
&lt;p&gt;例如，我在大学里学到的是，一个人应该在完全接触计算机之前在纸上完整地构思一个程序。我发现我不是这样编程的。我发现我喜欢坐在计算机前编程，而不是在纸上。更糟糕的是，我不是耐心地写出完整的程序并确保它是正确的，而是倾向于只是喷出完全没有希望的代码，然后逐渐把它塑造成形。我学到的是，调试是一种最后阶段，你捕捉打字错误和疏忽。按照我的工作方式，编程似乎就是由调试组成的。&lt;/p&gt;
&lt;p&gt;很长时间以来，我对此感觉很糟糕，就像我曾经因为小学时握铅笔的方式和他们教我的不一样而感到难过一样。如果我看过其他创造者，画家或建筑师，我会意识到我所做的事情有一个名字：素描。据我所知，他们在大学教我的编程方法完全是错的。你应该在编写程序时构思程序，就像作家、画家和建筑师所做的那样。&lt;/p&gt;
&lt;p&gt;意识到这一点对软件设计有实际意义。这意味着编程语言最重要的特性应该是可塑的。编程语言是用来思考程序的，而不是表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果人们真的像他们在大学教我的那样写程序，静态类型会是个好主意。但这不是我认识的任何黑客写程序的方式。我们需要一种让我们能够涂鸦、涂抹和弄脏的语言，而不是一种你必须用一杯类型平衡在膝盖上与严格的老婶婶编译器礼貌交谈的语言。&lt;/p&gt;
&lt;p&gt;既然我们在讨论静态类型，认同创造者将使我们免于困扰科学的另一个问题：数学嫉妒。科学界的每个人都秘密认为数学家比他们聪明。我认为数学家也相信这一点。无论如何，结果是科学家倾向于使他们的工作看起来尽可能数学化。在像物理学这样的领域，这可能不会造成太大伤害，但离自然科学越远，这个问题就越大。&lt;/p&gt;
&lt;p&gt;一页公式看起来非常令人印象深刻。（提示：为了更加令人印象深刻，使用希腊变量。）因此，有很大的诱惑去做你可以正式处理的问题，而不是那些重要的，比如说，重要的问题。&lt;/p&gt;
&lt;p&gt;如果黑客认同其他创造者，比如作家和画家，他们就不会感到诱惑去做这种事情。作家和画家不遭受数学嫉妒。他们觉得他们在做完全不相关的事情。我认为黑客也是如此。&lt;/p&gt;
&lt;p&gt;如果大学和研究实验室阻止黑客做他们想做的工作，也许他们的位置是在公司。不幸的是，大多数公司也不会让黑客做他们想做的事情。大学和研究实验室强迫黑客成为科学家，公司强迫他们成为工程师。&lt;/p&gt;
&lt;p&gt;我自己直到最近才发现这一点。当雅虎收购Viaweb时，他们问我想做什么。我从来不太喜欢商业方面，说我只想黑客。当我到雅虎时，我发现黑客对他们来说意味着实现软件，而不是设计它。程序员被视为技术人员，将产品经理的愿景（如果那算是的话）翻译成代码。&lt;/p&gt;
&lt;p&gt;这似乎是大公司的默认计划。他们这样做是因为它减少了结果的标准差。只有一小部分黑客能够真正设计软件，公司经营者很难挑选出这些人。因此，大多数公司不将软件的未来委托给一个才华横溢的黑客，而是设置成由委员会设计，黑客只实现设计。&lt;/p&gt;
&lt;p&gt;如果你想赚钱，记住这一点，因为这是创业公司获胜的原因之一。大公司希望减少设计结果的标准差，因为他们想避免灾难。但当你抑制波动时，你既失去了高点，也失去了低点。这对大公司来说不是问题，因为他们不是靠做出伟大的产品获胜的。大公司靠比其他大公司少些糟糕获胜。&lt;/p&gt;
&lt;p&gt;所以如果你能找到一种方法与一家大公司进行设计战争，大到其软件是由产品经理设计的，他们将永远无法跟上你。不过，这些机会并不容易找到。很难让大公司参与设计战争，就像很难让城堡内的对手进行肉搏战一样。例如，编写一个比微软Word更好的文字处理器会很容易，但微软在其操作系统垄断的城堡内，即使你做到了，可能甚至不会注意到。&lt;/p&gt;
&lt;p&gt;进行设计战争的地方是新市场，在那里还没有人设法建立任何防御工事。在那里，你可以通过大胆的设计方法，以及让同样的人既设计又实现产品而大获全胜。微软自己一开始就是这样做的。苹果也是如此。惠普也是如此。我怀疑几乎所有成功的创业公司都是如此。&lt;/p&gt;
&lt;p&gt;所以构建伟大软件的一种方法是创办自己的创业公司。然而，这有两个问题。一是在创业公司，你必须做很多编程以外的事情。在Viaweb，如果我能有四分之一的时间黑客，我就觉得自己很幸运。我在其他四分之三的时间里不得不做的事情从乏味到可怕不等。我对此有一个基准，因为我曾经不得不离开董事会会议去补牙。我记得坐在牙医的椅子上，等待钻头，感觉就像在度假。&lt;/p&gt;
&lt;p&gt;创业公司的另一个问题是，赚钱的软件和有趣的软件之间没有太多重叠。编程语言写起来很有趣，微软的第一个产品确实是，但现在没有人会为编程语言付钱。如果你想赚钱，你往往被迫从事对任何人来说都太麻烦而无法免费解决的问题。&lt;/p&gt;
&lt;p&gt;所有创造者都面临这个问题。价格由供求关系决定，对有趣工作的需求不如解决个人客户日常问题的需求多。在外百老汇戏剧中表演不如在贸易展上穿着大猩猩服装在别人的展位工作赚钱。写小说不如为垃圾处理器写广告文案赚钱。黑客编程语言不如想办法将某公司的遗留数据库连接到他们的Web服务器赚钱。&lt;/p&gt;
&lt;p&gt;我认为这个问题的答案，在软件的情况下，是一个几乎所有创造者都知道的概念：日常工作。这个词始于音乐家，他们晚上表演。更一般地说，这意味着你做一种工作是为了钱，做另一种是为了爱。&lt;/p&gt;
&lt;p&gt;几乎所有创造者在职业生涯早期都有日常工作。画家和作家尤其如此。如果你幸运，你可以找到与你真正工作密切相关的日常工作。音乐家似乎经常在唱片店工作。从事某种编程语言或操作系统工作的黑客同样可能能够使用它获得日常工作。[1]&lt;/p&gt;
&lt;p&gt;当我说答案是为黑客提供日常工作，并在业余时间从事美丽软件工作时，我并不是在提出一个新想法。这就是开源黑客的全部内容。我要说的是，开源可能是正确的模式，因为它已经被所有其他创造者独立证实。&lt;/p&gt;
&lt;p&gt;任何雇主都不愿让黑客从事开源项目，这让我感到惊讶。在Viaweb，我们不愿意雇佣任何不这样做的人。当我们面试程序员时，我们主要关心的是他们在业余时间编写什么样的软件。除非你热爱它，否则你不能真正做好任何事情，如果你热爱黑客，你将不可避免地从事自己的项目。[2]&lt;/p&gt;
&lt;p&gt;因为黑客是创造者而不是科学家，寻找隐喻的正确地方不是科学，而是其他类型的创造者。绘画还能教给我们什么关于黑客的知识？&lt;/p&gt;
&lt;p&gt;我们可以从绘画的例子中学到的一件事，或者至少确认的是，如何学习黑客。你主要通过做来学习绘画。黑客也是如此。大多数黑客不是通过上大学编程课程来学习黑客的。他们在十三岁时通过编写自己的程序来学习黑客。即使在大学课程中，你也主要通过黑客来学习黑客。[3]&lt;/p&gt;
&lt;p&gt;因为画家在他们身后留下了作品的痕迹，你可以看着他们通过做来学习。如果你按时间顺序看一位画家的作品，你会发现每幅画都建立在以前画中学到的东西的基础上。当一幅画中有某个东西效果很好时，你通常可以在一些早期绘画中以较小的形式找到它的版本1。&lt;/p&gt;
&lt;p&gt;我认为大多数创造者都是这样工作的。作家和建筑师似乎也是如此。也许黑客应该更像画家，定期从头开始，而不是继续在一个项目上工作多年，并试图将他们以后的想法作为修订纳入其中。&lt;/p&gt;
&lt;p&gt;黑客通过做来学习黑客这一事实是黑客与科学不同的另一个标志。科学家不是通过做科学来学习科学，而是通过做实验和解决问题集。科学家开始做的工作是完美的，在这个意义上说，他们只是试图重现别人已经为他们做过的工作。最终，他们达到可以做原创工作的地步。而黑客从一开始就在做原创工作；只是非常糟糕。所以黑客从原创开始，然后变好，科学家从好开始，然后变原创。&lt;/p&gt;</description></item><item><title>Lisp的不同之处</title><link>https://linguista.cn/person/paul_graham/essays_zh/diff/</link><pubDate>Sat, 01 Dec 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/diff/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/diff/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/diff.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/diff.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/diff.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的不同之处"&gt;Lisp的不同之处&lt;/h1&gt;
&lt;p&gt;2001年12月（修订于2002年5月）&lt;/p&gt;
&lt;p&gt;（本文是回应LL1邮件列表上一些问题而产生的。现在已收录在《书呆子的复仇》中。）&lt;/p&gt;
&lt;p&gt;当McCarthy在1950年代末设计Lisp时，它是对现有语言的彻底突破，其中最重要的是Fortran。&lt;/p&gt;
&lt;p&gt;Lisp体现了九个新思想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;条件语句。&lt;/strong&gt; 条件语句是if-then-else结构。现在我们认为这是理所当然的。它们是McCarthy在开发Lisp过程中发明的。（当时的Fortran只有条件goto，紧密基于底层硬件的分支指令。）McCarthy是Algol委员会的成员，他将条件语句引入Algol，随后传播到大多数其他语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数类型。&lt;/strong&gt; 在Lisp中，函数是一等对象——它们是一种数据类型，就像整数、字符串等，并且有字面表示，可以存储在变量中，可以作为参数传递，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归。&lt;/strong&gt; 递归当然在Lisp之前作为数学概念存在，但Lisp是第一个支持递归的编程语言。（可以说这在使函数成为一等对象中是隐含的。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;变量的新概念。&lt;/strong&gt; 在Lisp中，所有变量实际上都是指针。具有类型的是值，而不是变量，赋值或绑定变量意味着复制指针，而不是它们指向的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;垃圾回收。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;由表达式组成的程序。&lt;/strong&gt; Lisp程序是表达式的树，每个表达式都返回一个值。（在某些Lisp中，表达式可以返回多个值。）这与Fortran和大多数后续语言形成对比，后者区分表达式和语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Fortran中有这种区别是很自然的，因为（在输入格式为打孔卡的语言中不足为奇）该语言是面向行的。你不能嵌套语句。因此，虽然你需要表达式来进行数学运算，但让其他任何东西返回值都没有意义，因为不可能有任何东西在等待它。&lt;/p&gt;
&lt;p&gt;随着块结构语言的出现，这个限制消失了，但那时已经太晚了。表达式和语句的区别已经根深蒂固。它从Fortran传播到Algol，然后传播到它们的后代。&lt;/p&gt;
&lt;p&gt;当一种语言完全由表达式构成时，你可以任意组合表达式。你可以说（使用Arc语法）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(if foo (= x 1) (= x 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(= x (if foo 1 2))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="7"&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;符号类型。&lt;/strong&gt; 符号与字符串的不同在于你可以通过比较指针来测试相等性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用符号树表示代码的记号。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;整个语言始终可用。&lt;/strong&gt; 读取时间、编译时间和运行时间之间没有真正的区别。你可以在读取时编译或运行代码，在编译时读取或运行代码，在运行时读取或编译代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在读取时运行代码允许用户重新编程Lisp的语法；在编译时运行代码是宏的基础；在运行时编译是Lisp用作扩展语言的基础，如在Emacs等程序中；在运行时读取使程序能够使用s表达式进行通信，这个想法最近被重新发明为XML。&lt;/p&gt;
&lt;p&gt;当Lisp首次发明时，所有这些想法都与当时的普通编程实践相去甚远，后者主要由1950年代末可用的硬件决定。&lt;/p&gt;
&lt;p&gt;随着时间的推移，体现在一系列流行语言中的默认语言逐渐向Lisp演变。1-5现在已经广泛传播。6开始出现在主流中。Python具有7的一种形式，尽管似乎没有任何语法支持它。8（与9一起）是使Lisp宏成为可能的特性，到目前为止仍然是Lisp独有的，也许是因为（a）它需要那些括号，或者同样糟糕的东西，（b）如果你添加这最后的力量增量，你不能再声称发明了一种新语言，而只是设计了一种新的Lisp方言 ;-)&lt;/p&gt;
&lt;p&gt;虽然对当今的程序员有用，但通过描述Lisp与其他语言采用的随机权宜之计的差异来描述它是很奇怪的。这可能不是McCarthy对它的看法。Lisp不是设计来修复Fortran中的错误；它更像是试图将计算公理化的副产品。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;</description></item><item><title>Lisp的根源</title><link>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/rootsoflisp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/rootsoflisp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/rootsoflisp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/rootsoflisp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/rootsoflisp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="lisp的根源"&gt;Lisp的根源&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（我写这篇文章是为了帮助自己准确理解McCarthy的发现。你不需要知道这些东西来用Lisp编程，但对于想要理解Lisp本质的人来说——无论是从起源还是语义核心的角度——这应该是有帮助的。Lisp拥有这样一个核心是其区别于其他语言的特征之一，也是为什么与其他语言不同，Lisp有方言的原因。）&lt;/p&gt;
&lt;p&gt;1960年，John McCarthy发表了一篇非凡的论文，他在编程领域做了类似于欧几里得对几何学所做的事情。他展示了，给定一些简单的操作符和函数表示法，如何构建一个完整的编程语言。他称这种语言为Lisp，即&amp;quot;列表处理&amp;quot;，因为他的一个关键想法是使用一种称为列表的简单数据结构来同时表示代码和数据。&lt;/p&gt;
&lt;p&gt;值得理解McCarthy的发现，不仅作为计算机史上的里程碑，而且作为我们时代编程发展方向的模型。在我看来，迄今为止有两个真正干净、一致的编程模型：C模型和Lisp模型。这两个模型似乎像是高地，之间是沼泽般的低地。随着计算机变得越来越强大，正在开发的新语言一直在稳步向Lisp模型移动。过去20年来，新编程语言的一个流行配方是采用C计算模型，然后零散地添加从Lisp模型中提取的部分，如运行时类型和垃圾收集。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将尝试用最简单的术语解释McCarthy的发现。重点不仅仅是了解某人40年前想出的一个有趣的理论结果，而是展示语言的发展方向。Lisp的不寻常之处——事实上，Lisp的定义性特征——是它可以用自身来编写。要理解McCarthy的意思，我们将追溯他的步骤，将他的数学表示法转换为运行的Common Lisp代码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注意：这似乎是一篇较长文章的介绍或摘要。全文可能作为PostScript文件提供，在原始来源中链接为&amp;quot;Complete Article (Postscript)&amp;quot;。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What Made Lisp Different&lt;/li&gt;
&lt;li&gt;The Code&lt;/li&gt;
&lt;li&gt;中文翻译&lt;/li&gt;
&lt;li&gt;日语翻译&lt;/li&gt;
&lt;li&gt;葡萄牙语翻译&lt;/li&gt;
&lt;li&gt;韩语翻译&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>关于语言设计的五个问题</title><link>https://linguista.cn/person/paul_graham/essays_zh/langdes/</link><pubDate>Tue, 01 May 2001 00:00:00 +0800</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/langdes/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/langdes/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/langdes.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/langdes.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/langdes.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="关于语言设计的五个问题"&gt;关于语言设计的五个问题&lt;/h1&gt;
&lt;p&gt;2001年5月&lt;/p&gt;
&lt;p&gt;（这些是我在2001年5月10日MIT编程语言设计小组讨论会上所做的笔记。）&lt;/p&gt;
&lt;h2 id="1-编程语言是为人设计的"&gt;1. 编程语言是为人设计的。&lt;/h2&gt;
&lt;p&gt;编程语言是人们与计算机交流的方式。计算机对于任何无歧义的语言都会同样满意。我们有高级语言的原因是因为人们无法处理机器语言。编程语言的要点是防止我们可怜脆弱的人类大脑被大量细节所淹没。&lt;/p&gt;
&lt;p&gt;建筑师知道某些设计问题比其他问题更具个人性。最干净、最抽象的设计问题之一是设计桥梁。在那里，你的工作主要是用最少的材料跨越给定的距离。光谱的另一端是设计椅子。椅子设计师必须花时间思考人类的臀部。&lt;/p&gt;
&lt;p&gt;软件也是如此。设计网络数据路由算法是一个很好的抽象问题，就像设计桥梁。而设计编程语言就像设计椅子：这完全是关于处理人类弱点的问题。&lt;/p&gt;
&lt;p&gt;我们大多数人都讨厌承认这一点。设计具有数学优雅性的系统对我们大多数人来说比迎合人类弱点听起来更有吸引力。数学优雅确实有作用：某些优雅性使程序更容易理解。但优雅本身不是目的。&lt;/p&gt;
&lt;p&gt;当我说语言必须设计得适合人类弱点时，我并不是说语言必须为糟糕的程序员设计。事实上我认为你应该为最好的程序员设计，但即使是最好的程序员也有局限性。我认为没有人会喜欢在所有变量都是带整数下标的字母x的语言中编程。&lt;/p&gt;
&lt;h2 id="2-为自己和你的朋友设计"&gt;2. 为自己和你的朋友设计。&lt;/h2&gt;
&lt;p&gt;如果你看看编程语言的历史，很多最好的语言都是为其作者自己使用的语言设计的，而很多最差的语言是为其他人使用而设计的。&lt;/p&gt;
&lt;p&gt;当语言为其他人设计时，总是特定的一群其他人：没有语言设计师聪明的人。所以你得到一种居高临下的语言。Cobol是最极端的例子，但很多语言都充斥着这种精神。&lt;/p&gt;
&lt;p&gt;这与语言的抽象程度无关。C是相当低级的，但它是为其作者使用而设计的，这就是为什么黑客喜欢它。&lt;/p&gt;
&lt;p&gt;为糟糕的程序员设计语言的论点是糟糕的程序员比好程序员多。可能是这样。但是那些少数好程序员编写了不成比例的大量软件。&lt;/p&gt;
&lt;p&gt;我对这个问题很感兴趣，你如何设计一种最好的黑客会喜欢的语言？我碰巧认为这与如何设计一种好的编程语言是同一个问题，但即使不是，它至少是一个有趣的问题。&lt;/p&gt;
&lt;h2 id="3-给程序员尽可能多的控制权"&gt;3. 给程序员尽可能多的控制权。&lt;/h2&gt;
&lt;p&gt;许多语言（特别是为其他人设计的语言）都有保姆的态度：它们试图阻止你做它们认为对你不好的事情。我喜欢相反的方法：给程序员尽可能多的控制权。&lt;/p&gt;
&lt;p&gt;当我第一次学习Lisp时，我最喜欢的是它把我当作平等的伙伴。在我之前学习的其他语言中，有语言本身和用该语言写的我的程序，两者非常分离。但在Lisp中，我编写的函数和宏就像构成语言本身的那些一样。如果我想，我可以重写语言。它有着与开源软件相同的吸引力。&lt;/p&gt;
&lt;h2 id="4-追求简洁"&gt;4. 追求简洁。&lt;/h2&gt;
&lt;p&gt;简洁被低估甚至被鄙视。但如果你深入了解黑客的内心，你会发现他们真的很喜欢它。你有多少次听到黑客深情地谈到，比如说，在APL中，他们只需几行代码就能做出惊人的事情？我认为任何真正聪明的人真正喜欢的东西都值得注意。&lt;/p&gt;
&lt;p&gt;我认为几乎任何能让程序更短的事情都是好的。应该有很多库函数；任何可以隐含的东西都应该；语法应该简洁到极致；甚至事物的名称都应该简短。&lt;/p&gt;
&lt;p&gt;不仅程序应该简短。手册也应该薄。手册的很大部分被用于澄清、保留、警告和特殊情况。如果你强迫自己缩短手册，在最好的情况下，你会通过修复语言中需要这么多解释的东西来实现。&lt;/p&gt;
&lt;h2 id="5-承认黑客的本质"&gt;5. 承认黑客的本质。&lt;/h2&gt;
&lt;p&gt;很多人希望黑客是数学，或者至少是类似自然科学的东西。我认为黑客更像是建筑。建筑与物理学有关，因为建筑师必须设计不会倒塌的建筑，但建筑师的真正目标是建造伟大的建筑，而不是做出关于静力学的发现。&lt;/p&gt;
&lt;p&gt;黑客喜欢做的是编写伟大的程序。而且我认为，至少在我们自己的心中，我们必须记住，编写伟大的程序是一件令人钦佩的事情，即使这项工作不容易转化为研究论文的传统智力货币。在智力上，设计程序员会喜欢的语言与设计一个包含你可以发表论文的某些想法的糟糕语言同样有价值。&lt;/p&gt;
&lt;h2 id="开放性问题"&gt;开放性问题&lt;/h2&gt;
&lt;h3 id="1-如何组织大型库"&gt;1. 如何组织大型库？&lt;/h3&gt;
&lt;p&gt;库正在成为编程语言越来越重要的组成部分。它们也在变得更大，这可能很危险。如果找到能做你想要的事情的库函数比你自己编写它需要更长的时间，那么所有这些代码只是在让你的手册变厚。（Symbolics手册就是一个例子。）所以我认为我们必须研究组织库的方法。理想的情况是设计它们，使程序员能够猜测哪个库调用会做正确的事情。&lt;/p&gt;
&lt;h3 id="2-人们真的害怕前缀语法吗"&gt;2. 人们真的害怕前缀语法吗？&lt;/h3&gt;
&lt;p&gt;这是一个开放性问题，在这个意义上我多年来一直在思考它，但仍然不知道答案。前缀语法对我来说似乎完全自然，可能除了数学。但Lisp不受欢迎可能只是因为它有陌生的语法。如果这是真的，是否要对此做些什么是另一个问题。&lt;/p&gt;
&lt;h3 id="3-基于服务器的软件需要什么"&gt;3. 基于服务器的软件需要什么？&lt;/h3&gt;
&lt;p&gt;我认为未来二十年内编写的最令人兴奋的新应用程序中，很多将是基于Web的应用程序，意味着程序位于服务器上并通过Web浏览器与你交谈。而编写这类程序我们可能需要一些新东西。&lt;/p&gt;
&lt;p&gt;我们需要的一件事是支持基于服务器的应用程序发布的新方式。不像桌面软件那样每年有一两个大的发布版本，基于服务器的应用程序作为一系列小变化发布。你一天可能有五到十个发布版本。而且作为规则，每个人都会总是使用最新版本。&lt;/p&gt;
&lt;p&gt;你知道你可以设计程序以便调试吗？嗯，基于服务器的软件同样必须设计成可改变的。你必须能够轻松地改变它，或者至少知道什么是小的改变，什么是重大的改变。&lt;/p&gt;
&lt;p&gt;另一个可能对基于服务器的软件有用的东西，令人惊讶的是，是continuations。在基于Web的软件中，你可以使用类似continuation-passing style的东西来在Web会话本质上无状态的世界中获得子程序的效果。如果不太昂贵，拥有实际的continuations可能是值得的。&lt;/p&gt;
&lt;h3 id="4-还有什么新的抽象有待发现"&gt;4. 还有什么新的抽象有待发现？&lt;/h3&gt;
&lt;p&gt;我不确定这个希望有多合理，但我个人真的很想做的一件事是发现一个新的抽象——某种能像拥有一等函数或递归甚至关键字参数那样产生巨大影响的东西。这可能是一个不可能实现的梦想。这些东西并不经常被发现。但我一直在寻找。&lt;/p&gt;</description></item></channel></rss>