<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on Linguista</title><link>https://linguista.cn/tags/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 28 Sep 2025 21:29:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>代码“劫后余生”:记一场Git灾难与抢救</title><link>https://linguista.cn/post/git-incident-2025-09-28/</link><pubDate>Sun, 28 Sep 2025 21:29:00 +0800</pubDate><guid>https://linguista.cn/post/git-incident-2025-09-28/</guid><description>&lt;p&gt;经过一天的工作，我昨天配置的博客评论区离奇消失，查找记录时发现更惊悚的事：我近几天的Git提交记录全部失踪，并因一个误操作导致代码回滚到三天前的基础版本，所有后期工作成果瞬间清零。我向 GPT-5-Codex 求救，它立即启动高级Git命令进行抢救。最终，在GPT的指导下，我执行了几行恢复命令，代码起死回生，成功回到了误操作前的状态。这次劫后余生的经历，让我深切体会到Git的强大与学习它的必要性。&lt;/p&gt;</description></item><item><title>老范讲故事 GPT-5-Codex 技术平权革命</title><link>https://linguista.cn/infos/htmlcards/gpt-5-codex-kimi-laofan/</link><pubDate>Wed, 17 Sep 2025 08:00:00 +0800</pubDate><guid>https://linguista.cn/infos/htmlcards/gpt-5-codex-kimi-laofan/</guid><description>本文深度解析了 GPT-5-Codex 如何被视为技术平权的里程碑，通过其长达 7 小时的可靠执行能力和亲民的价格策略，打破了传统编程的专家壁垒，让仅具备“略会”技能的普通用户也能驾驭大规模软件开发，标志着编程领域的一场深刻变革。</description></item><item><title>Git 使用指南开发者必备知识</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/git-guide-essentials-developers/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/git-guide-essentials-developers/</guid><description>&lt;h1 id="git-使用指南开发者必备知识"&gt;Git 使用指南开发者必备知识&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;Git 是现代软件开发中不可或缺的版本控制工具。本文系统性地介绍了 Git 的核心概念，包括分支、提交、暂存区等基础要素，详细讲解了从初始化仓库到高级历史操作的各项命令，并梳理了五种主流的 Git 协作工作流。掌握这些知识将显著提升开发者的代码管理效率和团队协作能力。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇强调了 Git 在开发者工作中的核心地位，指出掌握 Git 是职业发展中最有价值的投资之一。全文采用结构化的方式，从基础概念入手，逐步深入到实际操作和高级技巧。&lt;/p&gt;
&lt;p&gt;在基础概念部分，作者详细解释了 Git 的核心架构，包括分支如何实现并行工作流、提交如何记录代码快照、以及工作目录、暂存区、本地仓库和远程仓库这四个阶段的关系。这些概念是理解 Git 工作原理的基础。&lt;/p&gt;
&lt;p&gt;操作指南部分涵盖了日常开发中最常用的命令，从初始化仓库、配置凭证，到分支管理、提交操作，再到历史重写技术如变基、合并、压缩提交等。这些内容直接对应开发者的实际工作场景。&lt;/p&gt;
&lt;p&gt;文章后半部分深入探讨了 Git 协作的最佳实践，对比了功能分支、Gitflow、Forking、Pull Request 和主干开发五种主流工作流的适用场景，并介绍了签名提交、reflog 恢复等高级技巧，最后提供了实用工具和学习资源推荐。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Git 四阶段模型&lt;/strong&gt;：工作目录、暂存区、本地仓库和远程仓库构成了 Git 的核心数据流。理解这四个阶段的转换关系是掌握 Git 的关键，工作目录是实际文件状态，暂存区准备提交内容，本地仓库存储提交历史，远程仓库实现团队协作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支与 HEAD&lt;/strong&gt;：分支本质上是指向提交的可移动指针，HEAD 则是指向当前分支的特殊引用。这种设计使得开发者可以轻松在多个工作流之间切换，而不会互相干扰，是 Git 强大并行能力的根本所在。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变基与合并&lt;/strong&gt;：变基重写提交历史以创建线性叙事，合并则保留完整的分支结构。选择哪种方式取决于团队偏好和项目需求，变基产生更清晰的历史记录，而合并更真实地反映开发过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协作工作流选择&lt;/strong&gt;：不同规模和类型的团队适合不同的 Git 工作流。功能分支工作流适合大多数团队，Gitflow 适合有严格发布周期的项目，Forking 工作流适合开源项目，主干开发则适合追求极致速度的小型团队。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;历史操作的不可逆性&lt;/strong&gt;：虽然 Git 提供了 reflog 等恢复机制，但修改已推送的历史需要团队协调。理解哪些操作是安全的、哪些会重写公共历史，是避免协作灾难的重要前提。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://medium.com/@jake.page91/the-guide-to-git-i-never-had-a89048d4703a"&gt;The guide to Git I never had&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Jake Page&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>计算机科学中的好点子</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/good-ideas-computer-science/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/good-ideas-computer-science/</guid><description>&lt;h1 id="计算机科学中的好点子"&gt;计算机科学中的好点子&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了计算机科学中那些被普遍认为是好的想法，这些想法不被争论且广泛有效。作者指出，虽然程序员们喜欢争论他们喜欢的技术，但这些争论掩盖了计算机科学的胜利。文章列举了从16世纪到20世纪70年代的多个好点子，包括二进制数、可编程计算机、布尔代数、浮点数、数组、哈希表、调用栈、结构化编程、虚拟地址空间、内存保护、版本控制、公钥加密和图形用户界面等，并解释了为何到1974年我们已经拥有了大部分现代计算的基础。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从程序员喜欢争论技术偏好的现象入手，指出这些争论往往掩盖了计算机科学的真正成就。作者在Twitter上提出了一个问题：计算机科学中有哪些想法被普遍认为是好的？这些想法的特点是不被争论、广泛且有效，重点在于想法本身而非具体实现。&lt;/p&gt;
&lt;p&gt;文章的主体部分按照时间顺序列举了从1500年代到1973年的好点子。这些想法构成了现代计算的基础，从数学基础（二进制数、布尔代数）到硬件架构（可编程计算机、浮点数），再到编程概念（数组、哈希表、调用栈、结构化编程），最后到系统级概念（进程、虚拟地址空间、内存保护、版本控制、公钥加密）和用户界面（图形用户界面）。&lt;/p&gt;
&lt;p&gt;作者还特意说明了哪些想法没有被包括在内，如垃圾回收（因为性能考虑）、数据库（因为不是单一想法）、面向对象编程（因为存在争议）等，并解释了排除的原因。文章最后指出，到1974年，我们已经拥有了大部分现代计算的基础，今天的基础与1974年相同，并希望在未来50年内有新的好想法被普遍认为是好的。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;普遍认为的好想法&lt;/strong&gt;：这些想法的特点是不被争论、广泛且有效，重点在于想法本身而非具体实现。例如，Unix包含许多好想法，但不在列表中，因为它是一个实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间分布&lt;/strong&gt;：从文章列举的好点子来看，绝大多数出现在1974年之前。这表明到20世纪70年代中期，现代计算的基础已经基本建立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有意排除的想法&lt;/strong&gt;：垃圾回收因为性能问题被排除，数据库因为不是单一想法而被排除，面向对象编程因为存在争议而被排除。这些排除反映了作者对&amp;quot;普遍认为是好的&amp;quot;这一标准的坚持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;历史连续性&lt;/strong&gt;：从二进制数（1500年代）到图形用户界面（1973年），这些好点子展示了计算机科学发展的连续性和累积性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未来展望&lt;/strong&gt;：作者希望在未来50年内有新的好想法被普遍认为是好的，这表明计算机科学仍然有发展和创新的空间。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://danielchasehooper.com/posts/good-ideas-in-cs/"&gt;Good Ideas in Computer Science&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Daniel Chase Hooper&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>Linus Torvalds 对人工智能编程的独特见解</title><link>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/linus-torvalds-view-on-ai-programming/</link><pubDate>Mon, 13 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes_2025_p4/linus-torvalds-view-on-ai-programming/</guid><description>&lt;h1 id="linus-torvalds-对人工智能编程的独特见解"&gt;Linus Torvalds 对人工智能编程的独特见解&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍了 Linux 和 Git 的创造者 Linus Torvalds 对人工智能在编程领域影响的独特见解。他将大型语言模型比作&amp;quot;强化版的自动更正&amp;quot;，认为目前 AI 擅长预测但不具备真正智能。Torvalds 主张将 AI 视为开发工具而非威胁，强调人类监督的重要性，并对 AI 编程的未来提出了有趣的展望。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从 Linus Torvalds 的视角出发，深入探讨了人工智能在编码领域的现状与未来。Torvalds 将大型语言模型形象地比喻为&amp;quot;强化版的自动更正&amp;quot;，指出这些模型擅长基于模式预测下一个单词或代码行，但目前还不具备人类意义上的&amp;quot;智能&amp;quot;。这种既务实又略带怀疑的态度，为我们理解 AI 编程工具提供了新的视角。&lt;/p&gt;
&lt;p&gt;在谈及 AI 作为开发工具时，Torvalds 认为 AI 在编码中的作用目前还不算革命性，更像是一个超高效的助手而非替代品。他以 GitHub Copilot 为例，说明这些工具如何帮助开发人员编写代码、建议修复和发现潜在错误。值得注意的是，他对未来提出了一个有趣的预测：人工智能可能以人类程序员陌生的方式编写代码，无需考虑人类可读性，这意味着人类开发者的角色可能转变为管理完善代码的 AI 系统。&lt;/p&gt;
&lt;p&gt;文章也客观地讨论了 AI 的局限性，特别是&amp;quot;幻觉&amp;quot;问题——AI 模型可能自信地产生不正确或误导性的输出。Torvalds 强调，AI 生成和审查代码仍需人工监督。在就业问题上，他不认同 AI 将取代所有工作的悲观论调，认为新技术会创造新机会，AI 更多是增强人类能力而非完全替代。最后，他还分享了对软件开发职业的思考，提醒读者编程虽难但有回报，关键是要真心热爱。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;强化版的自动更正&lt;/strong&gt;：Torvalds 用这个比喻来形容大型语言模型的本质。就像手机的自动更正功能根据上下文预测下一个词一样，LLM 也是基于模式预测下一个单词或代码行。这个比喻提醒我们，目前的 AI 并不具备真正的理解能力或智能，而是在做统计预测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 作为助手而非替代品&lt;/strong&gt;：这是 Torvalds 对 AI 编码工具的核心定位。他认为像 GitHub Copilot 这样的工具可以提高效率，但不会取代人类程序员。人类仍然需要理解代码逻辑、做出架构决策，并对 AI 的输出进行审查和验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人类不可读的代码&lt;/strong&gt;：Torvalds 预测的未来场景——AI 可能编写优化过的、人类难以直接理解的代码。这将改变开发者的角色，从直接编写代码转变为管理和监督 AI 系统。这个观点暗示了编程范式可能发生的根本性转变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AI 幻觉问题&lt;/strong&gt;：指 AI 模型自信地输出不正确或误导性内容的现象。Torvalds 强调这是当前 AI 技术的重要局限，意味着在使用 AI 辅助编程时必须保持人工监督，不能盲目信任 AI 的输出。&lt;/p&gt;</description></item><item><title>使用LÖVE构建游戏原型的探索</title><link>https://linguista.cn/infos/tldrcards/henrinotes-2025-p1/building-game-prototypes-with-love/</link><pubDate>Fri, 03 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/infos/tldrcards/henrinotes-2025-p1/building-game-prototypes-with-love/</guid><description>&lt;h1 id="使用löve构建游戏原型的探索"&gt;使用LÖVE构建游戏原型的探索&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文记录了作者在2025年完成并发布一个完整游戏的目标，以及他使用LÖVE框架进行游戏原型开发的冬季假期经历。LÖVE是一个用Lua语言制作2D游戏的框架，具有简单而强大的API。作者分享了他的学习体验、代码示例，以及国际象棋UI和卡牌游戏原型的开发过程，为游戏开发者提供了宝贵的实践参考。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章从作者的个人目标开始谈起——到2025年完成一个可以在Steam或App Store上销售的完整游戏。作者此前有制作小型游戏的经验，但这次希望能够完成并发布一个完整的游戏项目。为了实现这一目标，他选择在冬季假期期间使用LÖVE框架进行原型开发。&lt;/p&gt;
&lt;p&gt;LÖVE是一个用于2D游戏开发的框架，使用Lua语言编写。作者在使用LÖVE之前已经写过约200行Lua代码，因此学习LÖVE的语法对他来说没有困难。他强调了LÖVE API的简洁性和强大功能——能够用少量代码展示完整的游戏功能。文章提供了一个让玩家控制方块在屏幕上移动的代码示例，展示了LÖVE的核心回调函数结构。&lt;/p&gt;
&lt;p&gt;在实践部分，作者分享了两个具体项目：国际象棋用户界面和卡牌游戏UI。国际象棋项目源于作者每年冬天都会回归国际象棋的习惯，他通过LÖVE的回调函数捕捉鼠标输入，实现了一个基础的国际象棋界面。卡牌游戏原型则展示了卡牌交互动画，作者特别强调了动画在卡牌游戏中的重要性。&lt;/p&gt;
&lt;p&gt;最后，作者概述了他2025年的游戏开发计划，包括游戏设计、原型创建、游戏测试等步骤。他也提到可能会使用Godot引擎进行更复杂的游戏开发，并将其原型代码开源供其他开发者参考。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LÖVE框架&lt;/strong&gt;：LÖVE是一个免费、开源的框架，用于使用Lua语言制作2D游戏。它的API设计简洁而强大，开发者可以用很少的代码实现完整的游戏功能。LÖVE的核心结构基于三个主要回调函数：&lt;code&gt;load()&lt;/code&gt;用于初始化，&lt;code&gt;update()&lt;/code&gt;用于处理游戏逻辑，&lt;code&gt;draw()&lt;/code&gt;用于渲染画面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏原型开发&lt;/strong&gt;：原型开发是游戏开发过程中的重要环节，它允许开发者快速验证游戏概念和机制。LÖVE特别适合原型开发，因为它的学习曲线平缓，开发速度快。作者通过国际象棋UI和卡牌游戏两个例子，展示了如何快速构建可玩的游戏原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lua编程语言&lt;/strong&gt;：Lua是一种轻量级、高效的脚本语言，常用于游戏开发。语法简洁，易于学习。作者提到在使用LÖVE前只写了约200行Lua代码，但这足以让他开始构建游戏原型。Lua的动态特性和简洁语法使其成为快速原型开发的理想选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;游戏开发迭代流程&lt;/strong&gt;：作者展示了从概念设计到原型实现，再到测试和迭代的完整流程。他计划2025年进行一系列游戏设计和开发步骤，包括设计游戏、创建原型、进行游戏测试等。这种迭代方法是现代游戏开发的标准实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动画在游戏中的重要性&lt;/strong&gt;：在卡牌游戏原型部分，作者特别强调了动画的重要性。流畅的动画能够显著提升游戏体验，使玩家操作更加直观和愉悦。这体现了游戏开发中&amp;quot;游戏手感&amp;quot;（game feel）的重要性——即玩家与游戏互动时的整体感受。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://healeycodes.com/building-game-prototypes-with-love"&gt;Building Game Prototypes with LÖVE&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Andrew Healey&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024年12月&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>"艺术家要发布"的另一面</title><link>https://linguista.cn/person/paul_graham/essays_zh/artistsship/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/artistsship/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/artistsship/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/artistsship.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/artistsship.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/artistsship.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="艺术家要发布的另一面"&gt;&amp;ldquo;艺术家要发布&amp;quot;的另一面&lt;/h1&gt;
&lt;p&gt;2008年11月&lt;/p&gt;
&lt;p&gt;大公司与创业公司之间的区别之一是，大公司往往已经制定了防止犯错的程序。创业公司走路就像幼儿，不断撞到东西，跌倒。大公司则更加谨慎。&lt;/p&gt;
&lt;p&gt;组织中审核的逐渐积累是一种学习，基于发生在自己或类似组织身上的灾难。例如，在与一个破产并无法交付的供应商签订合同后，公司可能会要求所有供应商在投标前证明自己有偿付能力。&lt;/p&gt;
&lt;p&gt;随着公司的发展，他们不可避免地会有更多这样的审核，要么是为了应对他们遭受的灾难，要么（可能更常见的是）通过从更大的公司雇佣带来新灾难防范习惯的人。&lt;/p&gt;
&lt;p&gt;组织从错误中学习是自然的。问题是，提出新审核的人几乎从不考虑审核本身有成本。&lt;/p&gt;
&lt;h2 id="每个审核都有成本"&gt;每个审核都有成本。&lt;/h2&gt;
&lt;p&gt;例如，考虑让供应商验证其偿付能力的情况。这难道不是仅仅谨慎吗？但实际上它可能有巨大成本。显然，双方提供和检查供应商偿付能力证明的人有直接的时间成本。但真正的成本是你从未听说过的：本会是最佳供应商的公司，但因为无法腾出精力进行验证而没有投标。或者本会是最佳供应商的公司，但偿付能力却刚好低于门槛——当然这个门槛会被定得偏高，因为没有明显的提高成本。&lt;/p&gt;
&lt;p&gt;每当组织中有人提议添加新审核时，他们应该不仅解释收益，还要解释成本。无论他们分析得多么糟糕，这个元审核至少会提醒每个人必须存在成本，并让他们去寻找它。&lt;/p&gt;
&lt;p&gt;如果公司开始这样做，他们会发现一些意外。Joel Spolsky最近在Y Combinator谈到向企业客户销售软件。他说，在大多数公司中，成本高达约1000美元的软件可以由个人经理无需任何额外批准购买。超过这个门槛，软件购买通常必须由委员会批准。但是为软件供应商处理这个过程如此昂贵，以至于收费少于50000美元没有意义。这意味着如果你制造了一个本来可能收费5000美元的东西，你必须以50000美元的价格出售。&lt;/p&gt;
&lt;p&gt;委员会的目的是确保公司不浪费钱。然而结果是公司支付了10倍的价格。&lt;/p&gt;
&lt;p&gt;购买审核总是昂贵的，因为向你销售东西越困难，它就必须成本越高。而且不是线性的。如果你足够难以销售，最擅长制造东西的人根本不想费心。唯一会向你销售的是专门向你销售的公司。那么你已经陷入了全新的低效率水平。市场机制不再保护你，因为好的供应商已经不在市场上了。&lt;/p&gt;
&lt;p&gt;这样的事情不断发生在所有最大的组织中，政府。但政府实施的审核可能导致的问题不仅仅是多付钱。政府实施的审核可能破坏整个国家的经济。直到大约1400年，中国比欧洲更富有，技术更先进。欧洲超越的一个原因是中国政府限制了长途贸易航行。因此欧洲人开始探索并最终主导世界其他地区，包括中国。&lt;/p&gt;
&lt;p&gt;在更近的时代，《萨班斯-奥克斯利法案》实际上摧毁了美国IPO市场。这不是立法者的意图。他们只是想为上市公司添加更多审核。但他们忘记了考虑成本。他们忘记了即将上市的公司通常相当紧张，而对通用电气来说可能容易承受的几个额外审核的重量，足以阻止年轻公司上市。&lt;/p&gt;
&lt;p&gt;一旦你开始思考审核的成本，你就可以开始问其他有趣的问题。成本是在增加还是减少？在某些地区是否比其他地区高？哪里会不连续地增加？如果大型组织开始问这样的问题，他们会学到一些令人恐惧的事情。&lt;/p&gt;
&lt;h2 id="我认为审核的成本实际上可能在增加"&gt;我认为审核的成本实际上可能在增加。&lt;/h2&gt;
&lt;p&gt;原因是软件在公司中扮演着越来越重要的角色，而编写软件的人特别受到审核的伤害。&lt;/p&gt;
&lt;p&gt;程序员与许多类型的工人不同，最好的程序员实际上更愿意努力工作。在大多数类型的工作中似乎并非如此。当我在快餐店工作时，我们并不喜欢繁忙时段。当我过去修剪草坪时，我绝对不喜欢一周下雨后草长得很长的时候。&lt;/p&gt;
&lt;p&gt;然而，程序员在写更多代码时更喜欢。或者更准确地说，在发布更多代码时更喜欢。程序员喜欢做出改变。好的程序员，无论如何。&lt;/p&gt;
&lt;p&gt;对于好的程序员来说，为创业公司工作的最大好处之一是发布的审核很少。在真正的创业公司中，根本没有外部审核。如果你早上有一个新功能的想法，你可以在午餐前编写它并将其推送到生产服务器。当你能做到这一点时，你会有更多想法。&lt;/p&gt;
&lt;p&gt;在大公司，软件必须经过各种批准才能发布。这样做的成本可能是巨大的——实际上是不连续的。最近我和三个程序员交谈，他们的创业公司几年前被一家大公司收购。当他们独立时，他们可以立即发布更改。现在，他们说，他们能在生产服务器上发布代码的最快速度是两周。&lt;/p&gt;
&lt;p&gt;这不仅让他们生产力降低。这让他们讨厌为收购者工作。&lt;/p&gt;
&lt;p&gt;这里是程序员多么喜欢能够努力工作的一个迹象：这些人会付钱来立即发布代码，像过去那样。我问他们是否愿意用收购价的10%来换取立即发布代码的能力，三个人立即说愿意。然后我问他们愿意用收购价的最大百分比来换取它。他们说他们不想思考，因为他们不想知道自己会多高，但我得到的印象可能高达一半。&lt;/p&gt;
&lt;p&gt;他们会牺牲数十万，也许是数百万美元，只是为了能够向用户交付更多软件。你知道吗？让他们这样做是完全安全的。事实上，收购者会更好；这些人不仅不会破坏任何东西，他们会完成更多工作。所以收购者实际上以更高的成本获得了更差的绩效。就像批准软件购买的委员会一样。&lt;/p&gt;
&lt;p&gt;正如难以销售的最大危险不是你多付钱，而是最好的供应商甚至不会向你销售，对程序员应用太多审核的最大危险不是你会让他们不高效，而是好的程序员甚至不想为你工作。&lt;/p&gt;
&lt;p&gt;史蒂夫·乔布斯著名的格言&amp;quot;艺术家要发布&amp;quot;有两个方面。艺术家不仅能够发布。他们坚持要发布。所以如果你不让人发布，你就不会有任何艺术家。&lt;/p&gt;</description></item><item><title>ANSI Common Lisp 简介</title><link>https://linguista.cn/person/paul_graham/essays_zh/acl1txtt1748944359/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/acl1txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/acl1txtt1748944359/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="ansi-common-lisp-简介"&gt;ANSI Common Lisp 简介&lt;/h1&gt;
&lt;p&gt;ANSI Common Lisp 简介&lt;/p&gt;
&lt;p&gt;（这是Paul Graham的《ANSI Common Lisp》一书的第一章。版权1995年，Prentice-Hall。）&lt;/p&gt;
&lt;h2 id="介绍"&gt;介绍&lt;/h2&gt;
&lt;p&gt;John McCarthy和他的学生于1958年开始在第一个Lisp实现上工作。除了Fortran之外，Lisp是仍在使用的最古老的语言。[1] 更值得注意的是，它仍然处于编程语言技术的前沿。了解Lisp的程序员会告诉你，这种语言有某种独特之处。&lt;/p&gt;
&lt;p&gt;Lisp的独特之处部分在于它被设计为可进化的。你可以使用Lisp来定义新的Lisp操作符。当新的抽象变得流行时（例如面向对象编程），事实证明在Lisp中实现它们总是很容易的。像DNA这样的语言不会过时。&lt;/p&gt;
&lt;h2 id="新工具"&gt;新工具&lt;/h2&gt;
&lt;p&gt;为什么学习Lisp？因为它让你做其他语言做不到的事情。如果你只是想写一个返回小于n的数字之和的函数，在Lisp和C中看起来会非常相似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun sum (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (&lt;span style="color:#66d9ef"&gt;let&lt;/span&gt; ((s &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (dotimes (i n s)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; (incf s i))))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/* C */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;sum&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; n){
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; i, s &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;for&lt;/span&gt;(i &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; i &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style="color:#f92672"&gt;++&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; s &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt;(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你只需要做这样的简单事情，你使用哪种语言并不重要。假设相反，你想写一个函数，它接受一个数字n，并返回一个将n加到其参数上的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-lisp" data-lang="lisp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;; Lisp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;(defun addn (n)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;#&amp;#39;&lt;/span&gt;(lambda (x) (&lt;span style="color:#a6e22e"&gt;+&lt;/span&gt; x n)))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addn在C中是什么样的？你根本写不出来。&lt;/p&gt;
&lt;p&gt;你可能会想知道，什么时候有人会想做这样的事情？编程语言教会你不要渴望它们不能提供的东西。你必须用一种语言思考才能用其编写程序，很难渴望你无法描述的东西。当我开始编写程序时——使用Basic——我不想念递归，因为我不知道有这样的东西。我用Basic思考。我只能构想迭代算法，为什么要想念递归？&lt;/p&gt;
&lt;p&gt;如果你不怀念词法闭包（这就是前面例子中制作的东西），暂时相信Lisp程序员一直使用它们。很难找到任何长度的Common Lisp程序不利用闭包。到第112页，你自己也会使用它们。而闭包只是我们在其他语言中找不到的抽象之一。&lt;/p&gt;</description></item><item><title>Java的外衣</title><link>https://linguista.cn/person/paul_graham/essays_zh/javacover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/javacover/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/javacover/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/javacover.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/javacover.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/javacover.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="java的外衣"&gt;Java的外衣&lt;/h1&gt;
&lt;p&gt;2001年4月&lt;/p&gt;
&lt;p&gt;这篇文章源于我与几位程序员关于Java为何气味可疑的对话。这不是对Java的批判！这是黑客雷达的一个案例研究。&lt;/p&gt;
&lt;p&gt;随着时间的推移，黑客对好（和坏）技术培养出了一种嗅觉。我想试着写下是什么让Java对我来说似乎可疑，这可能会很有趣。&lt;/p&gt;
&lt;p&gt;一些读过这篇文章的人认为这是试图以前所未有的方式写一些有趣的事情。其他人说我将因为看起来写我不理解的东西而陷入麻烦。所以，以防万一有任何好处，让我澄清我在这里不是在写Java（我从未使用过），而是在写黑客雷达（我对此思考很多）。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;不能凭封面判断一本书&amp;quot;这句格言起源于书籍用普通纸板封面出售的时代，由每个购买者根据自己的品味装订。在那个时代，你不能凭封面判断一本书。但出版业从那时起进步了：现在的出版商努力使封面成为你可以判断一本书的依据。&lt;/p&gt;
&lt;p&gt;我花了很多时间在书店，我觉得我现在已经学会理解出版商想要告诉我关于一本书的一切，可能还有更多。我没有在书店度过的时间主要花在电脑前，我觉得我在某种程度上已经学会了通过封面来判断技术。这可能只是运气，但我已经让自己避免了一些最终被证明是真正糟糕的技术。&lt;/p&gt;
&lt;p&gt;到目前为止，Java对我来说似乎很糟糕。我从未写过Java程序，从未看过关于它的参考书，但我有一个预感，它不会是一种非常成功的语言。我可能被证明是错的；对技术做出预测是危险的事情。但作为某种时间胶囊，就其价值而言，这就是为什么我不喜欢Java的外观：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它被如此热情地炒作。真正的标准不需要被推广。没有人需要推广C、Unix或HTML。真正的标准在大多数人听到它之前就已经建立了。在黑客雷达屏幕上，Perl和Java一样大，或者更大，仅仅是凭借自身的优点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的目标很低。在最初的Java白皮书中，Gosling明确表示Java的设计对习惯C的程序员来说不会太困难。它被设计成另一个C++：C加上一些从更高级语言中借来的想法。就像情景喜剧、垃圾食品或包价旅游的创造者一样，Java的设计者有意识地为不如他们聪明的人设计产品。历史上，为他人使用而设计的语言都很糟糕：Cobol、PL/I、Pascal、Ada、C++。好的语言是那些为自己的设计者设计的：C、Perl、Smalltalk、Lisp。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有不可告人的动机。有人说过，如果人们只在有话要说时才写书，而不是因为想写书，世界会变得更美好。同样，我们一直听到Java的原因不是因为它对编程语言有什么要说的。我们听到Java作为Sun公司削弱微软计划的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有人喜欢它。C、Perl、Python、Smalltalk和Lisp程序员都喜欢他们的语言。我从未听任何人说过他们喜欢Java。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人们被迫使用它。我认识的许多使用Java的人使用它是因为他们觉得必须这样做。要么是他们觉得为了获得资助必须这样做，要么是他们认为客户会想要，要么是管理层告诉他们要这样做。这些都是聪明人；如果技术好，他们会自愿使用它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它有太多的厨师。最好的编程语言是由小团体开发的。Java似乎是由一个委员会管理的。如果它最终成为一种好语言，这将是历史上委员会第一次设计出好语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是官僚主义的。据我对Java的一点点了解，似乎有很多做事的协议。真正的好语言不是那样的。它们让你做你想做的事，然后让路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是伪时髦的。Sun现在假装Java是一种像Perl或Python那样的草根、开源语言努力。这个恰好由一家大公司控制。所以这种语言很可能具有与大公司生产的任何东西相同的单调笨重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它是为大型组织设计的。大型组织的目标与黑客不同。他们想要适合大型平庸程序员团队使用的语言——具有像U-Haul卡车中的限速器那样的功能，防止傻瓜造成太大损害。黑客不喜欢对他们居高临下的语言。黑客只想要力量。历史上，为大型组织设计的语言（PL/I、Ada）都失败了，而黑客语言（C、Perl）获胜了。原因：今天的青少年黑客是明天的CTO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误的人喜欢它。我最钦佩的程序员整体上没有被Java迷住。谁喜欢Java？西装革履的人，不知道一种语言与另一种的区别，但知道他们在媒体上不断听到Java；大公司的程序员，惊讶地发现还有比C++更好的东西；以及即插即用的本科生，准备好喜欢任何可能让他们找到工作的东西（这会考试吗？）。这些人的意见随风而变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的爸爸陷入困境。Sun的商业模式正受到两方面的侵蚀。与台式机相同类型的廉价Intel处理器现在对服务器来说已经足够快了。而且FreeBSD似乎至少与Solaris一样适合作为服务器操作系统。Sun的广告暗示你需要Sun服务器用于工业级应用程序。如果这是真的，Yahoo会第一个排队购买Sun；但当我在那里工作时，服务器都是运行FreeBSD的Intel盒子。这对Sun的未来是个坏兆头。如果Sun遇到麻烦，他们可能会把Java拖下水。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;国防部喜欢它。国防部鼓励开发者使用Java。这在我看来是最 damning 的迹象。国防部的国防工作做得很好（虽然昂贵），但他们喜欢计划、程序和协议。他们的文化与黑客文化相反；在软件问题上他们往往会下错注。国防部最后一次真正喜欢一种编程语言是Ada。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请记住，这不是对Java的批判，而是对其外衣的批判。我对Java的了解还不足以喜欢或不喜欢它。这只是为什么我不觉得急于学习它的解释。&lt;/p&gt;
&lt;p&gt;在尝试用一种语言编写程序之前就将其 dismissed 可能看起来 cavalier。但这是所有程序员都必须做的事情。外面的技术太多了，无法全部学习。你必须学会通过外部迹象来判断哪些值得你花时间。我同样 cavalier 地 dismissed 了Cobol、Ada、Visual Basic、IBM AS400、VRML、ISO 9000、SET协议、VMS、Novell Netware和CORBA等。它们只是气味不对。&lt;/p&gt;
&lt;p&gt;在Java的情况下我可能错了。可能一种由一家大公司推广以削弱另一家大公司、由委员会为&amp;quot;主流&amp;quot;受众设计、被炒作到天际、国防部喜欢的语言，碰巧是一种我会喜欢编程的干净、美丽、强大的语言。可能，但这似乎非常不可能。&lt;/p&gt;
&lt;p&gt;Trevor Re: Java&amp;rsquo;s Cover | Berners-Lee Re: Java | Being Popular | Sun Internal Memo | 2005: BusinessWeek Agrees&lt;/p&gt;</description></item><item><title>Mac的回归</title><link>https://linguista.cn/person/paul_graham/essays_zh/mac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/mac/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/mac/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/mac.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/mac.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/mac.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="mac的回归"&gt;Mac的回归&lt;/h1&gt;
&lt;p&gt;2005年3月&lt;/p&gt;
&lt;p&gt;我认识的所有最好的黑客都在逐渐转向Mac。我的朋友Robert说，他在MIT的整个研究小组最近都给自己买了Powerbook。这些人不是90年代中期苹果低谷时期购买Mac的图形设计师和祖母们。他们是你能找到的最核心的OS黑客。&lt;/p&gt;
&lt;p&gt;原因当然是OS X。Powerbook设计精美，运行FreeBSD。你还需要知道什么？&lt;/p&gt;
&lt;p&gt;我在去年年底买了一台Powerbook。当我的IBM Thinkpad的硬盘很快损坏后，它成了我唯一的笔记本电脑。当我的朋友Trevor最近出现在我家时，他拿着一台与我相同的Powerbook。&lt;/p&gt;
&lt;p&gt;对我们大多数人来说，这不是转向苹果，而是回归。尽管在90年代中期很难相信，但Mac在其时代是典型的黑客计算机。&lt;/p&gt;
&lt;p&gt;1983年秋天，我大学的一门CS课教授站起来，像先知一样宣布，很快将有一种计算机具有半MIPS的处理能力，可以放在飞机座位下，价格如此便宜，我们可以从暑假工作中节省足够的钱来买一台。整个房间都倒吸了一口气。当Mac出现时，它甚至比我们希望的还要好。它如承诺的那样小、强大和便宜。但它也是我们从未想过计算机能成为的东西：设计精美。&lt;/p&gt;
&lt;p&gt;我必须拥有一台。我不是一个人。在80年代中后期，我认识的所有黑客都在为Mac编写软件，或者想要这样做。剑桥的每个沙发床垫上似乎都躺着一本相同的胖白皮书。如果你把它翻过来，上面写着&amp;quot;Inside Macintosh&amp;quot;。&lt;/p&gt;
&lt;p&gt;然后是Linux和FreeBSD，黑客们跟随最强大的OS wherever it leads，发现自己转向了Intel盒子。如果你关心设计，你可以买一台Thinkpad，如果你能把Intel和Microsoft的标签从前面撕掉，它至少不会 actively 令人反感。[1]&lt;/p&gt;
&lt;p&gt;随着OS X的出现，黑客们回来了。当我走进剑桥的苹果商店时，就像回家一样。很多东西都变了，但空气中仍然有那种苹果的酷炫感，感觉表演是由真正关心的人运营的，而不是随机的公司交易者。&lt;/p&gt;
&lt;p&gt;那又怎样，商界可能会说。谁在乎黑客是否再次喜欢苹果？毕竟，黑客市场有多大？&lt;/p&gt;
&lt;p&gt;相当小，但相对于其规模来说很重要。当涉及计算机时，黑客现在正在做的事情，十年后每个人都会做。几乎所有的技术，从Unix到位图显示到Web，都是在CS部门和研究实验室中首先流行的，然后逐渐传播到世界其他地方。&lt;/p&gt;
&lt;p&gt;我记得1986年告诉我父亲，有一种叫做Sun的新型计算机，它是一台严肃的Unix机器，但如此小和便宜，你可以拥有一个自己坐在前面，而不是坐在连接到单个中央Vax的VT100前面。我建议，也许他应该买一些这家公司的股票。我想他真的希望他听了。&lt;/p&gt;
&lt;p&gt;1994年，我的朋友Koling想和他在台湾的女朋友交谈，为了节省长途账单，他写了一些软件，将声音转换为可以通过互联网发送的数据包。当时我们不确定这是否是互联网的适当用途，互联网当时仍然是一个准政府实体。他现在做的事情被称为VoIP，它是一个巨大且快速增长的业务。&lt;/p&gt;
&lt;p&gt;如果你想知道十年后普通人会用计算机做什么，只需在一个好大学的CS部门走一圈。无论他们在做什么，你都会做。&lt;/p&gt;
&lt;p&gt;在&amp;quot;平台&amp;quot;问题上，这种趋势更加明显，因为新颖的软件源自伟大的黑客，他们倾向于首先为他们个人使用的任何计算机编写它。软件销售硬件。Apple II的初始销售中，如果不是大多数的话，很多来自购买它来运行VisiCalc的人。为什么Bricklin和Frankston为Apple II编写VisiCalc？因为他们个人喜欢它。他们可以选择任何机器使其成为明星。&lt;/p&gt;
&lt;p&gt;如果你想吸引黑客编写销售你的硬件的软件，你必须使它成为他们自己使用的东西。仅仅使其&amp;quot;开放&amp;quot;是不够的。它必须开放且好。&lt;/p&gt;
&lt;p&gt;而开放且好正是Macs再次成为的。中间的几年创造了一种据我所知前所未有的情况：苹果在低端和高端都很受欢迎，但在中间不。我七十岁的母亲有一台Mac笔记本电脑。我拥有计算机科学博士学位的朋友都有Mac笔记本电脑。[2] 然而苹果的整体市场份额仍然很小。&lt;/p&gt;
&lt;p&gt;尽管前所未有，但我预测这种情况也是暂时的。&lt;/p&gt;
&lt;p&gt;所以爸爸，有家叫苹果的公司。他们制造一种新型计算机，设计得像Bang &amp;amp; Olufsen音响系统一样好，下面是你能买到的最好的Unix机器。是的，市盈率有点高，但我想很多人会想要这些。&lt;/p&gt;
&lt;h2 id="注释"&gt;注释&lt;/h2&gt;
&lt;p&gt;[1] 这些可怕的标签很像前Google搜索引擎上流行的侵入性广告。它们对客户说：你不重要。我们关心Intel和Microsoft，而不是你。&lt;/p&gt;
&lt;p&gt;[2] Y Combinator（我们希望）主要被黑客访问。操作系统的比例是：Windows 66.4%，Macintosh 18.8%，Linux 11.4%，FreeBSD 1.5%。Mac数字与五年前相比是一个很大的变化。&lt;/p&gt;
&lt;h2 id="意大利语翻译"&gt;意大利语翻译&lt;/h2&gt;
&lt;h2 id="俄语翻译"&gt;俄语翻译&lt;/h2&gt;
&lt;h2 id="中文翻译"&gt;中文翻译&lt;/h2&gt;</description></item><item><title>Progbot</title><link>https://linguista.cn/person/paul_graham/essays_zh/progbot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/progbot/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/progbot/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/progbot.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/progbot.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/progbot.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="progbot"&gt;Progbot&lt;/h1&gt;
&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;
&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;
&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;
&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;
&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;
&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;
&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;
&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;
&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;
&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;
&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;
&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;
&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description></item><item><title>Python悖论</title><link>https://linguista.cn/person/paul_graham/essays_zh/pypar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/pypar/</guid><description>&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/pypar.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/pypar.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/pypar.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="python悖论"&gt;Python悖论&lt;/h1&gt;
&lt;p&gt;2004年8月&lt;/p&gt;
&lt;p&gt;在最近的一次演讲中，我说了一些让很多人不高兴的话：你可以让更聪明的程序员在Python项目上工作，而不是在Java项目上工作。&lt;/p&gt;
&lt;p&gt;我这样说并不是指Java程序员很笨。我的意思是Python程序员很聪明。学习一门新的编程语言需要很多工作。人们学习Python并不是因为它能给他们带来工作；他们学习它是因为他们真正喜欢编程，并且对已经知道的语言不满意。&lt;/p&gt;
&lt;p&gt;这使他们成为公司应该想要雇佣的那种程序员。因此，由于缺乏更好的名称，我称之为Python悖论：如果一个公司选择用相对冷门的语言编写其软件，他们将能够雇佣到更好的程序员，因为他们只会吸引那些足够关心它而去学习它的人。而对于程序员来说，这个悖论更加明显：如果你想找到一份好工作，应该学习的语言是那些人们不仅仅是为了找工作而学习的语言。&lt;/p&gt;
&lt;p&gt;到目前为止，只有少数公司足够聪明地意识到了这一点。但这里也有一种选择在进行：它们正是程序员最想为之工作的公司。例如，Google。当他们发布Java编程工作时，他们也希望有Python经验。&lt;/p&gt;
&lt;p&gt;我的一位朋友几乎知道所有广泛使用的语言，他在大多数项目中都使用Python。他说主要的原因是他喜欢源代码的外观。这可能是选择一种语言而不是另一种语言的轻率理由。但并没有听起来那么轻率：当你编程时，你花在阅读代码上的时间比写代码的时间多。你推着源代码团，就像雕塑家推着粘土团一样。因此，一种让源代码看起来丑陋的语言对于要求精确的程序员来说是令人发疯的，就像充满疙瘩的粘土对于雕塑家一样。&lt;/p&gt;
&lt;p&gt;提到丑陋的源代码，人们当然会想到Perl。但Perl表面的丑陋并不是我指的那种。真正的丑陋不是看起来刺耳的语法，而是不得不用错误的概念来构建程序。Perl可能看起来像一个骂人的卡通人物，但在某些情况下，它在概念上超越了Python。&lt;/p&gt;
&lt;p&gt;到目前为止，无论如何。当然，这两种语言都是不断发展的目标。但它们与Ruby（以及Icon、Joy、J、Lisp和Smalltalk）共享一个事实：它们都是由真正关心编程的人创建和使用的。而那些往往是做得好的人。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;如果你喜欢这篇文章，你可能也会喜欢&lt;a href="https://linguista.cn/person/paul_graham/essays_zh/hp/"&gt;黑客与画家&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description></item><item><title>伟大的黑客</title><link>https://linguista.cn/person/paul_graham/essays_zh/gh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/gh/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/gh/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/gh.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/gh.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/gh.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="伟大的黑客"&gt;伟大的黑客&lt;/h1&gt;
&lt;p&gt;2004年7月&lt;/p&gt;
&lt;p&gt;（本文源自2004年Oscon大会的演讲。）&lt;/p&gt;
&lt;p&gt;几个月前我完成了一本新书，在评论中我不断注意到诸如&amp;quot;挑衅性&amp;quot;和&amp;quot;争议性&amp;quot;的词语。更不用说&amp;quot;白痴&amp;quot;了。&lt;/p&gt;
&lt;p&gt;我并不是想让这本书具有争议性。我试图让它高效。我不想浪费人们的时间告诉他们他们已经知道的事情。更高效的方法只是给他们差异。但我想这必然会产生一本令人担忧的书。&lt;/p&gt;
&lt;h2 id="爱迪生们"&gt;爱迪生们&lt;/h2&gt;
&lt;p&gt;最具争议的想法是：财富的差异可能并不像我们想象的那么大问题。&lt;/p&gt;
&lt;p&gt;我在书中没有说财富差异本身就是好事。我说在某些情况下它可能是好事的标志。剧烈的头痛不是好事，但它可能是好事的标志——例如，你被击中头部后正在恢复意识。&lt;/p&gt;
&lt;p&gt;财富差异可能是生产力差异的标志。（在一个人的社会中，它们是相同的。）这几乎肯定是好事：如果你的社会没有生产力差异，可能不是因为每个人都是托马斯·爱迪生。而是因为你没有托马斯·爱迪生。&lt;/p&gt;
&lt;p&gt;在低技术社会中，你看不到太多的生产力差异。如果你有一群游牧民族为火收集木棍，最好的木棍收集者比最差的能多收集多少？两倍？而当你给人们一个像电脑这样的复杂工具时，他们能用它做的事情的差异是巨大的。&lt;/p&gt;
&lt;p&gt;这不是一个新想法。Fred Brooks在1974年写过这个，他引用的研究发表于1968年。但我认为他低估了程序员之间的差异。他写了代码行数方面的生产力：最好的程序员可以在十分之一的时间内解决给定问题。但如果问题没有给定呢？在编程中，就像在许多领域一样，困难的部分不是解决问题，而是决定要解决什么问题。想象力很难衡量，但在实践中它主导着以代码行数衡量的那种生产力。&lt;/p&gt;
&lt;p&gt;生产力在任何领域都有变化，但很少有领域变化如此之大。程序员之间的差异如此之大，以至于成为一种质的差异。我不认为这是编程固有的，但在每个领域，技术都放大了生产力的差异。我认为编程中发生的事情只是因为我们有很多技术杠杆。但在每个领域，杠杆都在变长，所以我们看到的差异是随着时间的推移，越来越多的领域都会看到的。公司和国家的成功将越来越取决于他们如何应对这个问题。&lt;/p&gt;
&lt;p&gt;如果生产力的差异随着技术而增加，那么最有生产力个体的贡献不仅会不成比例地大，而且会随着时间的推移而实际增长。当你达到一个群体的90%产出由其1%的成员创造的地步时，如果有什么（无论是维京袭击，还是中央计划）将他们的生产力拖到平均水平，你就会损失惨重。&lt;/p&gt;
&lt;p&gt;如果我们想充分利用他们，我们需要了解这些特别有生产力的人。什么激励他们？他们需要什么来做他们的工作？你如何认识他们？你如何让他们来为你工作？然后当然还有这个问题，你如何成为其中一员？&lt;/p&gt;
&lt;h2 id="不仅仅是金钱"&gt;不仅仅是金钱&lt;/h2&gt;
&lt;p&gt;我认识一些超级黑客，所以我坐下来思考他们有什么共同点。他们的决定性品质可能是他们真的喜欢编程。普通程序员写代码是为了付账单。伟大的黑客认为这是他们为了乐趣而做的事情，并且很高兴发现有人会为此付钱。&lt;/p&gt;
&lt;p&gt;伟大的程序员有时被认为对金钱漠不关心。这不完全正确。确实，他们真正关心的只是做有趣的工作。但如果你赚了足够的钱，你就可以做任何你想做的工作，因此黑客被赚取巨额金钱的想法所吸引。但只要他们还必须每天上班工作，他们更关心在那里做什么，而不是得到多少报酬。&lt;/p&gt;
&lt;p&gt;从经济学上讲，这是最重要的事实，因为这意味着你不必支付伟大的黑客接近他们价值的报酬。一个伟大的程序员可能比普通程序员生产力高十倍或一百倍，但他会认为能获得三倍报酬就很幸运了。正如我稍后要解释的，这部分是因为伟大的黑客不知道他们有多好。但也是因为金钱不是他们主要想要的东西。&lt;/p&gt;
&lt;p&gt;黑客想要什么？像所有工匠一样，黑客喜欢好工具。事实上，这低估了。好的黑客发现无法忍受使用坏工具。他们会拒绝在错误基础设施的项目上工作。&lt;/p&gt;
&lt;p&gt;在我曾经工作过的一家创业公司，我们公告板上钉着的一张东西是IBM的广告。那是一张AS400的图片，标题写着，我认为，&amp;ldquo;黑客鄙视它。&amp;quot;[1]&lt;/p&gt;
&lt;p&gt;当你决定为项目使用什么基础设施时，你不仅在做出技术决定。你还在做出社会决定，而这可能是两者中更重要的。例如，如果你的公司想写一些软件，用Java写似乎是一个谨慎的选择。但当你选择一种语言时，你也在选择一个社区。你能雇佣来在Java项目上工作的程序员不会像你能雇佣来在Python项目上工作的那样聪明。而你的黑客的质量可能比你选择的语言更重要。虽然，坦率地说，好的黑客更喜欢Python而不是Java这一事实应该告诉你这些语言的相对优点。&lt;/p&gt;
&lt;p&gt;商业类型更喜欢最流行的语言，因为他们将语言视为标准。他们不想在公司上下注Betamax。但语言的问题是，它们不仅仅是标准。如果你必须通过网络传输比特，务必使用TCP/IP。但编程语言不仅仅是格式。编程语言是一种表达媒介。&lt;/p&gt;
&lt;p&gt;我读到Java刚刚超过Cobol成为最流行的语言。作为标准，你不能期望更多。但作为表达媒介，你可以做得更好。在我能想到的所有伟大程序员中，我只知道一个会自愿用Java编程。而在我能想到的所有不为Sun工作的伟大程序员中，在Java方面，我一个也不知道。&lt;/p&gt;
&lt;p&gt;伟大的黑客通常也坚持使用开源软件。不仅仅是因为它更好，还因为它给他们更多控制权。好的黑客坚持控制权。这是使他们成为好黑客的部分原因：当某些东西坏了时，他们需要修复它。你希望他们对你为他们编写的软件有这种感觉。当他们对操作系统有同样的感觉时，你不应该感到惊讶。&lt;/p&gt;
&lt;p&gt;几年前，一个风险投资家朋友告诉我他参与的一家新创业公司。听起来很有希望。但下次我和他交谈时，他们说他们决定在Windows NT上构建软件，并刚刚聘请了一位非常有经验的NT开发者担任首席技术官。当我听到这个时，我想，这些人注定要失败。第一，CTO不可能是第一流黑客，因为要成为杰出的NT开发者，他必须自愿多次使用NT，我无法想象一个伟大的黑客会这样做；第二，即使他很好，如果项目必须在NT上构建，他也很难雇佣到优秀的人才。[2]&lt;/p&gt;
&lt;h2 id="最后的边疆"&gt;最后的边疆&lt;/h2&gt;
&lt;p&gt;除了软件，黑客最重要的工具可能是他的办公室。大公司认为办公室空间的功能是表达等级。但黑客不仅仅为此使用办公室：他们将办公室作为思考的地方。如果你是一家技术公司，他们的思想就是你的产品。所以让黑客在嘈杂、分散注意力的环境中工作，就像在油漆厂空气中充满烟尘。&lt;/p&gt;
&lt;p&gt;连环漫画Dilbert有很多关于隔间的说法，这是有充分理由的。我认识的所有黑客都鄙视它们。仅仅被中断的前景就足以阻止黑客处理困难问题。如果你想在有隔间的办公室里完成真正的工作，你只有两个选择：在家工作，或在别人不在的时候早点来、晚点来或周末来。公司没有意识到这是出了问题的标志吗？办公室环境应该是有助于你工作的东西，而不是你尽管如此才工作的东西。&lt;/p&gt;
&lt;p&gt;像思科这样的公司为每个人都有一间隔间而自豪，即使是CEO。但他们不像他们想象的那么先进；显然他们仍然将办公室空间视为等级的标志。还要注意，思科以很少在内部进行产品开发而闻名。他们通过收购创造新技术的创业公司来获得新技术——大概在那里黑客确实有安静的工作地方。&lt;/p&gt;
&lt;p&gt;一家理解黑客需求的大公司是微软。我曾经看到过微软的招聘广告，有一张门的大图片。为我们工作，前提是，我们会给你一个可以真正完成工作的地方。而且你知道，微软在大公司中之所以非凡，是因为他们能够在内部开发软件。也许不太好，但足够好。&lt;/p&gt;
&lt;p&gt;如果公司希望黑客有生产力，他们应该看看他们在家里做什么。在家里，黑客可以自己安排事情，以便完成最多的工作。当黑客在家工作时，他们不在嘈杂、开放的空间工作；他们在有门的房间里工作。他们在舒适、社区化的地方工作，周围有人，需要思考时可以散步，而不是在停车场英亩的玻璃盒子里。他们有可以在感到疲倦时小睡的沙发，而不是坐在桌前昏迷，假装工作。没有吸尘器人员在每晚黑客黄金时间呼啸而过。没有会议，或者，天哪，公司静修或团队建设练习。当你看他们在电脑上做什么时，你会发现它强化了我之前关于工具的说法。他们在工作时可能必须使用Java和Windows，但在家里，当他们可以自由选择时，你更可能发现他们使用Perl和Linux。&lt;/p&gt;
&lt;p&gt;事实上，这些关于Cobol或Java是最流行语言的统计数据可能会产生误导。如果我们想知道什么工具最好，我们应该看的是黑客在可以自由选择时选择什么——也就是说，在他们自己的项目中。当你问这个问题时，你会发现开源操作系统已经占据了主导市场份额，排名第一的语言可能是Perl。&lt;/p&gt;
&lt;h2 id="有趣"&gt;有趣&lt;/h2&gt;
&lt;p&gt;除了好工具，黑客想要有趣的项目。什么使项目有趣？嗯，显然像隐形飞机或特效软件那样明显性感的应用程序会很有趣。但任何应用程序如果提出新颖的技术挑战，都可能很有趣。所以很难预测黑客会喜欢哪些问题，因为有些只有在工作的人发现新的解决方案时才变得有趣。在ITA（编写Orbitz内部软件的公司）之前，从事机票价格搜索的人可能认为这是可以想象的最无聊的应用程序。但ITA通过以更雄心勃勃的方式重新定义问题使其变得有趣。&lt;/p&gt;
&lt;p&gt;我认为谷歌也发生了同样的事情。当谷歌成立时，所谓门户网站的传统看法是搜索很无聊且不重要。但谷歌的人不认为搜索无聊，这就是为什么他们做得这么好。&lt;/p&gt;
&lt;p&gt;这是管理者可以有所作为的领域。就像父母对孩子说，我打赌你不能在十分钟内清理整个房间，一个好的管理者有时可以将问题重新定义为更有趣的问题。史蒂夫·乔布斯似乎特别擅长这个，部分原因只是因为他有高标准。在Mac之前有很多小型、便宜的电脑。他将问题重新定义为：制造一个漂亮的。这可能比任何胡萝卜或大棒更能驱动开发者。&lt;/p&gt;
&lt;p&gt;他们确实做到了。当Mac首次出现时，你甚至不必打开它就知道它会很好；你可以从机箱上看出来。几周前我在剑桥的街上走，在某个人的垃圾里我看到了一个似乎是Mac手提箱的东西。我往里看，里面有一台Mac SE。我带回家插上电，它启动了。快乐的Macintosh脸，然后是finder。我的天，它是如此简单。就像&amp;hellip;&amp;hellip;谷歌。&lt;/p&gt;
&lt;p&gt;黑客喜欢为有高标准的人工作。但仅仅精确是不够的。你必须坚持正确的事情。这通常意味着你必须自己是一个黑客。我偶尔看到过关于如何管理程序员的文章。真的应该有两篇文章：一篇是关于如果你自己是程序员该做什么，另一篇是关于如果你不是该做什么。而第二篇可能可以浓缩成两个词：放弃。&lt;/p&gt;
&lt;p&gt;问题不在于日常管理。真正好的黑客几乎是自我管理的。问题是，如果你不是黑客，你无法分辨谁是好黑客。一个类似的问题解释了为什么美国汽车如此丑陋。我称之为设计悖论。你可能认为你可以通过雇佣伟大的设计师来设计产品而使产品美丽。但如果你自己没有好品味，你如何认识好设计师？根据定义，你无法从他的作品集中判断。你也不能看他获得的奖项或工作，因为在设计领域，就像在大多数领域一样，这些往往是由时尚和交际驱动的，而实际能力排在第三位。没有办法：你无法在不知道什么是美丽的情况下管理一个旨在生产美丽的过程。美国汽车丑陋是因为美国汽车公司由品味差的人经营。&lt;/p&gt;
&lt;p&gt;这个国家的许多人认为品味是难以捉摸的，甚至是轻浮的。它都不是。要推动设计，管理者必须是公司产品最苛刻的用户。如果你真的有好品味，你可以像史蒂夫·乔布斯那样，使满足你成为好人喜欢解决的问题。&lt;/p&gt;
&lt;h2 id="讨厌的小问题"&gt;讨厌的小问题&lt;/h2&gt;
&lt;p&gt;很容易说什么样的问题不是有趣的：那些你必须解决很多讨厌小问题，而不是解决几个大的、清晰的问题。最糟糕的项目之一是为充满错误的软件编写接口。另一个是当你必须为个别客户的复杂和定义不清的需求定制东西。对黑客来说，这类项目是千刀万剐的死亡。&lt;/p&gt;
&lt;p&gt;讨厌小问题的区别特征是你从中学不到任何东西。编写编译器很有趣，因为它教你什么是编译器。但为有错误的软件编写接口教不了你任何东西，因为错误是随机的。[3] 所以不仅仅是挑剔使好黑客避免讨厌的小问题。这更多是自我保护的问题。处理讨厌的小问题会让你变笨。好黑客避免它就像模特避免奶酪汉堡一样。&lt;/p&gt;</description></item><item><title>你本不该有老板</title><link>https://linguista.cn/person/paul_graham/essays_zh/boss/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/boss/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/boss/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/boss.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/boss.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/boss.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="你本不该有老板"&gt;你本不该有老板&lt;/h1&gt;
&lt;p&gt;想要创业吗？获得Y Combinator的资助。&lt;/p&gt;
&lt;p&gt;2008年3月，2008年6月修订&lt;/p&gt;
&lt;p&gt;技术倾向于将正常与自然分开。我们的身体不是被设计来吃富裕国家人们吃的食物，也不是来进行这么少的运动。我们的工作方式可能也有类似的问题：正常的工作对我们智力的伤害可能就像白面粉或糖对我们身体的伤害一样。&lt;/p&gt;
&lt;p&gt;在与创业创始人共事几年后，我开始怀疑这一点。我现在已经与200多个创始人合作过，我注意到在自己创业公司工作的程序员与在大组织工作的程序员之间有明显的区别。我不会说创始人看起来更快乐， necessarily；创业可能非常有压力。也许最好的说法是，他们在你的身体在长跑时比坐在沙发上吃甜甜圈时更快乐的意义上更快乐。&lt;/p&gt;
&lt;p&gt;虽然他们在统计上不正常，但创业创始人似乎在以对人类更自然的方式工作。&lt;/p&gt;
&lt;p&gt;去年我在非洲，看到很多以前只在动物园里见过的野生动物。它们看起来多么不同，这很了不起。特别是狮子。野外的狮子似乎有十倍的活力。它们就像是不同的动物。我怀疑为自己工作对人类来说感觉更好，就像生活在野外对像狮子这样广泛活动的捕食者来说一定感觉更好一样。动物园的生活更容易，但这不是它们被设计的生活。&lt;/p&gt;
&lt;h2 id="树"&gt;树&lt;/h2&gt;
&lt;p&gt;在大公司工作有什么不自然的？问题的根源在于人类不是被设计在如此大的群体中工作。&lt;/p&gt;
&lt;p&gt;当你在野外看到动物时，你注意到的另一件事是，每个物种都在特定大小的群体中茁壮成长。一群黑斑羚可能有100只成年个体；狒狒可能20只；狮子很少10只。人类似乎也被设计在群体中工作，我读到的关于狩猎采集者的内容与组织研究和我的经验相符，表明理想的大小大致是：8人的群体工作良好；到20人时它们变得难以管理；50人的群体真的很笨拙。[1] 无论上限是多少，我们显然不是被设计在几百人的群体中工作。然而——由于与技术而非人性有关的原因——很多人在拥有数百或数千员工的公司工作。&lt;/p&gt;
&lt;p&gt;公司知道那么大的群体无法工作，所以它们将自己分成足够小以一起工作的单位。但为了协调这些，它们必须引入新的东西：老板。&lt;/p&gt;
&lt;p&gt;这些较小的群体总是按树状结构排列。你的老板是你的群体附着到树上的点。但是当你使用这个技巧将大群体分成小群体时，会发生一些奇怪的事情，我从未听有人明确提及。在你上一级的群体中，你的老板代表你的整个群体。10个经理的群体不仅仅是10个人以通常方式一起工作的群体。它真的是群体的群体。这意味着为了让10个经理的群体像只是10个个体一样一起工作，每个经理工作的群体必须像一个人一样工作——工人和经理之间只能分享相当于一个人的自由。&lt;/p&gt;
&lt;p&gt;在实践中，一群人永远无法像一个人一样行动。但在以这种方式分成群体的大组织中，压力总是在那个方向上。每个群体都尽力像人类被设计工作的小个体群体一样工作。创造它的目的就是如此。当你传播这种约束时，结果是每个人获得的行动自由与整个树的大小成反比。[2]&lt;/p&gt;
&lt;p&gt;任何在大组织工作过的人都感受到过这一点。即使你的群体只有10个人，你也能感受到在100名员工的公司和10,000名员工的公司工作的区别。&lt;/p&gt;
&lt;h2 id="玉米糖浆"&gt;玉米糖浆&lt;/h2&gt;
&lt;p&gt;大组织中的10人群体是一种虚假的部落。你与之互动的人数大约是正确的。但缺少了一些东西：个人主动性。狩猎采集部落的自由度要高得多。领导者比部落其他成员有更多的权力，但他们通常不像老板那样告诉他们做什么和什么时候做。&lt;/p&gt;
&lt;p&gt;这不是你老板的错。真正的问题是在你上面的层级群体中，你的整个群体是一个虚拟的人。你的老板只是约束传递给你的方式。&lt;/p&gt;
&lt;p&gt;所以在大组织中的10人群体中工作同时感觉既对又错。表面上它感觉像是你被设计工作的群体类型，但缺少了一些重要的东西。大公司的工作就像高果糖玉米糖浆：它具有你喜欢的东西的一些品质，但灾难性地缺乏其他品质。&lt;/p&gt;
&lt;p&gt;确实，食物是解释通常工作方式有什么问题的绝佳隐喻。&lt;/p&gt;
&lt;p&gt;例如，在大公司工作是默认要做的事情，至少对程序员来说。能有多糟糕？嗯，食物很清楚地显示了这一点。如果你今天被随机放在美国的一个地方，你周围几乎所有的食物对你都是有害的。人类不是被设计来吃白面粉、精制糖、高果糖玉米糖浆和氢化植物油的。然而，如果你分析普通杂货店的内容，你可能会发现这四种成分占了大部分热量。&amp;ldquo;正常&amp;quot;食物对你非常糟糕。唯一吃人类被设计实际吃的东西的人是伯克利的几个穿Birkenstock鞋的怪人。&lt;/p&gt;
&lt;p&gt;如果&amp;quot;正常&amp;quot;食物对我们如此糟糕，为什么它如此普遍？主要有两个原因。一是它有更直接的吸引力。你可能在吃那个披萨一小时后感觉糟糕，但吃前几口感觉很好。另一个是规模经济。生产垃圾食品可以规模化；生产新鲜蔬菜不行。这意味着（a）垃圾食品可以非常便宜，（b）值得花很多钱来营销它。&lt;/p&gt;
&lt;p&gt;如果人们必须在便宜、大量营销、短期有吸引力的东西和昂贵、晦涩、长期有吸引力的东西之间选择，你认为大多数人会选择哪个？&lt;/p&gt;
&lt;p&gt;工作也是如此。普通的麻省理工学院毕业生想在谷歌或微软工作，因为它是一个公认的品牌，很安全，他们会立即得到高薪。这是他们午餐吃的披萨的工作等价物。缺点只有在以后才会显现，而且只是一种模糊的不适感。&lt;/p&gt;
&lt;p&gt;同时，创业公司的创始人和早期员工，就像伯克利的穿Birkenstock鞋的怪人：虽然只是人口的极少数，但他们是像人类被设计那样生活的人。在人工世界里，只有极端主义者自然地生活。&lt;/p&gt;
&lt;h2 id="程序员"&gt;程序员&lt;/h2&gt;
&lt;p&gt;大公司工作的限制性对程序员来说尤其困难，因为编程的本质是构建新事物。销售人员每天做大致相同的推销；支持人员回答大致相同的问题；但一旦你写了一段代码，你就不需要再写它了。所以像程序员被设计那样工作的程序员总是在创造新事物。当你是一个组织的一部分，其结构给予每个人的自由与树的大小成反比时，当你做新事情时，你会面临阻力。&lt;/p&gt;
&lt;p&gt;这似乎是规模大的必然结果。即使在最聪明的公司也是如此。最近我与一个创始人交谈，他考虑一毕业就创业，但去了谷歌工作，因为他认为在那里会学到更多。他没有学到预期的那么多。程序员通过做来学习，而他想做的大多数事情，他都不能——有时因为公司不让他，但常常因为公司的代码不让他。在遗留代码的阻力、在如此大的组织中进行开发的开销，以及其他群体拥有的接口施加的限制之间，他只能尝试他想做的事情的一小部分。他说他在自己的创业公司学到了更多，尽管他必须做公司的所有杂事以及编程，因为至少当他编程时，他可以做任何他想做的事情。&lt;/p&gt;
&lt;p&gt;下游的障碍向上游传播。如果不允许你实现新想法，你就会停止有新想法。反之亦然：当你做任何你想做的事情时，你对做什么有更多的想法。所以为自己工作使你的大脑更强大，就像低限制排气系统使发动机更强大一样。&lt;/p&gt;
&lt;p&gt;为自己工作不一定要意味着创业，当然。但在大公司的常规工作和自己的创业公司之间做决定的程序员可能会在创业中学到更多。&lt;/p&gt;
&lt;p&gt;通过调整你工作的公司规模，你可以调整你获得的自由量。如果你创办公司，你将有最多的自由。如果你成为前10名员工之一，你将拥有几乎与创始人一样多的自由。即使是100人的公司也会感觉与1000人的公司不同。&lt;/p&gt;
&lt;p&gt;在小公司工作不确保自由。大组织的树状结构设置了自由的的上限，而不是下限。小公司的头可能仍然选择成为暴君。关键是大组织被其结构 compelled 成为暴君。&lt;/p&gt;
&lt;h2 id="后果"&gt;后果&lt;/h2&gt;
&lt;p&gt;这对组织和个人都有真正的后果。一个是公司随着规模变大不可避免地会变慢，无论它们多么努力保持创业精神。这是每个大组织被迫采用的树状结构的结果。&lt;/p&gt;
&lt;p&gt;或者说，大组织只有避免树状结构才能避免变慢。而且由于人性限制了可以一起工作的群体规模，我能想象的更大群体避免树状结构的唯一方法是没有结构：让每个群体实际上是独立的，像市场经济组成部分那样一起工作。&lt;/p&gt;
&lt;p&gt;这可能值得探索。我怀疑已经有一些高度可分的业务倾向于这种方式。但我不知道有任何技术公司这样做。&lt;/p&gt;
&lt;p&gt;公司可以做的比构建自己为海绵少的一件事是：保持小规模。如果我是对的，那么在每个阶段保持公司尽可能小确实有回报。特别是技术公司。这意味着雇佣最好的人加倍重要。平庸的雇佣伤害你两次：他们完成的更少，但它们也使你变大，因为你需要更多人来解决给定的问题。&lt;/p&gt;
&lt;p&gt;对个人来说结果是一样的：瞄准小规模。在大组织工作总是会糟糕，组织越大，越糟糕。&lt;/p&gt;
&lt;p&gt;几年前我写的一篇文章中，我建议即将毕业的 seniors 在创办自己的公司之前为另一家公司工作几年。我现在要修改这个。如果你愿意，可以为另一家公司工作，但只在小公司，如果你想创办自己的创业公司，就继续吧。&lt;/p&gt;
&lt;p&gt;我建议大学毕业生不要立即创业的原因是我觉得大多数人会失败。而且他们会失败。但有雄心的程序员做自己的事情并失败比去大公司工作更好。当然他们会学到更多。他们甚至在财务上可能更好。很多二十出头的人陷入债务，因为他们的费用增长比离开学校时看起来如此高的工资更快。至少如果你创业并失败，你的净资产将是零而不是负数。[3]&lt;/p&gt;</description></item><item><title>创造者的日程表，管理者的日程表</title><link>https://linguista.cn/person/paul_graham/essays_zh/makersschedule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/makersschedule/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/makersschedule/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/makersschedule.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/makersschedule.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/makersschedule.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="创造者的日程表管理者的日程表"&gt;创造者的日程表，管理者的日程表&lt;/h1&gt;
&lt;p&gt;2009年7月&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&amp;hellip;仅仅意识到有约会，有时就会困扰一整天。&amp;rdquo;
– 查尔斯·狄更斯&lt;/p&gt;
&lt;p&gt;程序员如此讨厌会议的一个原因是，他们与其他人的日程表类型不同。会议对他们来说成本更高。&lt;/p&gt;
&lt;p&gt;有两种类型的日程表，我称之为管理者的日程表和创造者的日程表。管理者的日程表是为老板设计的。它体现在传统的约会簿中，每天被划分为一小时的时间段。如果需要，你可以为单个任务屏蔽几个小时，但默认情况下你每小时都会改变正在做的事情。&lt;/p&gt;
&lt;p&gt;当你这样使用时间时，与某人会面只是一个实际问题。在你的日程表中找一个空闲的时间段，预约他们，就完成了。&lt;/p&gt;
&lt;p&gt;大多数有权力的人都在管理者的日程表上。这是指挥的日程表。但还有一种使用时间的方式在创造事物的人中很常见，比如程序员和作家。他们通常更喜欢至少以半天为单位使用时间。你无法在一小时的时间内很好地写作或编程。那 barely 是足够开始的时间。&lt;/p&gt;
&lt;p&gt;当你按照创造者的日程表工作时，会议是灾难性的。一个会议可以毁掉整个下午，因为它把下午分成两部分，每部分都太小，无法做任何困难的事情。而且你必须记得去参加会议。这对于管理者的日程表上的人来说不是问题。下一个小时总是有事情；唯一的问题是什么。但当创造者的日程表上的人有会议时，他们必须考虑它。&lt;/p&gt;
&lt;p&gt;对于创造者日程表上的人来说，开会就像抛出异常。它不仅让你从一个任务切换到另一个任务；它改变了你工作的模式。&lt;/p&gt;
&lt;p&gt;我发现一个会议有时会影响一整天。一个会议通常会破坏至少半天，通过打乱上午或下午。此外，有时还有连锁效应。如果我知道下午会被打断，我在上午开始一些雄心勃勃的事情的可能性就会稍微降低。我知道这听起来可能过于敏感，但如果你是创造者，想想你自己的情况。当想到有一整天的时间可以工作，没有任何约会时，你的精神不会振奋吗？嗯，这意味着当你没有这样的时间时，你的精神会相应地低落。而雄心勃勃的项目按定义接近你能力的极限。士气的小幅下降就足以扼杀它们。&lt;/p&gt;
&lt;p&gt;每种类型的日程表本身都运作良好。当它们相遇时，问题就出现了。由于大多数有权力的人都在管理者的日程表上，他们有能力让每个人都按照他们的频率共振，如果他们想的话。但更聪明的人会克制自己，如果他们知道为他们工作的一些人需要大块的时间来工作。&lt;/p&gt;
&lt;p&gt;我们的情况是不寻常的。几乎所有的投资者，包括我认识的所有风险投资家，都在管理者的日程表上。但Y Combinator按照创造者的日程表运行。Rtm、Trevor和我这样做是因为我们一直如此，Jessica也主要是如此，因为她与我们同步。&lt;/p&gt;
&lt;p&gt;如果开始有更多像我们这样的公司，我不会感到惊讶。我怀疑创始人可能越来越能够抵抗，或至少推迟，转变为管理者，就像几十年前他们开始能够抵抗从牛仔裤换成西装一样。&lt;/p&gt;
&lt;p&gt;我们如何在创造者的日程表上为这么多创业公司提供建议？通过使用在创造者的日程表中模拟管理者日程表的经典设备：办公时间。我每周几次留出一大块时间来见我们资助的创始人。这些时间块是在我工作日的末尾，我写了一个注册程序，确保给定办公时间内的所有预约都集中在末尾。因为它们在我的一天结束时到来，这些会议从来不会中断。（除非他们的工作日与我的同时结束，会议可能会中断他们的，但既然他们预约了，对他们来说一定是值得的。）在繁忙时期，办公时间有时会变得足够长，以至于压缩了一天，但它们从不中断它。&lt;/p&gt;
&lt;p&gt;当我们在90年代为自己的创业公司工作时，我发展出了另一个划分一天的技巧。我每天从晚餐编程到大约凌晨3点，因为在晚上没有人能打断我。然后我会睡到大约上午11点，进来工作直到晚餐，我称之为&amp;quot;业务事情&amp;quot;。我从来没有用这些术语思考过，但实际上我每天都有两个工作日，一个在管理者的日程表上，一个在创造者的日程表上。&lt;/p&gt;
&lt;p&gt;当你按照管理者的日程表工作时，你可以做一些在创造者的日程表上永远不想做的事情：你可以进行试探性会议。你可以见某人只是为了互相认识。如果你的日程表有空闲的时间段，为什么不呢？也许结果你们可以在某种程度上互相帮助。&lt;/p&gt;
&lt;p&gt;硅谷的商界人士（实际上是整个世界）一直在进行试探性会议。如果你在管理者的日程表上，它们实际上是免费的。它们如此普遍，以至于有独特的语言来提议它们：例如，说你想要&amp;quot;喝杯咖啡&amp;quot;。&lt;/p&gt;
&lt;p&gt;但是，如果你在创造者的日程表上，试探性会议的成本非常可怕。这使我们陷入某种困境。每个人都认为，像其他投资者一样，我们在管理者的日程表上运行。所以他们向我们介绍他们认为我们应该见面的人，或者给我们发邮件提议我们喝杯咖啡。在这一点上，我们有两个选择，都不好：我们可以与他们见面，失去半天的工作；或者我们可以尝试避免与他们见面，可能会冒犯他们。&lt;/p&gt;
&lt;p&gt;直到最近，我们自己对问题的根源还不清楚。我们只是想当然地认为我们必须要么破坏我们的日程表，要么冒犯人。但现在我意识到发生了什么，也许有第三种选择：写一些解释两种类型日程表的东西。也许最终，如果管理者的日程表和创造者的日程表之间的冲突开始被更广泛地理解，它会变得不那么成问题。&lt;/p&gt;
&lt;p&gt;我们这些在创造者日程表上的人愿意妥协。我们知道我们必须有一定数量的会议。我们只要求那些在管理者日程表上的人理解成本。&lt;/p&gt;
&lt;p&gt;感谢 Sam Altman、Trevor Blackwell、Paul Buchheit、Jessica Livingston 和 Robert Morris 阅读本文的草稿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何做你喜欢的事&lt;/li&gt;
&lt;li&gt;好的和坏的拖延&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>另一条道路</title><link>https://linguista.cn/person/paul_graham/essays_zh/road/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/road/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/road/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/road.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/road.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/road.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="另一条道路"&gt;另一条道路&lt;/h1&gt;
&lt;p&gt;2001年9月&lt;/p&gt;
&lt;p&gt;（本文解释了为什么下一代软件的大部分可能是基于服务器的，这对程序员意味着什么，以及这种新型软件为什么是创业公司的绝佳机会。本文源自在BBN实验室的一次演讲。）&lt;/p&gt;
&lt;p&gt;1995年夏天，我的朋友Robert Morris和我决定创办一家创业公司。当时，围绕Netscape IPO的公关活动正如火如荼地进行，媒体上有很多关于电子商务的讨论。那时网络上可能只有三十家实际的商店，都是手工制作的。如果将来会有很多在线商店，就需要制作它们的软件，所以我们决定写一些这样的软件。&lt;/p&gt;
&lt;p&gt;在最初的一周左右，我们打算将其制作成一个普通的桌面应用程序。然后有一天我们想到让软件在我们的Web服务器上运行，使用浏览器作为界面。我们尝试重写软件使其在Web上工作，很明显这是正确的方法。如果我们编写的软件在服务器上运行，对用户和我们自己都会容易得多。&lt;/p&gt;
&lt;p&gt;结果证明这是一个好计划。现在，作为Yahoo Store，这个软件是最受欢迎的在线商店构建器，拥有约14,000个用户。&lt;/p&gt;
&lt;p&gt;当我们开始Viaweb时，几乎没有人理解我们说软件在服务器上运行是什么意思。直到一年后Hotmail推出，人们才开始理解。现在每个人都知道这是一个有效的方法。我们现在所做的事情有了一个名字：应用服务提供商，或ASP。&lt;/p&gt;
&lt;p&gt;我认为下一代软件的大部分都将按照这个模型编写。即使是损失最大的微软，似乎也看到将一些东西移出桌面是不可避免的。如果软件从桌面移到服务器上，对开发者来说将意味着一个完全不同的世界。本文描述了我们作为这个新世界的首批访客所看到的令人惊讶的事情。就软件确实转移到服务器上的程度而言，我在这里描述的就是未来。&lt;/p&gt;
&lt;h2 id="下一件大事"&gt;下一件大事？&lt;/h2&gt;
&lt;p&gt;当我们回顾桌面软件时代时，我想我们会惊叹于人们忍受的不便，就像我们现在惊叹于早期车主忍受的不便一样。在最初的二三十年里，你必须是一个汽车专家才能拥有汽车。但汽车是一个如此巨大的进步，以至于很多不是汽车专家的人也想拥有它们。&lt;/p&gt;
&lt;p&gt;计算机现在正处于这个阶段。当你拥有桌面计算机时，你最终会学到比你想要知道的更多关于其内部情况的知识。但超过一半的美国家庭都拥有一台。我母亲有一台计算机，她用它来收发邮件和记账。大约一年前，她收到Apple的一封信，为她提供新操作系统的折扣，这让她感到担忧。当一个65岁的女性只想用计算机来收发邮件和记账时，却不得不考虑安装新的操作系统，这就有问题了。普通用户甚至不应该知道&amp;quot;操作系统&amp;quot;这个词，更不用说&amp;quot;设备驱动程序&amp;quot;或&amp;quot;补丁&amp;quot;了。&lt;/p&gt;
&lt;p&gt;现在有另一种交付软件的方式可以拯救用户免于成为系统管理员。基于Web的应用程序是在Web服务器上运行并使用Web页面作为用户界面的程序。对于普通用户来说，这种新型软件将比桌面软件更容易、更便宜、更便携、更可靠，而且通常更强大。&lt;/p&gt;
&lt;p&gt;有了基于Web的软件，大多数用户除了他们使用的应用程序外，不必考虑任何其他事情。所有混乱、变化的东西都将位于某处的服务器上，由擅长这种事情的人维护。因此，你通常不需要特定的计算机来使用软件。你只需要一个带有键盘、屏幕和Web浏览器的东西。也许它会有无线互联网接入。也许它也会是你的手机。无论它是什么，都将是消费电子产品：价格约200美元，人们主要根据外观选择的东西。你将在互联网服务上花费比硬件更多的钱，就像你现在对电话所做的那样。[1]&lt;/p&gt;
&lt;p&gt;点击到达服务器并返回需要大约十分之一秒，所以重度交互软件的用户，如Photoshop，仍然希望计算在桌面上进行。但如果你看大多数人使用计算机做的那种事情，十分之一秒的延迟不会成为问题。我母亲真的不需要桌面计算机，有很多像她这样的人。&lt;/p&gt;
&lt;h2 id="用户的胜利"&gt;用户的胜利&lt;/h2&gt;
&lt;p&gt;我家附近有一辆车，保险杠上贴着&amp;quot;死也不愿不便&amp;quot;。大多数人，在大多数时候，会选择需要最少工作的选择。如果基于Web的软件获胜，那将是因为它更方便。对于用户和开发者来说，它似乎都会更方便。&lt;/p&gt;
&lt;p&gt;使用纯基于Web的应用程序，你只需要一个连接到互联网的浏览器。所以你可以在任何地方使用基于Web的应用程序。当你在桌面计算机上安装软件时，你只能在该计算机上使用它。更糟糕的是，你的文件被困在那台计算机上。随着人们习惯网络，这种模式的不便越来越明显。&lt;/p&gt;
&lt;p&gt;这里的开端是基于Web的电子邮件。现在数百万人意识到，无论你在哪里，都应该能够访问电子邮件。如果你能看到你的邮件，为什么不能看到你的日历？如果你能和同事讨论文档，为什么不能编辑它？为什么你的任何数据都应该被困在某个远处桌子的计算机上？&lt;/p&gt;
&lt;p&gt;&amp;ldquo;你的计算机&amp;quot;的整个概念正在消失，被&amp;quot;你的数据&amp;quot;所取代。你应该能够从任何计算机访问你的数据。或者更确切地说，任何客户端，而客户端不一定是计算机。&lt;/p&gt;
&lt;p&gt;客户端不应该存储数据；它们应该像电话一样。事实上，它们可能会变成电话，或者反之亦然。随着客户端变小，你有另一个理由不在它们上保存数据：随身携带的东西可能会丢失或被盗。把PDA留在出租车里就像磁盘崩溃，只是你的数据交给了别人而不是被蒸发掉了。&lt;/p&gt;
&lt;p&gt;使用纯基于Web的软件，你的数据和应用程序都不会保存在客户端上。所以你不需要安装任何东西来使用它。当没有安装时，你不必担心安装出错。应用程序和你的操作系统之间不可能存在不兼容性，因为软件不在你的操作系统上运行。&lt;/p&gt;
&lt;p&gt;因为它不需要安装，所以在你&amp;quot;购买&amp;quot;之前尝试基于Web的软件将是容易且常见的。你应该期望能够免费试用任何基于Web的应用程序，只需访问提供它的网站即可。在Viaweb，我们的整个网站就像一个大箭头，指向用户试驾。&lt;/p&gt;
&lt;p&gt;试驾后，注册服务只需要填写一个简短的表格（越简短越好）。这应该是用户必须做的最后工作。有了基于Web的软件，你应该无需额外付费、做任何工作，甚至可能无需知道就能获得新版本。&lt;/p&gt;
&lt;p&gt;升级不会像现在那样令人震惊。随着时间的推移，应用程序将悄然变得更强大。这需要开发者付出一些努力。他们必须设计软件，使其能够在不使用户困惑的情况下更新。这是一个新问题，但有解决方法。&lt;/p&gt;
&lt;p&gt;有了基于Web的应用程序，每个人都使用相同的版本，错误一旦发现就可以修复。所以基于Web的软件应该比桌面软件的错误少得多。在Viaweb，我怀疑我们任何时候有过十个已知的错误。这比桌面软件好几个数量级。&lt;/p&gt;
&lt;p&gt;基于Web的应用程序可以同时被多个人使用。这对于协作应用程序来说显然是一个优势，但我敢打赌，一旦用户意识到这是可能的，他们会开始在大多数应用程序中想要这个功能。例如，让两个人编辑同一个文档通常是有用的。Viaweb允许多个用户同时编辑一个站点，更多是因为这是编写软件的正确方式，而不是因为我们期望用户想要这样做，但结果证明很多人确实这样做了。&lt;/p&gt;
&lt;p&gt;当你使用基于Web的应用程序时，你的数据会更安全。磁盘崩溃不会成为过去的事情，但用户不会再听到它们。它们将发生在服务器集群中。提供基于Web应用程序的公司实际上会进行备份——不仅因为他们会有真正的系统管理员担心这些事情，而且因为丢失用户数据的ASP将陷入巨大的麻烦。当人们在自己的磁盘崩溃中丢失数据时，他们不会太生气，因为他们只能生自己的气。当公司为他们丢失数据时，他们会更生气。&lt;/p&gt;
&lt;p&gt;最后，基于Web的软件应该对病毒不那么脆弱。如果客户端除了浏览器外不运行任何东西，运行病毒的机会就更少，本地也没有数据可以损坏。攻击服务器本身的程序会发现它们防御得很好。[2]&lt;/p&gt;
&lt;p&gt;对于用户来说，基于Web的软件压力会更小。我认为如果你查看普通Windows用户的内心，你会发现对符合这种描述的软件有着巨大且基本未被利用的渴望。释放出来，它可能是一股强大的力量。&lt;/p&gt;
&lt;h2 id="代码之城"&gt;代码之城&lt;/h2&gt;
&lt;p&gt;对于开发者来说，基于Web和桌面软件之间最显著的区别是，基于Web的应用程序不是单一的代码片段。它将是不同类型程序的集合，而不是单一的大二进制文件。因此设计基于Web的软件更像设计城市而不是建筑：除了建筑物，你还需要道路、路标、公用设施、警察和消防部门，以及增长和各种灾难的计划。&lt;/p&gt;
&lt;p&gt;在Viaweb，软件包括相当大的应用程序，用户直接与之对话；这些程序使用的程序；在后台持续运行寻找问题的程序；如果出现问题尝试重新启动事物的程序；偶尔运行以编译统计信息或构建搜索索引的程序；我们明确运行以垃圾收集资源或移动或恢复数据的程序；假装是用户的程序（以测量性能或暴露错误）；诊断网络问题的程序；进行备份的程序；外部服务的接口；驱动令人印象深刻的表盘集合显示实时服务器统计的软件（对访客来说很受欢迎，但对我们来说也是不可或缺的）；对开源软件的修改（包括错误修复）；以及大量的配置文件和设置。在我们被Yahoo收购后，Trevor Blackwell编写了一个精彩的程序，可以在不关闭商店的情况下将商店迁移到全国的新服务器。程序通过传呼机呼叫我们，向用户发送传真和电子邮件，与信用卡处理商进行交易，并通过套接字、管道、http请求、ssh、udp数据包、共享内存和文件相互交谈。Viaweb的一部分甚至由程序的缺失组成，因为Unix安全的关键之一是不运行人们可能用来闯入服务器的不必要实用程序。&lt;/p&gt;
&lt;p&gt;这并不以软件结束。我们花了很多时间思考服务器配置。我们自己从组件构建服务器——部分是为了省钱，部分是为了得到我们想要的东西。我们必须考虑我们的上游ISP是否与所有骨干网有足够快的连接。我们与RAID供应商连续约会。&lt;/p&gt;
&lt;p&gt;但硬件不仅仅是要担心的事情。当你控制它时，你可以为用户做更多。对于桌面应用程序，你可以指定某些最低硬件要求，但你不能添加更多。如果你管理服务器，你可以一步让所有用户能够传呼别人，或发送传真，或通过电话发送命令，或处理信用卡等，只需安装相关硬件即可。我们总是寻找用硬件添加功能的新方法，不仅因为它让用户高兴，而且作为将自己与竞争对手区分开来的方式——竞争对手要么因为他们销售桌面软件，要么通过ISP转售基于Web的应用程序，不能直接控制硬件。&lt;/p&gt;
&lt;p&gt;因为基于Web应用程序中的软件将是程序的集合而不是单一的二进制文件，它可以用多种不同的语言编写。当你编写桌面软件时，你实际上被迫用与底层操作系统相同的语言编写应用程序——即C和C++。因此，这些语言（尤其是在非技术人员如经理和风险投资家中）被认为是&amp;quot;严肃&amp;quot;软件开发的语言。但这只是桌面软件必须交付方式的人工产物。对于基于服务器的软件，你可以使用任何你想要的语言。[3] 今天，许多顶级黑客使用远离C和C++的语言：Perl、Python，甚至Lisp。&lt;/p&gt;
&lt;p&gt;有了基于服务器的软件，没有人能告诉你使用什么语言，因为你控制整个系统，一直到硬件。不同的语言适合不同的任务。你可以为每个任务使用最适合的语言。当你有竞争对手时，&amp;ldquo;你可以&amp;quot;意味着&amp;quot;你必须&amp;rdquo;（我们稍后会回到这一点），因为如果你不利用这种可能性，你的竞争对手会。&lt;/p&gt;
&lt;p&gt;我们的大多数竞争对手使用C和C++，这使得他们的软件明显 inferior，因为（除其他外），他们无法解决CGI脚本的无状态性问题。如果你要改变什么，所有的改变都必须在一个页面上发生，底部有一个更新按钮。正如我在其他地方写过的，通过使用许多人仍然认为是研究语言的Lisp，我们能够让Viaweb编辑器的行为更像桌面软件。&lt;/p&gt;
&lt;h2 id="发布"&gt;发布&lt;/h2&gt;
&lt;p&gt;在这个新世界中最重要的变化之一是你进行发布的方式。在桌面软件业务中，进行发布是一个巨大的创伤，整个公司都在努力推出一个单一的、巨大的代码片段。明显的比较会让人联想到这个过程和最终产品。&lt;/p&gt;
&lt;p&gt;有了基于服务器的软件，你可以像为自己编写的程序那样几乎实时地进行更改。你以一系列增量更改而不是偶尔的大爆炸形式发布软件。一个典型的桌面软件公司可能一年进行一两次发布。在Viaweb，我们通常一天进行三到五次发布。&lt;/p&gt;</description></item><item><title>垃圾邮件过滤计划</title><link>https://linguista.cn/person/paul_graham/essays_zh/spam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/spam/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/spam/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/spam.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/spam.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/spam.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="垃圾邮件过滤计划"&gt;垃圾邮件过滤计划&lt;/h1&gt;
&lt;p&gt;2002年8月&lt;/p&gt;
&lt;p&gt;（本文描述了在我们构建的用于测试Arc的反垃圾邮件网络邮件阅读器中使用的垃圾邮件过滤技术。改进的算法在《更好的贝叶斯过滤》中有描述。）我认为可以阻止垃圾邮件，而基于内容的过滤器是实现这一目标的方法。垃圾邮件发送者的致命弱点是他们的消息。他们可以绕过你设置的任何其他障碍。至少到目前为止是这样。但他们必须传递他们的信息，无论是什么。如果我们能够编写识别他们消息的软件，就没有办法能够绕过它。&lt;/p&gt;
&lt;p&gt;对收件人来说，垃圾邮件很容易识别。如果你雇佣某人阅读你的邮件并丢弃垃圾邮件，他们会毫无困难地做到这一点。我们需要做多少工作，除了人工智能之外，来自动化这个过程？&lt;/p&gt;
&lt;p&gt;我认为我们将能够用相当简单的算法解决这个问题。事实上，我发现你可以使用不比单个词的垃圾邮件概率的贝叶斯组合更多的东西来相当好地过滤现在的垃圾邮件。使用一个稍微调整的（如下所述）贝叶斯过滤器，我们现在在每1000封垃圾邮件中遗漏少于5封，误报率为0。&lt;/p&gt;
&lt;p&gt;统计方法通常不是人们编写垃圾邮件过滤器时首先尝试的方法。大多数黑客的第一本能是尝试编写识别垃圾邮件单个特征的软件。你看着垃圾邮件，想，这些家伙竟然敢给我发送以&amp;quot;亲爱的朋友&amp;quot;开头的邮件，或者主题行全是大写并以八个感叹号结尾的邮件。我可以用大约一行代码过滤掉这些东西。&lt;/p&gt;
&lt;p&gt;于是你这样做了，开始时它有效。几个简单的规则会大量减少你收到的垃圾邮件。仅仅查找&amp;quot;点击&amp;quot;这个词就会捕获我垃圾邮件语料库中79.7%的邮件，误报率只有1.2%。&lt;/p&gt;
&lt;p&gt;在尝试统计方法之前，我花了大约六个月编写查找单个垃圾邮件特征的软件。我发现的是，识别最后百分之几的垃圾邮件变得非常困难，而且当我使过滤器更严格时，我得到了更多的误报。&lt;/p&gt;
&lt;p&gt;误报是被错误识别为垃圾邮件的无辜邮件。对于大多数用户来说，错过合法邮件比收到垃圾邮件糟糕一个数量级，因此产生误报的过滤器就像带有死亡风险的痤疮治疗。&lt;/p&gt;
&lt;p&gt;用户收到的垃圾邮件越多，他们注意到一封无辜邮件坐在垃圾邮件文件夹中的可能性就越小。奇怪的是，你的垃圾邮件过滤器越好，误报就变得越危险，因为当过滤器真的很好时，用户更可能忽略它们捕获的一切。&lt;/p&gt;
&lt;p&gt;我不知道为什么我这么长时间才尝试统计方法。我想这是因为我对试图自己识别垃圾邮件特征上了瘾，好像我在和垃圾邮件发送者玩某种竞争游戏。（非黑客通常不会意识到这一点，但大多数黑客非常有竞争心。）当我尝试统计分析时，我立即发现它比我聪明得多。它当然发现了像&amp;quot;virtumundo&amp;quot;和&amp;quot;teens&amp;quot;这样的术语是垃圾邮件的良好指标。但它还发现&amp;quot;per&amp;quot;和&amp;quot;FL&amp;quot;和&amp;quot;ff0000&amp;quot;是垃圾邮件的良好指标。事实上，&amp;ldquo;ff0000&amp;rdquo;（亮红色的html）结果证明和任何色情术语一样是垃圾邮件的良好指标。&lt;/p&gt;
&lt;p&gt;以下是我如何进行统计过滤的概述。我从一个垃圾邮件语料库和一个非垃圾邮件语料库开始。目前每个语料库中大约有4000条消息。我扫描每个语料库中每条消息的整个文本，包括标题、嵌入的html和javascript。我目前认为字母数字字符、破折号、撇号和美元符号是标记的一部分，其他一切都是标记分隔符。（这里可能还有改进的空间。）我忽略全是数字的标记，我也忽略html注释，甚至不将它们视为标记分隔符。&lt;/p&gt;
&lt;p&gt;我计算每个标记（目前忽略大小写）在每个语料库中出现的次数。在这个阶段，我最终得到两个大的哈希表，每个语料库一个，将标记映射到出现次数。&lt;/p&gt;
&lt;p&gt;接下来我创建第三个哈希表，这次将每个标记映射到包含它的电子邮件是垃圾邮件的概率，我计算如下[1]：(let ((g (* 2 (or (gethash word good) 0))) (b (or (gethash word bad) 0))) (unless (&amp;lt; (+ g b) 5) (max .01 (min .99 (float (/ (min 1 (/ b nbad)) (+ (min 1 (/ g ngood)) (min 1 (/ b nbad))))))))) 其中word是我们计算其概率的标记，good和bad是我在第一步创建的哈希表，ngood和nbad分别是非垃圾邮件和垃圾邮件的数量。&lt;/p&gt;</description></item><item><title>基于Web应用的Lisp</title><link>https://linguista.cn/person/paul_graham/essays_zh/lwba/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/lwba/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/lwba/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/lwba.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/lwba.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/lwba.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="基于web应用的lisp"&gt;基于Web应用的Lisp&lt;/h1&gt;
&lt;p&gt;在《击败平均值》的链接被发布在slashdot上之后，一些读者希望更详细地了解我们在Viaweb中使用Lisp获得的具体技术优势。对于那些感兴趣的人，以下是我2001年4月在剑桥BBN实验室的演讲节选。&lt;/p&gt;
&lt;p&gt;BBN演讲节选（ASCII）&lt;/p&gt;</description></item><item><title>大学本科</title><link>https://linguista.cn/person/paul_graham/essays_zh/college/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/college/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/college/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/college.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/college.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/college.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="大学本科"&gt;大学本科&lt;/h1&gt;
&lt;p&gt;想要创业吗？获得Y Combinator的资助。2005年3月&lt;/p&gt;
&lt;p&gt;（本文的部分内容始于对给我写信提问的学生的回复。）&lt;/p&gt;
&lt;p&gt;最近我收到了几封计算机科学本科生的邮件，询问在大学应该做什么。我可能不是最好的建议来源，因为我在大学主修的是哲学。但我上了很多计算机科学的课程，以至于大多数计算机科学专业的学生都以为我是其中一员。我当然是个黑客，至少如此。&lt;/p&gt;
&lt;h2 id="黑客技术"&gt;黑客技术&lt;/h2&gt;
&lt;p&gt;在大学里应该做什么才能成为一个优秀的黑客？你可以做两件主要的事情：在编程方面变得非常出色，并学习很多关于特定、酷炫问题的知识。这两件事被证明是等价的，因为每一件都会推动你去做另一件。&lt;/p&gt;
&lt;p&gt;在编程方面变得出色的方法是（a）大量地（b）解决难题。而让你自己解决难题的方法是从事一些非常引人入胜的项目。这个项目很可能不是课堂作业。我的朋友罗伯特在本科时通过编写网络软件学到了很多。他的一个项目是将哈佛连接到阿帕网；它曾经是最初的节点之一，但到1984年连接已经断开了。这项工作不仅不是为了课堂，而且因为他把所有时间都花在上面而忽视了学业，他被学校开除了一年。最终一切都平衡了，现在他是麻省理工学院的教授。但如果你不走那个极端，你可能会更快乐；这当时给他带来了很多担忧。&lt;/p&gt;
&lt;p&gt;在编程方面变得出色的另一种方法是找到其他擅长编程的人，学习他们的知识。程序员倾向于根据他们做的工作类型和他们使用的工具将自己分成部落，有些部落比其他部落更聪明。看看你周围，看看聪明的人似乎在做什么；通常都有原因。&lt;/p&gt;
&lt;p&gt;你周围一些最聪明的人是教授。所以找到有趣工作的一个方法是自愿担任研究助理。教授对那些能为他们解决繁琐的系统管理类型问题的人特别感兴趣，所以这是进门的一种方式。他们害怕的是那些不可靠和为了简历而工作的人。助理往往导致工作量净增加，这太常见了。所以你必须明确你会带来净减少。&lt;/p&gt;
&lt;p&gt;如果他们说不要，不要气馁。拒绝几乎总是比被拒绝者想象的要少个人色彩。继续下一个。（这也适用于约会。）&lt;/p&gt;
&lt;p&gt;小心，因为虽然大多数教授都很聪明，但并不是所有人都从事有趣的工作。教授必须发表新颖的结果才能推进他们的职业生涯，但在更有趣的研究领域竞争更激烈。所以那些不那么有抱负的教授所做的是发表一系列论文，这些论文的结论之所以新颖，是因为没有其他人关心它们。你最好避免这些。&lt;/p&gt;
&lt;p&gt;我从来没有当过研究助理，所以推荐那条路线我觉得有点不诚实。我通过写自己的东西学会了编程，特别是通过尝试逆向工程Winograd的SHRDLU。我对那个程序的痴迷就像母亲对新生婴儿一样。&lt;/p&gt;
&lt;p&gt;无论独自工作有什么缺点，优点是这个项目完全是你自己的。你永远不必妥协或询问任何人的许可，如果你有新的想法，你可以坐下来开始实现它。&lt;/p&gt;
&lt;p&gt;在你自己的项目中，你不必担心新颖性（像教授那样）或盈利能力（像企业那样）。唯一重要的是项目在技术上的难度，这与应用的性质没有相关性。像数据库这样的&amp;quot;严肃&amp;quot;应用在技术上往往是琐碎和枯燥的（如果你曾遭受失眠之苦，试试阅读关于数据库的技术文献），而像游戏这样的&amp;quot;琐碎&amp;quot;应用往往非常复杂。我确信有一些游戏公司正在开发的产品，其智力内容比大学计算机科学系底部十分之九的研究还要多。&lt;/p&gt;
&lt;p&gt;如果我现在在大学，我可能会从事图形学工作：例如，一个网络游戏，或者一个3D动画工具。当我是本科生时，没有足够的周期让图形学变得有趣，但现在很难想象有什么更有趣的工作。&lt;/p&gt;
&lt;h2 id="数学"&gt;数学&lt;/h2&gt;
&lt;p&gt;当我在大学时，很多教授相信（或至少希望）计算机科学是数学的一个分支。这种想法在哈佛最强烈，那里直到1980年代甚至没有计算机科学专业；在此之前，人们必须主修应用数学。但在康奈尔大学也几乎一样糟糕。当我告诉可怕的康威教授我对人工智能感兴趣（那时是个热门话题）时，他告诉我应该主修数学。我仍然不确定他认为人工智能需要数学，还是他认为人工智能是无稽之谈，主修一些严谨的学科会治愈我这种愚蠢的抱负。&lt;/p&gt;
&lt;p&gt;事实上，作为黑客，你需要的数学比大多数大学系愿意承认的要少得多。我认为你需要的除了高中数学加上计算理论的一些概念外，不需要太多。如果你想避免编写n²算法，你必须知道什么是n²算法。当然，除非你计划编写数学应用。例如，机器人技术全是数学。&lt;/p&gt;
&lt;p&gt;虽然对于大多数类型的黑客技术，你从字面上不需要数学，在知道1001个微分公式技巧的意义上，数学本身非常值得学习。它几乎是任何类型工作的宝贵隐喻来源。出于这个原因，我希望我在大学时学了更多数学。&lt;/p&gt;
&lt;p&gt;像许多人一样，我在童年时被数学虐待过。我学会将数学视为公式的集合，这些公式既不美丽，与我的生活也没有任何关系（尽管试图将它们翻译成&amp;quot;文字问题&amp;quot;），但必须记住以便在考试中取得好成绩。&lt;/p&gt;
&lt;p&gt;你在大学能做的最有价值的事情之一可能是了解数学的真正含义。这可能不容易，因为许多优秀的数学家都是糟糕的老师。虽然有许多关于数学的通俗书籍，但似乎很少有好的。我能想到的最好的是W.W.索耶的。当然还有欧几里得。&lt;/p&gt;
&lt;h2 id="一切"&gt;一切&lt;/h2&gt;
&lt;p&gt;托马斯·赫胥黎说&amp;quot;尝试了解一切的一些事情和一件事的一切。&amp;ldquo;大多数大学都以这个理想为目标。&lt;/p&gt;
&lt;p&gt;但什么是&amp;quot;一切&amp;rdquo;？对我来说，它意味着人们在诚实解决难题的过程中学到的一切。所有这样的工作往往是相关的，因为一个领域的想法和技术通常可以成功移植到其他领域。即使是那些看起来相当遥远的领域。例如，我写文章的方式和写软件的方式一样：我坐下来尽可能快地敲出一个蹩脚的版本1，然后花几周时间重写它。&lt;/p&gt;
&lt;p&gt;解决难题本身并不足够。中世纪的炼金术士在解决一个难题，但他们的方法是如此虚假，以至于研究它几乎学不到什么，除了可能关于人们欺骗自己的能力。不幸的是，我在大学尝试学习的那种人工智能有同样的缺陷：一个非常困难的问题，轻率地使用完全不足的技术来解决。大胆？更接近欺诈。社会科学也相当虚假，因为它们受到知识时尚的太大影响。如果一个物理学家遇到100年前的同事，他可以教他一些新东西；如果一个心理学家遇到100年前的同事，他们只会陷入意识形态争论。是的，当然，通过上心理学课你会学到一些东西。重点是，通过上另一个系的课，你会学到更多。&lt;/p&gt;
&lt;p&gt;在我看来，值得学习的系是数学、硬科学、工程、历史（特别是经济和社会历史，以及科学史）、建筑学和古典文学。艺术史概论课程可能是值得的。现代文学很重要，但了解它的方法就是阅读。我对音乐了解不够，无法发表意见。&lt;/p&gt;
&lt;p&gt;你可以跳过社会科学、哲学和最近为应对政治压力而创建的各个系。这些领域当然谈论重要问题。但它们谈论问题的方式是无用的。例如，哲学谈论我们对彼此的义务等；但你可以从一位明智的祖母或E.B.怀特那里学到更多关于这方面的知识，而不是从一位学术哲学家。&lt;/p&gt;
&lt;p&gt;我在这里是从经验出发说话。当人们嘲笑克林顿说&amp;quot;这取决于&amp;rsquo;是&amp;rsquo;这个词的含义是什么&amp;quot;时，我可能应该感到被冒犯。我在大学上了大约五门关于&amp;quot;是&amp;quot;这个词的含义的课。&lt;/p&gt;
&lt;p&gt;找出哪些领域值得学习的另一种方法是创建辍学图表。例如，我知道许多人从数学转向计算机科学，因为他们发现数学太难了，没有人做相反的事情。人们不会无缘无故地做困难的事情；除非一个问题相应地（或至少log(n)）更有回报，否则没有人会去解决更难的问题。所以可能数学比计算机科学更值得学习。通过类似的比较，你可以为大学中的所有系制作一个图表。在底部你会发现智力内容最少的科目。&lt;/p&gt;
&lt;p&gt;如果你使用这种方法，你会得到与我刚才给出的大致相同的答案。&lt;/p&gt;
&lt;p&gt;语言课程是一个异常。我认为它们更好地被视为课外活动，就像陶艺课程一样。当结合在讲这种语言的国家生活一段时间时，它们会更有用。我一时兴起在大一时学习了阿拉伯语。这是很多工作，唯一持久的好处是一种奇怪的能力来识别闪米特语词根，以及对人们如何识别单词的一些见解。&lt;/p&gt;
&lt;p&gt;工作室艺术和创意写作课程是变数。通常你不会被教太多：你只是在老师模糊的监督下做（或不做）你想做的任何事情，然后坐在一起为彼此的创作提供&amp;quot;批评&amp;quot;。但写作和艺术都是人们诚实解决的非常困难的问题，所以它们值得做，特别是如果你能找到一位好老师。&lt;/p&gt;
&lt;h2 id="工作"&gt;工作&lt;/h2&gt;
&lt;p&gt;当然，大学生必须考虑的不仅仅是学习。还有两个实际问题需要考虑：工作和研究生院。&lt;/p&gt;
&lt;p&gt;理论上，通识教育不应该提供职业培训。但每个人都知道这有点谎言。每所大学的黑客都学习实用技能，而且不是偶然的。&lt;/p&gt;
&lt;p&gt;为找工作而学习的内容取决于你想要的工作类型。如果你想在大公司工作，学习如何在Windows上编写Blub程序。如果你想在一家酷的小公司或研究实验室工作，学习在Linux上使用Ruby会更好。如果你想创办自己的公司，我认为这会越来越普遍，掌握你能找到的最强大的工具，因为你将要与竞争对手比赛，他们将是你的马。&lt;/p&gt;
&lt;p&gt;你应该在大学学习的技能和工作中使用的技能之间没有直接的相关性。在大学里你应该目标稍微高一些。&lt;/p&gt;
&lt;p&gt;在锻炼中，足球运动员可能卧推300磅，尽管在比赛过程中他可能永远不必施加类似的力量。同样，如果你的教授试图让你学习比工作中需要的更先进的东西，可能不仅仅是因为他们是学者，脱离现实世界。他们可能在试图用你的大脑举重。&lt;/p&gt;
&lt;p&gt;你在课堂上写的程序与你将在现实世界中写的程序在三个关键方面不同：它们很小；你可以从头开始；问题通常是人为的和预定的。在现实世界中，程序更大，往往涉及现有代码，通常需要你在解决问题之前弄清楚问题是什么。&lt;/p&gt;
&lt;p&gt;你不必等到离开（甚至进入）大学才学习这些技能。例如，如果你想学习如何处理现有代码，你可以为开源项目做贡献。你想要为之工作的雇主会对此印象深刻，就像课堂作业的好成绩一样。&lt;/p&gt;
&lt;p&gt;在现有的开源项目中，你在第三种技能上没有太多练习，即决定要解决什么问题。但没有什么能阻止你开始自己的新项目。好雇主会对这更印象深刻。&lt;/p&gt;
&lt;p&gt;你应该尝试解决什么类型的问题？回答这个问题的一种方法是询问你作为用户需要什么。例如，我偶然发现了一个很好的垃圾邮件过滤算法，因为我想停止接收垃圾邮件。现在我希望我有一个邮件阅读器，能以某种方式防止我的收件箱填满。我倾向于使用我的收件箱作为待办事项列表。但这就像用螺丝刀开瓶子；人们真正想要的是一个开瓶器。&lt;/p&gt;
&lt;h2 id="研究生院"&gt;研究生院&lt;/h2&gt;
&lt;p&gt;研究生院怎么样？你应该去吗？你如何进入一所好的研究生院？&lt;/p&gt;
&lt;p&gt;原则上，研究生院是研究的专业培训，除非你想把研究作为职业，否则你不应该去。然而，获得计算机科学博士学位的人中有一半没有进入研究界。我去研究生院不是为了成为教授。我去是因为我想学到更多。&lt;/p&gt;</description></item><item><title>将程序装在脑中</title><link>https://linguista.cn/person/paul_graham/essays_zh/head/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/head/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/head/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/head.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/head.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/head.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="将程序装在脑中"&gt;将程序装在脑中&lt;/h1&gt;
&lt;p&gt;2007年8月&lt;/p&gt;
&lt;p&gt;一个优秀的程序员密集地工作在他自己的代码上时，可以像数学家把持一个他在解决的问题那样把持它。数学家不像学校教的那样在纸上工作来回答问题。他们在脑子里做得更多：他们试图充分理解问题空间，能够像漫步在你成长房屋的记忆中那样漫步其中。在最佳状态下，编程也是如此。你把整个程序装在脑中，你可以随意操纵它。&lt;/p&gt;
&lt;p&gt;这在项目开始时特别有价值，因为最初最重要的是能够改变你正在做的事情。不仅仅是以不同的方式解决问题，而是改变你正在解决的问题。&lt;/p&gt;
&lt;p&gt;你的代码是你对你正在探索的问题的理解。所以只有当你把代码装在脑中时，你才真正理解这个问题。&lt;/p&gt;
&lt;p&gt;把程序装进脑中并不容易。如果你离开一个项目几个月，当你回到它时，可能需要几天才能真正再次理解它。即使你在积极地处理一个程序，每天开始工作时也需要半小时才能把它装进脑中。这是最好的情况。在典型办公条件下工作的普通程序员永远不会进入这种模式。或者更戏剧性地说，在典型办公条件下工作的普通程序员永远不会真正理解他们正在解决的问题。&lt;/p&gt;
&lt;p&gt;即使是最优秀的程序员并不总是把他们正在处理的整个程序都装在脑中。但你可以做一些事情来帮助：&lt;/p&gt;
&lt;h2 id="避免干扰"&gt;避免干扰。&lt;/h2&gt;
&lt;p&gt;干扰对许多类型的工作都是有害的，但对编程尤其有害，因为程序员倾向于在他们能处理的细节极限上运作。&lt;/p&gt;
&lt;p&gt;干扰的危险不在于它持续多久，而在于它使你的大脑混乱的程度。程序员可以离开办公室去吃个三明治而不会失去脑中的代码。但错误的干扰可以在30秒内抹去你的大脑。&lt;/p&gt;
&lt;p&gt;奇怪的是，有计划的干扰可能比没有计划的干扰更糟。如果你知道一小时后有个会议，你甚至不会开始处理困难的事情。&lt;/p&gt;
&lt;h2 id="长时间工作"&gt;长时间工作。&lt;/h2&gt;
&lt;p&gt;因为每次开始处理一个程序都有固定成本，所以在几个长时段中工作比在许多短时段中工作更有效率。当然，总会有一个点，因为你累了而变得愚蠢。这因人而异。我听说过人们连续36小时编程，但我能管理的最多只有18小时左右，而且我在不超过12小时的块中工作效果最好。&lt;/p&gt;
&lt;p&gt;最佳状态不是你身体能忍受的极限。分解项目既有优势也有成本。有时当你在休息后回到问题时，你会发现你的潜意识留下了答案等着你。&lt;/p&gt;
&lt;h2 id="使用简洁的语言"&gt;使用简洁的语言。&lt;/h2&gt;
&lt;p&gt;更强大的编程语言使程序更短。程序员似乎至少部分地用他们用来编写程序的语言来思考程序。语言越简洁，程序越短，就越容易装进脑中并保持在那里。&lt;/p&gt;
&lt;p&gt;你可以通过使用一种称为自底向上编程的风格来增强强大语言的效果，在这种风格中，你编写多层程序，较低的层作为其上层的编程语言。如果你正确地这样做，你只需要把最顶层装在脑中。&lt;/p&gt;
&lt;h2 id="不断重写你的程序"&gt;不断重写你的程序。&lt;/h2&gt;
&lt;p&gt;重写程序通常会得到更清晰的设计。但即使不会，它也有优势：你必须完全理解一个程序才能重写它，所以没有更好的方法把它装进脑中。&lt;/p&gt;
&lt;h2 id="写可重读的代码"&gt;写可重读的代码。&lt;/h2&gt;
&lt;p&gt;所有程序员都知道写可读代码是好的。但你自己是最重要的读者。特别是在开始时；原型是与自己的对话。当为自己写作时，你有不同的优先事项。如果为别人写作，你可能不想让代码太密集。程序的某些部分可能最容易读，如果你把东西摊开，像一本入门教科书。而如果你写代码是为了让它容易重新装进脑中，最好追求简洁。&lt;/p&gt;
&lt;h2 id="小组工作"&gt;小组工作。&lt;/h2&gt;
&lt;p&gt;当你在脑中操纵一个程序时，你的视野倾向于停在你拥有的代码边缘。其他部分你理解得不够好，更重要的是，不能随意处理。所以程序员数量越少，项目就能越完全地变异。如果只有一个程序员，通常开始时是这样，你可以做全面重新设计。&lt;/p&gt;
&lt;h2 id="不要让多个人编辑同一段代码"&gt;不要让多个人编辑同一段代码。&lt;/h2&gt;
&lt;p&gt;你永远不会像理解自己的代码那样理解别人的代码。无论你多么彻底地读过它，你只是读了它，而不是写了它。所以如果一段代码由多个作者编写，他们中没有人像单个作者那样理解它。&lt;/p&gt;
&lt;p&gt;当然你不能安全地重新设计别人正在处理的东西。不仅仅是你必须请求许可。你甚至不让自己考虑这样的事情。重新设计有几个作者的代码就像改变法律；重新设计你独自控制的代码就像看到模糊图像的另一种解释。&lt;/p&gt;
&lt;p&gt;如果你想让几个人在一个项目上工作，把它分成组件，每个给一个人。&lt;/p&gt;
&lt;h2 id="从小开始"&gt;从小开始。&lt;/h2&gt;
&lt;p&gt;随着你对程序越来越熟悉，它变得更容易装在脑中。一旦你确信你已经完全探索了某些部分，你就可以开始把它们当作黑盒处理。但当你开始处理一个项目时，你被迫看到一切。如果你开始的问题太大，你可能永远无法完全把握它。所以如果你需要写一个大的、复杂的程序，开始的最佳方式可能不是为它写规范，而是写一个解决子集问题的原型。无论计划有什么优势，它们往往被能够把程序装在脑中的优势所抵消。&lt;/p&gt;
&lt;p&gt;程序员们经常偶然做到这八点，这很引人注目。有人有了一个新项目的想法，但因为不是正式批准的，他必须在下班时间做——结果证明更有生产力，因为没有干扰。受到他对新项目的热情驱使，他连续工作许多小时。因为它最初只是一个实验，他使用的是&amp;quot;脚本&amp;quot;语言而不是&amp;quot;生产&amp;quot;语言——实际上它强大得多。他完全重写程序几次；这对正式项目是不合理的，但这是爱的劳动，他想要它完美。而且因为除了他没有人会看到它，他省略了除笔记类型外的任何注释。他被迫在小团队中工作，因为他要么还没有告诉任何人这个想法，要么它看起来如此无望以至于不允许其他人在其上工作。即使有一个团队，他们也不能让多个人编辑同一段代码，因为它变化太快，那是不可能的。项目从小开始是因为想法一开始很小；他只是有一些很酷的黑客技巧想试试。&lt;/p&gt;
&lt;p&gt;更引人注目的是有多少正式批准的项目设法把这八件事都做错了。事实上，如果你看看大多数组织中软件编写的方式，几乎就像他们在故意做错事情。在某种意义上，他们确实如此。自从有组织以来，其定义性品质之一就是把个人当作可互换的部件。这对更可并行化的任务很有效，比如打仗。在历史上大部分时间里，一支训练有素的专业士兵军队可以指望打败一群个人战士，无论多么勇敢。但拥有想法不是很可并行化的。而程序就是：想法。&lt;/p&gt;
&lt;p&gt;组织不喜欢依赖个人天才的想法不仅仅是真的，它是同义反复。不这样做是组织定义的一部分。至少是我们当前组织概念的一部分。&lt;/p&gt;
&lt;p&gt;也许我们可以定义一种新型的组织，结合个人的努力而不要求他们可互换。可以说市场就是这种形式的组织，尽管把市场描述为退化情况可能更准确——当组织不可能时默认得到的情况。&lt;/p&gt;
&lt;p&gt;可能我们能做到的最好的是某种hack，比如让一个组织的编程部分以不同于其他部分的方式工作。也许最佳解决方案是大公司甚至不尝试内部开发想法，而只是购买它们。但无论解决方案是什么，第一步是意识到存在问题。&amp;ldquo;软件公司&amp;quot;这个短语本身就有矛盾。这两个词在相反的方向上拉扯。任何大型组织中的优秀程序员都会与之冲突，因为组织的设计是为了防止程序员追求的目标。&lt;/p&gt;
&lt;p&gt;优秀的程序员无论如何都能完成很多事情。但这往往需要对雇佣他们的组织进行实际上反抗的行为。如果更多的人理解程序员的行为方式是由他们工作的需求驱动的，这可能会有所帮助。他们长时间工作，期间推掉所有其他义务，直接投入编程而不是先写规范，重写已经工作的代码，这不是因为他们不负责任。他们更喜欢独自工作，或者对探头说你好的人咆哮，这不是因为他们不友好。这个表面上随机的令人讨厌习惯集合有一个单一的解释：将程序装在脑中的力量。&lt;/p&gt;
&lt;p&gt;无论理解这一点是否能帮助大型组织，它肯定能帮助他们的竞争对手。大公司的最弱点是他们不让个别程序员做出伟大的工作。所以如果你是一个小创业公司，这是攻击他们的地方。接手那些必须在一个大脑中解决的问题。&lt;/p&gt;
&lt;p&gt;感谢Sam Altman、David Greenspan、Aaron Iba、Jessica Livingston、Robert Morris、Peter Norvig、Lisa Randall、Emmett Shear、Sergei Tsarev和Stephen Wolfram阅读本文的草稿。&lt;/p&gt;</description></item><item><title>我所从事的工作</title><link>https://linguista.cn/person/paul_graham/essays_zh/worked/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/worked/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/worked/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/worked.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/worked.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/worked.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="我所从事的工作"&gt;我所从事的工作&lt;/h1&gt;
&lt;p&gt;2021年2月&lt;/p&gt;
&lt;p&gt;大学前，我在课外主要从事的两件事是写作和编程。我不写文章。我写的是当时初学写作的人应该写的东西，可能现在还是：短篇小说。我的故事很糟糕。几乎没有情节，只有感情强烈的角色，我以为这让他们显得深刻。&lt;/p&gt;
&lt;p&gt;我尝试编写的第一个程序是在我们学区用于当时称为&amp;quot;数据处理&amp;quot;的IBM 1401上。那时我在九年级，所以是13或14岁。学区的1401恰好在我们的初中的地下室，我的朋友Rich Draves和我获得了使用它的许可。那里就像一个小型的邦德反派巢穴，所有这些看起来外星般的机器——CPU、磁盘驱动器、打印机、卡片阅读器——坐在明亮的荧光灯下的抬高地板上。&lt;/p&gt;
&lt;p&gt;我们使用的语言是Fortran的早期版本。你必须在打孔卡上键入程序，然后将它们堆叠在卡片阅读器中并按下按钮将程序加载到内存中并运行。结果通常是在极其响亮的打印机上打印一些东西。&lt;/p&gt;
&lt;p&gt;我对1401感到困惑。我无法弄清楚如何使用它。回想起来，我能用它做的事情不多。程序的唯一输入形式是存储在打孔卡上的数据，而我没有任何存储在打孔卡上的数据。唯一的选择是做不依赖任何输入的事情，比如计算π的近似值，但我的数学知识不足以做任何有趣的这类事情。所以我不奇怪我不记得我编写的任何程序，因为它们不可能做太多事情。我最清晰的记忆是我了解到程序可能不会终止的那一刻，当我的一个程序没有终止时。在没有分时系统的机器上，这既是社会错误也是技术错误，正如数据中心经理的表情所表明的那样。&lt;/p&gt;
&lt;p&gt;有了微型计算机，一切都改变了。现在你可以有一台电脑就坐在你面前，在桌子上，它可以在运行时响应你的按键，而不仅仅是处理一堆打孔卡然后停止。[1]&lt;/p&gt;
&lt;p&gt;我的朋友中第一个拥有微型计算机的人是自己组装的。它是由Heathkit作为套件出售的。我生动地记得看着它坐在它前面，直接在电脑中键入程序时我感到多么印象深刻和羡慕。&lt;/p&gt;
&lt;p&gt;那时候计算机很昂贵，我纠缠了多年才说服我父亲在1980年左右买了一台TRS-80。当时黄金标准是Apple II，但TRS-80已经足够好了。这是我真正开始编程的时候。我编写了简单的游戏，一个预测我的模型火箭能飞多高的程序，以及我的父亲用来写至少一本书的文字处理器。内存中只有大约2页文本的空间，所以他一次写2页然后打印出来，但这比打字机好多了。&lt;/p&gt;
&lt;p&gt;虽然我喜欢编程，但我没打算在大学里学习它。在大学里我要学习哲学，这听起来强大得多。对于我天真的高中自我来说，这似乎是对终极真理的研究，相比之下其他领域研究的东西将只是领域知识。当我到达大学时，我发现其他领域占据了思想空间的很大部分，这些所谓的终极真理没有太多空间留下来。哲学似乎只剩下其他领域的人认为可以安全忽略的边缘情况。&lt;/p&gt;
&lt;p&gt;我18岁时无法把这些变成语言。我当时只知道我不断选修哲学课程，而它们总是很无聊。所以我决定转向AI。&lt;/p&gt;
&lt;p&gt;AI在1980年代中期很流行，但有两件事特别让我想要从事它：海因莱因的一部名为《月亮是一个严厉的女人》的小说，其中有一个名为Mike的智能计算机，以及一个展示Terry Winograd使用SHRDLU的PBS纪录片。我没有尝试重读《月亮是一个严厉的女人》，所以我不知道它老化得如何，但当我读它时，我完全被它的世界吸引住了。似乎只是时间问题，我们就会有Mike，当我看到Winograd使用SHRDLU时，似乎那时间将是几年。你所要做的就是教SHRDLU更多的词语。&lt;/p&gt;
&lt;p&gt;那时康奈尔大学没有任何AI课程，甚至研究生课程也没有，所以我开始尝试自学。这意味着学习Lisp，因为在那些日子Lisp被认为是AI的语言。当时常用的编程语言相当原始，程序员的想法也相应地如此。康奈尔的默认语言是一种类似Pascal的语言，称为PL/I，其他地方的情况也类似。学习Lisp如此迅速地扩展了我对程序的概念，以至于我花了几年时间才开始感觉到新的限制在哪里。这更像它；这是我对大学期望的。它没有像应该的那样在课堂上发生，但没关系。接下来的几年我很顺利。我知道我要做什么。&lt;/p&gt;
&lt;p&gt;对于我的本科论文，我逆向工程了SHRDLU。天啊，我多么喜欢在这个程序上工作。这是一段令人愉悦的代码，但更令人兴奋的是我的信念——现在很难想象，但在1985年并不独特——它已经在攀登智能的较低坡度。&lt;/p&gt;
&lt;p&gt;我进入了康奈尔的一个不要求你选择专业的项目。你可以选修任何你喜欢的课程，选择任何你喜欢放在学位上的东西。我当然选择了&amp;quot;人工智能&amp;quot;。当我拿到实际的物理文凭时，我惊恐地发现引号被包括在内，这使它们读作引号。当时这困扰着我，但现在看来可笑地准确，原因我即将发现。&lt;/p&gt;
&lt;p&gt;我申请了3所研究生院：MIT和耶鲁，当时以AI闻名，以及哈佛，我访问过因为Rich Draves去那里，也是Bill Woods的故乡，他发明了我在我的SHRDLU克隆中使用的解析器类型。只有哈佛接受了我，所以我就去了那里。&lt;/p&gt;
&lt;p&gt;我不记得那一刻是什么时候发生的，或者甚至是否有特定的时刻，但在研究生第一年期间，我意识到AI，当时实践的方式，是一个骗局。我的意思是那种AI，其中被告知&amp;quot;狗坐在椅子上&amp;quot;的程序将其转换为某种正式表示并将其添加到它知道的事情列表中。&lt;/p&gt;
&lt;p&gt;这些程序真正显示的是，自然语言的一个子集是一种形式语言。但是一个非常适当的子集。很明显，他们能做的事情和真正理解自然语言之间有一个不可逾越的鸿沟。事实上，这不仅仅是教SHRDLU更多词语的问题。整个AI方式，用代表概念的显式数据结构，是行不通的。它的 brokenness 确实，像经常发生的那样，产生了大量机会来写关于可以应用的各种创可贴的论文，但它永远不会给我们带来Mike。&lt;/p&gt;
&lt;p&gt;所以我环顾四周，看看我能从计划的残骸中挽救什么，那就是Lisp。我从经验中知道Lisp本身就很有趣，不仅仅是因为它与AI的联系，尽管那时这是人们关心它的主要原因。所以我决定专注于Lisp。事实上，我决定写一本关于Lisp黑客技术的书。想到我开始写那本书时对Lisp黑客技术了解得多么少，真是令人害怕。但是没有什么比写一本关于某件事的书更能帮助你学习它了。这本书，《On Lisp》，直到1993年才出版，但我在研究生院写了大部分。&lt;/p&gt;
&lt;p&gt;计算机科学是两个部分之间不安的联盟：理论和系统。理论家证明事情，系统家建造事情。我想建造事情。我对理论有很大的尊重——确实，一种偷偷摸摸的怀疑，认为它是两个部分中更令人钦佩的——但建造事情似乎令人兴奋得多。&lt;/p&gt;
&lt;p&gt;然而，系统工作的问题在于它不持久。你今天编写的任何程序，无论多好，最多几十年后就会过时。人们可能在脚注中提到你的软件，但没有人会实际使用它。而且，它会显得非常无力的工作。只有对领域历史有了解的人才会意识到，在它的时代，它曾经是好的。&lt;/p&gt;
&lt;p&gt;有一次，计算机实验室里有一些多余的施乐Dandelions。任何想要一个来玩的人都可以有一个。我短暂地被诱惑了，但按照现在的标准它们太慢了；有什么意义呢？也没有其他人想要一个，所以它们被运走了。这就是系统工作的下场。&lt;/p&gt;
&lt;p&gt;我不仅要建造事情，还要建造会持久的事情。&lt;/p&gt;
&lt;p&gt;在这种不满的状态下，我在1988年去CMU拜访Rich Draves，他在那里读研究生。有一天我去参观卡内基研究所，我小时候在那里花了很多时间。在那里看一幅画时，我意识到一些可能看起来显而易见的事情，但对我来说是一个巨大的惊喜。在那里，就在墙上，是一些你可以制造的东西，它会持久。绘画不会过时。一些最好的已经有几百年历史了。&lt;/p&gt;
&lt;p&gt;而且这是你可以谋生的事情。当然不像写软件那么容易，但我认为如果你真正勤奋且生活非常节俭，必须有可能赚足够的钱生存。作为艺术家，你可以真正独立。你不会有老板，甚至不需要获得研究经费。&lt;/p&gt;
&lt;p&gt;我一直喜欢看画。我能画画吗？我不知道。我从未想象过这是可能的。我在理智上知道人们制造艺术——它不是自发出现的——但制造它的人似乎是不同的物种。他们要么生活在很久以前，要么是在《生活》杂志的简介中做奇怪事情的神秘天才。实际上能够制造艺术，把这个动词放在这个名词前面，似乎几乎是奇迹性的。&lt;/p&gt;
&lt;p&gt;那年秋天我开始在哈佛选修艺术课程。研究生可以在任何系选修课程，我的导师Tom Cheatham非常随和。即使他知道我选修的奇怪课程，他也什么都没说。&lt;/p&gt;
&lt;p&gt;所以现在我在计算机科学博士项目中，却计划成为艺术家，却又真正热爱Lisp黑客技术和努力编写《On Lisp》。换句话说，像许多研究生一样，我精力充沛地从事多个不是我的论文的项目。&lt;/p&gt;
&lt;p&gt;我没有看到摆脱这种局面的方法。我不想退学，但我还能怎么出去呢？我记得当我的朋友Robert Morris因编写1988年互联网蠕虫而被康奈尔开除时，我羡慕他找到了如此壮观的方式来离开研究生院。&lt;/p&gt;
&lt;p&gt;然后在1990年4月的一天，墙上出现了一道裂缝。我遇到了Cheatham教授，他问我是否已经足够进展可以在那年六月毕业。我的论文一个字都没有写，但一定是我一生中最快的思考，我决定在剩下的5周左右的时间内尝试写一篇，尽可能重用《On Lisp》的部分，我能够毫无察觉地延迟回答&amp;quot;是的，我想是的。我几天内给你一些东西阅读。&amp;quot;&lt;/p&gt;
&lt;p&gt;我选择了continuations的应用作为主题。回想起来我应该写关于宏和嵌入式语言。那里有一个几乎未被探索的整个世界。但我只想离开研究生院，我快速写的论文足够了，勉强而已。&lt;/p&gt;
&lt;p&gt;与此同时，我在申请艺术学院。我申请了两所：美国的RISD，和佛罗伦萨的Accademia di Belli Arti，因为它是最古老的艺术学校，我想象它会很好。RISD接受了我，而我从未收到Accademia的回音，所以我去了普罗维登斯。&lt;/p&gt;</description></item><item><title>拖累盲区</title><link>https://linguista.cn/person/paul_graham/essays_zh/schlep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/schlep/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/schlep/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/schlep.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/schlep.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/schlep.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="拖累盲区"&gt;拖累盲区&lt;/h1&gt;
&lt;p&gt;2012年1月&lt;/p&gt;
&lt;p&gt;伟大的创业想法就在我们眼皮底下未被利用。我们看不到它们的一个原因是我称之为拖累盲区的现象。Schlep最初是一个意第绪语单词，但已经在美国通用。它意味着一项繁琐、不愉快的任务。&lt;/p&gt;
&lt;p&gt;没有人喜欢拖累，但黑客尤其不喜欢它们。大多数开始创业的黑客希望他们能够只写一些聪明的软件，把它放在某个服务器上，看着钱滚滚而来——而不必与用户交谈，或与其他公司谈判，或处理其他人的破损代码。也许这是可能的，但我还没有看到。&lt;/p&gt;
&lt;p&gt;我们在Y Combinator做的许多事情之一是教导黑客们拖累的不可避免性。不，你不能只通过写代码来创业。我记得我自己经历了这种认识。在1995年的某个时刻，我仍然试图说服自己我可以只通过写代码来创业。但我很快从经验中学到，拖累不仅是不可避免的，而且基本上就是商业的组成部分。&lt;/p&gt;
&lt;p&gt;一个公司是由它愿意承担的拖累来定义的。拖累应该像对待冷水游泳池一样处理：直接跳进去。这并不是说你应该刻意寻求不愉快的工作，而是说你永远不应该回避它，如果它在通往伟大事物的道路上。&lt;/p&gt;
&lt;p&gt;我们对拖累的厌恶最危险的部分是其中大部分是无意识的。你的无意识甚至不会让你看到涉及痛苦拖累的想法。这就是拖累盲区。&lt;/p&gt;
&lt;p&gt;这种现象不仅仅限于创业。大多数人不会有意识地决定不拥有与奥林匹克运动员一样好的身体状况。例如，他们的无意识为他们做决定，回避所涉及的工作。&lt;/p&gt;
&lt;p&gt;我所知道的拖累盲区最突出的例子是Stripe，或者更确切地说是Stripe的想法。十多年来，每个曾经不得不在线处理付款的黑客都知道这个体验有多痛苦。成千上万的人一定知道这个问题。然而当他们开始创业时，他们决定建立食谱网站，或者本地活动聚合器。为什么？为什么在你可以修复世界上最重要基础设施之一的组件时，要从事很少有人关心也没有人会为之付钱的问题？因为拖累盲区阻止人们甚至考虑修复付款的想法。&lt;/p&gt;
&lt;p&gt;可能没有人申请Y Combinator做食谱网站项目时首先问&amp;quot;我们应该修复付款，还是建立食谱网站？&amp;ldquo;然后选择了食谱网站。虽然修复付款的想法就在明面上，但他们从未看到它，因为他们的无意识回避所涉及的复杂性。你将不得不与银行达成协议。你怎么做到的？而且你在转移资金，所以你将不得不处理欺诈，以及试图闯入你服务器的人。而且可能还有各种法规需要遵守。开始像这样的创业公司比开始食谱网站创业公司要令人畏惧得多。&lt;/p&gt;
&lt;p&gt;这种可怕性使得雄心勃勃的想法具有双重价值。除了它们的内在价值之外，它们就像被低估的股票，因为在创始人中对它们的需求较少。如果你选择一个雄心勃勃的想法，你将有更少的竞争，因为其他人都会被所涉及的挑战吓倒。（这对于创业一般也是正确的。）&lt;/p&gt;
&lt;p&gt;你如何克服拖累盲区？坦率地说，对拖累盲区最有价值的解药可能是无知。大多数成功的创始人可能会说，如果他们在开始创业时知道他们必须克服的障碍，他们可能永远不会开始。也许这就是为什么最成功的创业公司经常有年轻创始人的原因之一。&lt;/p&gt;
&lt;p&gt;在实践中，创始人与问题一起成长。但似乎没有人能够预见到这一点，即使是更年长、更有经验的创始人。所以年轻创始人有优势的原因是他们犯两个错误，这些错误相互抵消。他们不知道他们能成长多少，但他们也不知道他们需要成长多少。年长的创始人只犯第一个错误。&lt;/p&gt;
&lt;p&gt;无知不能解决所有问题。有些想法如此明显地涉及令人担忧的拖累，任何人都能看到它们。你如何看到这样的想法？我推荐的技巧是自己退出画面。不要问&amp;quot;我应该解决什么问题？&amp;ldquo;而是问&amp;quot;我希望别人为我解决什么问题？&amp;ldquo;如果在Stripe之前有人不得不处理付款的人尝试问这个问题，Stripe会是他们首先希望的事情之一。&lt;/p&gt;
&lt;p&gt;现在成为Stripe已经太晚了，但世界上仍然有很多破损的东西，如果你知道如何看到它。&lt;/p&gt;
&lt;p&gt;感谢萨姆·奥特曼、保罗·布赫海特、帕特里克·克里森、亚伦·伊巴、杰西卡·利文斯顿、埃米特·谢尔和哈吉·塔加阅读本文的草稿。&lt;/p&gt;</description></item><item><title>欢迎来到Lisp</title><link>https://linguista.cn/person/paul_graham/essays_zh/acl2txtt1748944359/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/acl2txtt1748944359/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/acl2txtt1748944359/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="欢迎来到lisp"&gt;欢迎来到Lisp&lt;/h1&gt;
&lt;p&gt;本章旨在让你尽快开始编程。到本章结束时，你将了解足够的Common Lisp知识来开始编写程序。&lt;/p&gt;
&lt;h2 id="21-形式"&gt;2.1 形式&lt;/h2&gt;
&lt;p&gt;对于Lisp来说尤其如此，你通过使用它来学习它，因为Lisp是一种交互式语言。任何Lisp系统都包含一个称为toplevel的交互式前端。你将Lisp表达式输入到toplevel中，系统会显示它们的值。Lisp通常会显示一个提示符来告诉你它在等待你输入内容。许多Common Lisp实现使用&amp;gt;作为toplevel提示符。这就是我们在这里要使用的。&lt;/p&gt;
&lt;p&gt;最简单的Lisp表达式之一是整数。如果我们在提示符后输入1，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; 1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;系统将打印它的值，然后是另一个提示符，表示它准备好接受更多输入。在这种情况下，显示的值与我们输入的相同。像1这样的数字被称为求值为自身。&lt;/p&gt;
&lt;p&gt;当我们输入需要一些工作来求值的表达式时，生活变得更加有趣。例如，如果我们想要将两个数字相加，我们输入类似这样的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在表达式(+ 2 3)中，+被称为运算符，数字2和3被称为参数。在日常生活中，我们会将这个表达式写为2 + 3，但在Lisp中，我们将+运算符放在前面，后面跟着参数，整个表达式用一对括号括起来：(+ 2 3)。这被称为前缀表示法，因为运算符在前。&lt;/p&gt;
&lt;p&gt;这种写表达式的方式起初可能看起来很奇怪，但实际上这种表示法是Lisp最棒的特点之一。例如，如果我们想要将三个数字相加，在普通表示法中我们必须使用+两次，2 + 3 + 4，而在Lisp中我们只需添加另一个参数：(+ 2 3 4)&lt;/p&gt;
&lt;p&gt;我们通常使用+的方式是，它必须恰好有两个参数：一个在左边，一个在右边。前缀表示法的灵活性意味着，在Lisp中，+可以接受任意数量的参数，包括无参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;0
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;2
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;5
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3 4)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;9
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (+ 2 3 4 5)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;14
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为运算符可以接受不同数量的参数，我们需要括号来表示表达式的开始和结束。表达式可以嵌套。也就是说，表达式中的参数本身可能是复杂的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&amp;gt; (/ (- 7 1) (- 4 2))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;3
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用英语来说，这是七减一，除以四减二。&lt;/p&gt;</description></item><item><title>简洁即力量</title><link>https://linguista.cn/person/paul_graham/essays_zh/power/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/power/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/power/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/power.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/power.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/power.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="简洁即力量"&gt;简洁即力量&lt;/h1&gt;
&lt;p&gt;2002年5月&lt;/p&gt;
&lt;p&gt;&amp;ldquo;通过代数符号将大量意义压缩到一个小空间中，这是另一个有助于我们习惯性推理的因素。&amp;rdquo; - 查尔斯·巴贝奇，引自艾弗森的图灵奖演讲&lt;/p&gt;
&lt;p&gt;在LL1邮件列表上关于《书呆子的复仇》所提出问题的讨论中，保罗·普雷斯科德写了一些让我印象深刻的话。Python的目标是规范性和可读性，而不是简洁性。表面上看来，这对编程语言来说似乎是一个相当不利的评价。据我所知，简洁性=力量。如果是这样，那么替换后我们得到Python的目标是规范性和可读性，而不是力量。这似乎不是一个你想要做出的权衡（如果这确实是一个权衡的话）。这几乎等同于说Python的目标不是作为一种有效的编程语言。&lt;/p&gt;
&lt;p&gt;简洁性等于力量吗？在我看来，这是一个重要的问题，可能是对任何对语言设计感兴趣的人来说最重要的问题，直接面对这个问题会很有用。我还不确定答案是否是简单的&amp;quot;是&amp;quot;，但这似乎是一个很好的开始假设。&lt;/p&gt;
&lt;h2 id="假设"&gt;假设&lt;/h2&gt;
&lt;p&gt;我的假设是简洁性就是力量，或者足够接近，除了在病态的例子中，你可以将它们视为相同。&lt;/p&gt;
&lt;p&gt;在我看来，简洁性就是编程语言的意义所在。计算机对于直接用机器语言被告知要做什么同样满意。我认为我们开发高级语言的主要原因是获得杠杆作用，这样我们就可以用高级语言的10行代码来表达（更重要的是思考）需要1000行机器语言才能完成的事情。换句话说，高级语言的主要目的是使源代码更小。&lt;/p&gt;
&lt;p&gt;如果更小的源代码是高级语言的目的，而某种东西的力量是它实现其目的的程度，那么编程语言力量的衡量标准就是它使你的程序变得多小。&lt;/p&gt;
&lt;p&gt;相反，不能使你的程序更小的语言在编程语言应该做的事情上做得不好，就像一把不好切的刀或难以辨认的印刷品。&lt;/p&gt;
&lt;h2 id="衡量标准"&gt;衡量标准&lt;/h2&gt;
&lt;p&gt;但是从什么意义上来说更小呢？代码大小最常见的衡量标准是代码行数。但我认为这个衡量标准最常见是因为它最容易测量。我不认为有人真正相信它是程序长度的真正测试。不同的语言对于在一行中放多少内容有不同的约定；在C语言中，很多行只有一个或两个分隔符。&lt;/p&gt;
&lt;p&gt;另一个简单的测试是程序中的字符数，但这也不是很好；一些语言（例如Perl）只是使用比其他语言更短的标识符。&lt;/p&gt;
&lt;p&gt;我认为程序大小的更好衡量标准是元素的数量，其中元素是如果你画一个表示源代码的树，会成为不同节点的任何东西。变量或函数的名称是一个元素；整数或浮点数是一个元素；一段字面文本是一个元素；模式元素或格式指令是一个元素；新块是一个元素。有一些边界情况（-5是两个元素还是一个？）但我认为大多数情况对每种语言都是相同的，所以它们不会对比较产生太大影响。&lt;/p&gt;
&lt;p&gt;这个衡量标准需要充实，在特定语言的情况下可能需要解释，但我认为它试图衡量正确的东西，即程序拥有的部分数量。我认为在这个练习中你会画的树就是你为了构思程序而必须在头脑中构建的东西，它的大小与你必须做的工作量成正比，无论是写还是读。&lt;/p&gt;
&lt;h2 id="设计"&gt;设计&lt;/h2&gt;
&lt;p&gt;这种衡量标准可以让我们比较不同的语言，但至少对我而言，这不是它的主要价值。简洁性测试的主要价值是作为设计语言的指导。语言之间最有用的比较是同一种语言的两个潜在变体之间的比较。我能在语言中做什么来使程序更短？&lt;/p&gt;
&lt;p&gt;如果程序的概念负荷与其复杂性成正比，而给定的程序员可以容忍固定的概念负荷，那么这与问&amp;quot;我能做什么来让程序员完成最多工作？&amp;ldquo;是相同的。这在我看来与问&amp;quot;我如何设计一种好的语言？&amp;ldquo;是相同的。&lt;/p&gt;
&lt;p&gt;（顺便说一句，没有什么比设计语言更能明显地证明&amp;quot;所有语言都是等价的&amp;quot;这个老生常谈是错误的了。当你设计一种新语言时，你不断地比较两种语言——如果我做了x的语言，如果我没做x的语言——来决定哪个更好。如果这真是一个无意义的问题，你不妨抛硬币。）&lt;/p&gt;
&lt;p&gt;以简洁性为目标似乎是寻找新想法的好方法。如果你能做一些让许多不同程序更短的事情，这可能不是巧合：你可能发现了一个有用的新抽象。你甚至可以编写一个程序来帮助搜索源代码中的重复模式。在其他语言中，那些以简洁性著称的语言是寻找新想法的地方：Forth、Joy、Icon。&lt;/p&gt;
&lt;h2 id="比较"&gt;比较&lt;/h2&gt;
&lt;p&gt;据我所知，第一个写这些相关文章的人是弗雷德·布鲁克斯在《人月神话》中。他写道，无论使用什么语言，程序员每天似乎生成大致相同数量的代码。我在二十出头第一次读到这个时，这是一个很大的惊喜，似乎有巨大的含义。这意味着（a）让软件写得更快的方法是使用更简洁的语言，（b）花功夫这样做的人可以把不这样做的竞争对手远远甩在后面。&lt;/p&gt;
&lt;p&gt;布鲁克斯的假设，如果它是真的，似乎处于黑客精神的核心。从那以后的几年里，我密切关注我能得到的关于这个问题的任何证据，从正式研究到个人项目的轶事。我没有看到任何与他相矛盾的证据。&lt;/p&gt;
&lt;p&gt;我还没有看到我认为决定性的证据，我也不期望看到。像卢茨·普雷克特尔对编程语言的比较这样的研究，虽然产生了我期望的那种结果，但往往使用太短的问题，无法成为有意义的测试。语言的更好测试是在需要一个月编写的程序中发生什么。而真正的测试，如果你像我一样相信语言的主要目的是为了便于思考（而不仅仅是在你思考完后告诉计算机要做什么），是你能用它写出什么新东西。所以任何需要满足预定义规范的语言比较都在测试稍微错误的东西。&lt;/p&gt;
&lt;p&gt;语言的真正测试是你发现和解决新问题的能力，而不是你用它解决别人已经制定的问题的能力。这是两个完全不同的标准。在艺术中，像刺绣和马赛克这样的媒介，如果你事先知道你想制作什么，效果很好，但如果你不知道，就绝对糟糕。当你想在制作过程中发现图像时——就像你必须处理像人物图像这样复杂的东西一样——你需要使用更流动的媒介，如铅笔、水墨或油画。实际上，挂毯和马赛克的制作方式是先制作一幅画，然后复制它。（&amp;ldquo;卡通&amp;quot;这个词最初用来描述用于这个目的的画。）&lt;/p&gt;
&lt;p&gt;这意味着我们永远不可能对编程语言的相对力量有准确的比较。我们会有精确的比较，但不会有准确的比较。特别是，为了比较语言而进行的明确研究，因为它们可能会使用小问题，并且必须使用预定义的问题，往往会低估更强大语言的力量。&lt;/p&gt;
&lt;p&gt;来自现场的报告，虽然它们必然不如&amp;quot;科学&amp;quot;研究精确，但可能更有意义。例如，爱立信的乌尔夫·维格进行了一项研究，结论是Erlang比C++简洁4-10倍，开发软件的速度也相应更快：爱立信内部开发项目之间的比较表明，包括软件开发的所有阶段在内的每行/小时生产力相似，几乎与使用的语言（Erlang、PLEX、C、C++或Java）无关。区分不同语言的成为源代码量。该研究还明确处理了布鲁克斯书中只是隐含的一点（因为他测量的是调试代码的行数）：用更强大语言编写的程序往往有更少的错误。这本身就成为一个目的，在网络交换机等应用中，可能比程序员的生产力更重要。&lt;/p&gt;
&lt;h2 id="味道测试"&gt;味道测试&lt;/h2&gt;
&lt;p&gt;最终，我认为你必须凭直觉行事。用这种语言编程感觉如何？我认为找到（或设计）最好语言的方法是对语言让你思考的出色程度变得高度敏感，然后选择/设计感觉最好的语言。如果某些语言功能笨拙或限制性，别担心，你会知道的。&lt;/p&gt;
&lt;p&gt;这种高度敏感是有代价的。你会发现你无法忍受在笨拙的语言中编程。我觉得在没有宏的语言中编程是无法忍受的限制性，就像习惯动态类型的人发现必须回到必须声明每个变量类型、不能制作不同类型对象列表的语言中编程是无法忍受的限制性一样。我不是唯一一个这样的人。我知道许多Lisp黑客都经历过这种情况。事实上，编程语言相对力量的最准确衡量标准可能是了解该语言的人愿意接受任何使用该语言的工作的百分比，不管应用领域如何。&lt;/p&gt;
&lt;h2 id="限制性"&gt;限制性&lt;/h2&gt;
&lt;p&gt;我认为大多数黑客都知道语言感觉限制性是什么意思。当你有这种感觉时发生了什么？我认为这与当你想走的街道被封锁，你必须绕很长的路才能到达你想去的地方时的感觉相同。你有想说的话，但语言不允许你说。&lt;/p&gt;
&lt;p&gt;这里真正发生的事情，我认为，是限制性语言是一种不够简洁的语言。问题不仅仅是你不能说你计划说的话。而是语言让你绕的弯路更长。试试这个思维实验。假设你想写某个程序，语言不允许你按计划的方式表达它，而是强迫你用某种更短的方式写程序。至少对我来说，这不会感觉很有限制性。这就像你想走的街道被封锁，十字路口的警察给你指了一条捷径而不是绕路。太好了！&lt;/p&gt;
&lt;p&gt;我认为限制性的感觉大部分（百分之九十？）来自于被迫使你在语言中写的程序比你头脑中的更长。限制性主要是缺乏简洁性。所以当一种语言感觉有限制性时，这（大部分）意味着它不够简洁，而当一种语言不够简洁时，它会感觉有限制性。&lt;/p&gt;
&lt;h2 id="可读性"&gt;可读性&lt;/h2&gt;
&lt;p&gt;我开始引用的引言提到了另外两个品质，规范性和可读性。我不确定性规范性是什么，或者规范和可读的代码比仅仅可读的代码有什么优势，如果有的话。但我想我知道可读性是什么意思，我认为它也与简洁性有关。&lt;/p&gt;
&lt;p&gt;我们必须小心区分单行代码的可读性和整个程序的可读性。重要的是后者。我同意Basic的一行代码可能比Lisp的一行代码更易读。但用Basic编写的程序行数会比用Lisp编写的相同程序多（特别是当你进入格林斯彭之地时）。阅读Basic程序的总工作量肯定会更大。总工作量 = 每行工作量 × 行数&lt;/p&gt;
&lt;p&gt;我不像确信力量与简洁性成正比那样确信可读性与简洁性成正比，但简洁性肯定是可读性的一个因素（在数学意义上；见上面的公式）。所以，说语言的目标是可读性而不是简洁性可能甚至没有意义；这就像说目标是可读性，而不是可读性。&lt;/p&gt;
&lt;p&gt;每行可读性对第一次遇到语言的用户来说，意味着源代码看起来不具威胁性。所以每行可读性可能是一个好的营销决策，即使它是一个糟糕的设计决策。它与让人们分期付款的非常成功的技术同构：不是用高昂的前期价格吓唬他们，而是告诉他们低月付款。分期付款对买方来说是净亏损，而每行可读性对程序员来说可能也是如此。买方将进行很多很多低月付款；而程序员将阅读很多很多单独可读的行。&lt;/p&gt;
&lt;p&gt;这种权衡比编程语言更早。如果你习惯于阅读小说和报纸文章，你第一次阅读数学论文的经历可能会令人沮丧。阅读一页可能需要半小时。然而，我很确定符号不是问题，尽管感觉上可能是。数学论文难读是因为思想难。如果你用散文表达相同的思想（正如数学家在发展出简洁的符号之前必须做的那样），它们不会更容易读，因为论文会增长到一本书的大小。&lt;/p&gt;</description></item><item><title>编程语言修复了什么</title><link>https://linguista.cn/person/paul_graham/essays_zh/fix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/fix/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/fix/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/fix.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/fix.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/fix.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="编程语言修复了什么"&gt;编程语言修复了什么&lt;/h1&gt;
&lt;p&gt;凯文·凯勒her建议了一种比较编程语言的有趣方式：用每种语言所要解决的问题来描述它。令人惊讶的是，有多少语言可以用这种方式很好地描述。&lt;/p&gt;
&lt;p&gt;Algol：汇编语言太底层了。&lt;/p&gt;
&lt;p&gt;Pascal：Algol没有足够的数据类型。&lt;/p&gt;
&lt;p&gt;Modula：Pascal对于系统编程来说太弱了。&lt;/p&gt;
&lt;p&gt;Simula：Algol在模拟方面不够好。&lt;/p&gt;
&lt;p&gt;Smalltalk：Simula中的一切都不是对象。&lt;/p&gt;
&lt;p&gt;Fortran：汇编语言太底层了。&lt;/p&gt;
&lt;p&gt;Cobol：Fortran太吓人了。&lt;/p&gt;
&lt;p&gt;PL/1：Fortran没有足够的数据类型。&lt;/p&gt;
&lt;p&gt;Ada：每种现有语言都缺少某些东西。&lt;/p&gt;
&lt;p&gt;Basic：Fortran太吓人了。&lt;/p&gt;
&lt;p&gt;APL：Fortran在操作数组方面不够好。&lt;/p&gt;
&lt;p&gt;J：APL需要自己的字符集。&lt;/p&gt;
&lt;p&gt;C：汇编语言太底层了。&lt;/p&gt;
&lt;p&gt;C++：C太底层了。&lt;/p&gt;
&lt;p&gt;Java：C++是一个混乱的东西。而且微软要打压我们。&lt;/p&gt;
&lt;p&gt;C#：Java被Sun控制着。&lt;/p&gt;
&lt;p&gt;Lisp：图灵机是描述计算的笨拙方式。&lt;/p&gt;
&lt;p&gt;Scheme：MacLisp是一个混乱的东西。&lt;/p&gt;
&lt;p&gt;T：Scheme没有库。&lt;/p&gt;
&lt;p&gt;Common Lisp：Lisp有太多方言。&lt;/p&gt;
&lt;p&gt;Dylan：Scheme没有库，而且Lisp语法太吓人了。&lt;/p&gt;
&lt;p&gt;Perl：Shell脚本/awk/sed不够像编程语言。&lt;/p&gt;
&lt;p&gt;Python：Perl是一个混乱的东西。&lt;/p&gt;
&lt;p&gt;Ruby：Perl是一个混乱的东西，而且Lisp语法太吓人了。&lt;/p&gt;
&lt;p&gt;Prolog：编程不够像逻辑。&lt;/p&gt;</description></item><item><title>让另外95%的优秀程序员进来</title><link>https://linguista.cn/person/paul_graham/essays_zh/95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/95/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/95/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/95.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/95.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/95.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="让另外95的优秀程序员进来"&gt;让另外95%的优秀程序员进来&lt;/h1&gt;
&lt;p&gt;让另外95%的优秀程序员进来 2014年12月&lt;/p&gt;
&lt;p&gt;美国科技公司希望政府让移民更容易，因为它们说在美国找不到足够的程序员。反移民人士说，与其让外国人占据这些工作，我们应该培训更多的美国人成为程序员。谁是对的？&lt;/p&gt;
&lt;p&gt;科技公司是对的。反移民人士不理解的是，合格的程序员和杰出的程序员之间在能力上存在巨大差异，虽然你可以培训人们成为合格的程序员，但你无法培训他们成为杰出的程序员。杰出的程序员对编程有天生的才能和兴趣，这不仅仅是培训的产物。[1]&lt;/p&gt;
&lt;p&gt;美国占世界人口不到5%。这意味着如果使某人成为优秀程序员的特质是均匀分布的，那么95%的优秀程序员都出生在美国以外。&lt;/p&gt;
&lt;p&gt;反移民人士必须编造一些解释来说明科技公司为使移民更容易而付出的所有努力。所以他们声称这是因为它们想压低工资。但如果你与创业公司交谈，你会发现几乎所有达到一定规模的公司都经历了法律上的周折来让程序员进入美国，在那里他们支付给这些程序员的工资与支付给美国人的相同。为什么他们要为以相同价格获得程序员而额外费心？唯一的解释是他们在说实话：根本没有足够多的优秀程序员可供分配。[2]&lt;/p&gt;
&lt;p&gt;我问了一家拥有约70名程序员的创业公司的CEO，如果他能获得所有他想要的优秀程序员，他会再雇佣多少。他说&amp;quot;明天早上我们就会雇佣30名。&amp;ldquo;而这是一家总是在招聘战中获胜的热门创业公司。整个硅谷都是如此。创业公司在人才方面如此受限。&lt;/p&gt;
&lt;p&gt;如果更多的美国人接受编程培训那将是很好的，但没有任何培训能够改变95比5这样压倒性的比例。特别是由于其他国家也在培训程序员。除非发生灾难，否则大多数优秀程序员都出生在美国以外这一事实将永远成立。大多数在任何方面优秀的人都出生在美国以外这一事实也将永远成立。[3]&lt;/p&gt;
&lt;p&gt;卓越的表现意味着移民。一个只占世界人口百分之几的国家只有在某个领域有大量移民工作的情况下才能在该领域表现出色。&lt;/p&gt;
&lt;p&gt;但整个讨论都理所当然地认为：如果我们让更多的优秀程序员进入美国，他们会想要来。现在这是真的，我们没有意识到我们有多么幸运。如果我们想保持这个选择开放，最好的方法是利用它：世界上越多的优秀程序员在这里，其余的就会越想要来这里。&lt;/p&gt;
&lt;p&gt;如果我们不这样做，美国可能会彻底完蛋。我意识到这是强烈的措辞，但对此犹豫不决的人似乎没有意识到这里发挥作用的力量有多大。技术给最好的程序员带来了巨大的杠杆作用。程序员的世界市场似乎正在变得更加流动性。而且由于优秀的人喜欢优秀的同事，这意味着最好的程序员可能会聚集在少数几个中心。可能主要在一个中心。&lt;/p&gt;
&lt;p&gt;如果大多数优秀程序员聚集在一个中心，而那个中心不在这里怎么办？这个场景现在可能看起来不太可能，但如果未来50年的变化与过去50年一样大，它就不会不太可能了。&lt;/p&gt;
&lt;p&gt;我们有可能仅仅通过每年让几千名优秀程序员进入美国就确保美国保持技术超级大国的地位。让这个机会溜走将是一个多么巨大的错误。这很容易成为这一代美国政客后来出名的决定性错误。与该规模的其他潜在错误不同，修复它的成本为零。&lt;/p&gt;
&lt;p&gt;所以，请继续吧。&lt;/p&gt;
&lt;h2 id="注释"&gt;注释&lt;/h2&gt;
&lt;p&gt;[1] 优秀程序员比普通程序员好多少？好到你甚至无法直接衡量差异。优秀程序员不仅仅是更快地完成相同的工作。优秀程序员会发明普通程序员甚至想不到的东西。这并不意味着优秀程序员的价值无限大，因为任何发明都有有限的市场价值。但很容易想象在某些情况下，优秀程序员可能会发明价值达到普通程序员工资100倍甚至1000倍的东西。&lt;/p&gt;
&lt;p&gt;[2] 有少数咨询公司出租大量通过H1-B签证带入的外国程序员。一定要打击这些。应该很容易写立法来区分它们，因为它们与技术公司如此不同。但反移民人士声称像谷歌和脸书这样的公司是由相同的动机驱动是不诚实的。廉价但平庸的程序员涌入是他们最不想要的事情；那会毁掉他们。&lt;/p&gt;
&lt;p&gt;[3] 虽然这篇文章谈论的是程序员，但我们需要引进的群体更广泛，从设计师到程序员再到电气工程师。作为通用术语，最好的可能是&amp;quot;数字人才&amp;rdquo;。似乎让论证过于狭窄比用新词混淆每个人要好。&lt;/p&gt;
&lt;p&gt;感谢萨姆·奥特曼、约翰·科利森、帕特里克·科利森、杰西卡·利文斯顿、杰夫·拉尔斯顿、弗雷德·威尔逊和卡萨尔·尤尼斯阅读本文的草稿。&lt;/p&gt;
&lt;p&gt;西班牙语翻译&lt;/p&gt;
&lt;hr&gt;</description></item><item><title>超越平均水平</title><link>https://linguista.cn/person/paul_graham/essays_zh/avg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/avg/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/avg/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/avg.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/avg.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/avg.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="超越平均水平"&gt;超越平均水平&lt;/h1&gt;
&lt;p&gt;2001年4月&lt;/p&gt;
&lt;p&gt;如果你想知道什么是编程的&amp;quot;秘密&amp;quot;，那么就是编程语言之间存在很大的差异。这不仅仅是理论问题。实际上，这会对创业公司产生很大影响。&lt;/p&gt;
&lt;p&gt;创业公司成功的可能性有多大？如果你考虑所有的创业公司，大多数都会失败。但如果你只考虑那些成功的创业公司，它们都有一个共同点：它们使用某种秘密武器。它们做了一些大公司无法做的事情。&lt;/p&gt;
&lt;h2 id="语言的差异"&gt;语言的差异&lt;/h2&gt;
&lt;p&gt;编程语言之间存在巨大差异。有些语言比其他语言强大得多。如果你使用一种强大的语言，你可以比使用较弱语言的程序员更快地完成工作。&lt;/p&gt;
&lt;p&gt;大多数程序员对编程语言之间的差异了解甚少。他们知道一些语言比其他语言更&amp;quot;高级&amp;quot;，但他们不理解这些差异有多大。他们不理解使用强大语言可以给你带来多大的优势。&lt;/p&gt;
&lt;p&gt;使用强大语言不仅仅是写代码更快的问题。它是关于你能做什么的问题。在较弱的语言中，有些事情根本做不了，或者做起来非常困难。在强大的语言中，这些事情很容易。&lt;/p&gt;
&lt;h2 id="lisp的优势"&gt;Lisp的优势&lt;/h2&gt;
&lt;p&gt;Lisp是最强大的编程语言之一。它比大多数其他语言强大得多。使用Lisp的程序员比使用其他语言的程序员有巨大的优势。&lt;/p&gt;
&lt;p&gt;Lisp的优势不是微小的。它是巨大的。使用Lisp的团队可以比使用其他语言的团队小得多，但仍然完成更多的工作。&lt;/p&gt;
&lt;p&gt;Viaweb就是一个例子。Viaweb是第一个基于Web的应用程序。它让用户可以在线构建商店。我们三个人使用Lisp构建了Viaweb。我们的竞争对手使用其他语言，如C++和Perl。他们需要更多的人来完成同样的工作。&lt;/p&gt;
&lt;h2 id="为什么更多的人不使用lisp"&gt;为什么更多的人不使用Lisp？&lt;/h2&gt;
&lt;p&gt;如果Lisp如此强大，为什么更多的人不使用它？&lt;/p&gt;
&lt;p&gt;一个原因是Lisp与其他语言非常不同。大多数程序员习惯使用类似C的语言。Lisp看起来很奇怪。&lt;/p&gt;
&lt;p&gt;另一个原因是Lisp并不适合所有事情。它不是最好的系统编程语言。如果你正在编写设备驱动程序，C可能更好。&lt;/p&gt;
&lt;p&gt;但Lisp非常适合编写Web应用程序。这就是我们选择它用于Viaweb的原因。&lt;/p&gt;
&lt;h2 id="创业公司的优势"&gt;创业公司的优势&lt;/h2&gt;
&lt;p&gt;创业公司可以利用大公司无法使用的强大语言。大公司有太多惯性。它们使用特定的语言，因为它们总是使用这些语言。它们不能轻易改变。&lt;/p&gt;
&lt;p&gt;创业公司可以灵活得多。它们可以选择最适合工作的工具。&lt;/p&gt;
&lt;p&gt;这不仅仅是技术问题。这关乎竞争。如果你使用比竞争对手更强大的语言，你可以更快地移动。你可以做他们做不到的事情。&lt;/p&gt;
&lt;h2 id="实际例子"&gt;实际例子&lt;/h2&gt;
&lt;p&gt;在Viaweb，我们能够快速添加新功能。我们的竞争对手需要几周才能完成的事情，我们可以在几天内完成。&lt;/p&gt;
&lt;p&gt;我们能够添加我们的竞争对手无法添加的功能。Lisp让我们能够做到这一点。&lt;/p&gt;
&lt;p&gt;例如，我们能够添加一个让用户编辑HTML的功能。我们的竞争对手无法做到这一点，因为他们的语言不够强大。&lt;/p&gt;
&lt;h2 id="学习曲线"&gt;学习曲线&lt;/h2&gt;
&lt;p&gt;Lisp有一个陡峭的学习曲线。大多数程序员需要一段时间才能习惯它。&lt;/p&gt;
&lt;p&gt;但这是值得的。一旦你学会了Lisp，你就会比其他程序员更有生产力。&lt;/p&gt;
&lt;h2 id="结论"&gt;结论&lt;/h2&gt;
&lt;p&gt;编程语言之间存在巨大差异。这些差异对创业公司来说很重要。&lt;/p&gt;
&lt;p&gt;如果你正在创办一家创业公司，你应该考虑使用像Lisp这样的强大语言。它可以给你带来竞争优势。&lt;/p&gt;
&lt;p&gt;不要担心别人会怎么说。做你认为正确的事情。&lt;/p&gt;
&lt;p&gt;记住，创业公司的目标是成功。如果使用强大的语言帮助你成功，那就去做吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;这篇文章基于Paul Graham在2001年4月发表的原创作品，讨论了编程语言之间的差异以及它们对创业公司的重要性。&lt;/em&gt;&lt;/p&gt;</description></item><item><title>黑客与画家</title><link>https://linguista.cn/person/paul_graham/essays_zh/hp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/hp/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/hp/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/hp.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/hp.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/hp.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="黑客与画家"&gt;黑客与画家&lt;/h1&gt;
&lt;p&gt;2003年5月&lt;/p&gt;
&lt;p&gt;（本文源于在哈佛大学的一次客座讲座，该讲座整合了之前在东北大学的一次演讲。）&lt;/p&gt;
&lt;p&gt;当我完成计算机科学研究生学业后，我去艺术学院学习绘画。很多人似乎对感兴趣于计算机的人也会对绘画感兴趣感到惊讶。他们似乎认为黑客和绘画是截然不同的工作类型——黑客工作是冷酷、精确、有条理的，而绘画则是某种原始冲动的狂热表达。&lt;/p&gt;
&lt;p&gt;这两种形象都是错误的。黑客和绘画有很多共同之处。事实上，在我认识的所有不同类型的人中，黑客和画家是最相似的。&lt;/p&gt;
&lt;p&gt;黑客和画家的共同点是他们都是创造者。与作曲家、建筑师和作家一样，黑客和画家试图做的是创造好东西。他们本身并不是在做研究，尽管在试图创造好东西的过程中他们发现了一些新技术，那就更好了。&lt;/p&gt;
&lt;p&gt;我从来不喜欢&amp;quot;计算机科学&amp;quot;这个词。我不喜欢它的主要原因是没有这样的东西。计算机科学是一堆关系不大的领域的拼凑，因历史的偶然而被组合在一起，就像南斯拉夫一样。一端是实际上是数学家的人，但他们称自己做的事情为计算机科学，以便获得DARPA资助。中间是从事类似计算机自然史工作的人——例如研究通过网络路由数据的算法行为。然后在另一端是黑客，他们试图编写有趣的软件，对他们来说，计算机只是表达媒介，就像对建筑师来说是混凝土，对画家来说是颜料一样。这就像是数学家、物理学家和建筑师都必须在同一个系里一样。&lt;/p&gt;
&lt;p&gt;有时黑客所做的事情被称为&amp;quot;软件工程&amp;quot;，但这个术语同样具有误导性。优秀的软件设计师并不比建筑师更像工程师。建筑和工程之间的界限并没有明确界定，但它是存在的。它在于做什么和如何做之间：建筑师决定做什么，工程师弄清楚如何做。&lt;/p&gt;
&lt;p&gt;做什么和如何做不应过于分离。如果你试图在不知道如何做的情况下决定做什么，那是在自找麻烦。但黑客工作绝不仅仅是决定如何实现某个规范。在最好的情况下，它是创建规范——但事实证明做到这一点的最好方法是实现它。&lt;/p&gt;
&lt;p&gt;也许有一天&amp;quot;计算机科学&amp;quot;会像南斯拉夫一样被分解成其组成部分。这可能是件好事。特别是如果这意味着我自己的领域——黑客的独立。&lt;/p&gt;
&lt;p&gt;将所有这些不同类型的工作捆绑在一个部门可能在行政上很方便，但在智力上是混乱的。这是我不喜欢&amp;quot;计算机科学&amp;quot;这个名字的另一个原因。可以说，中间的人在做类似实验科学的事情。但两端的人，黑客和数学家，实际上并不是在做科学。&lt;/p&gt;
&lt;p&gt;数学家似乎并不为此困扰。他们很高兴地开始证明定理，就像数学系的数学家一样，并且很快就会停止注意到他们工作的建筑外面写着&amp;quot;计算机科学&amp;quot;。但对黑客来说，这个标签是个问题。如果他们所做的事情被称为科学，这让他们觉得他们应该表现得科学。因此，大学和研究实验室里的黑客不做他们真正想做的事情，即设计美丽的软件，而是觉得他们应该写研究论文。&lt;/p&gt;
&lt;p&gt;在最好的情况下，论文只是一种形式。黑客编写很酷的软件，然后写一篇关于它的论文，论文就成为了软件所代表成就的代理。但这种不匹配经常导致问题。很容易从创造美丽的东西转向创造丑陋的东西，而这些东西更适合作为研究论文的题材。&lt;/p&gt;
&lt;p&gt;不幸的是，美丽的东西并不总是最好的论文主题。首先，研究必须是原创的——正如任何写过博士论文的人所知，确保你在探索未知领域的方法是占据一块没有人想要的地盘。其次，研究必须是实质性的——笨拙的系统会产生更丰富的论文，因为你可以写为了完成工作而必须克服的障碍。没有什么比从错误假设开始更能产生丰富的问题了。大多数人工智能都是这个规则的例子；如果你假设知识可以表示为谓词逻辑表达式的列表，其参数代表抽象概念，你将有很多论文要写关于如何使其工作。正如里奇·里卡多常说的：&amp;ldquo;露西，你有很多解释要做。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;创造美丽东西的方法往往是对现有事物进行微妙的调整，或者以稍新的方式组合现有的想法。这种工作很难在研究论文中传达。&lt;/p&gt;
&lt;p&gt;那么为什么大学和研究实验室继续用出版物来判断黑客呢？原因与&amp;quot;学术能力&amp;quot;用简单的标准化测试衡量，或者程序员的生产力用代码行数衡量是一样的。这些测试很容易应用，没有什么比一个勉强有效的简单测试更诱人的了。&lt;/p&gt;
&lt;p&gt;衡量黑客真正试图做的事情，设计美丽的软件，会困难得多。你需要良好的设计感来判断好的设计。人们识别好设计的能力与他们对自己能做到的信心之间没有任何相关性，除了可能是负相关。&lt;/p&gt;
&lt;p&gt;唯一的外部测试是时间。随着时间的推移，美丽的东西往往会繁荣，丑陋的东西往往会被抛弃。不幸的是，所涉及的时间可能比人类寿命还长。塞缪尔·约翰逊说，作家的声誉需要一百年才能收敛。你必须等待作家有影响力的朋友死去，然后他们所有的追随者都死去。&lt;/p&gt;
&lt;p&gt;我认为黑客只能接受自己声誉中有很大的随机成分。在这方面，他们与其他创造者没有什么不同。事实上，相比之下，他们是幸运的。时尚在黑客中的影响力远不如在绘画中那么大。&lt;/p&gt;
&lt;p&gt;有比被人误解你的作品更糟糕的事情。更危险的是你会自己误解你的作品。相关领域是你寻找想法的地方。如果你发现自己身处计算机科学系，自然会有一种诱惑，例如认为黑客是理论计算机科学理论的应用版本。我在研究生院的整个时间里，脑海中总有一种不安的感觉，觉得我应该知道更多理论，而且在期末考试后三周内忘记所有东西是非常疏忽的。&lt;/p&gt;
&lt;p&gt;现在我意识到我错了。黑客需要了解计算理论的程度，与画家需要了解颜料化学的程度差不多。你需要知道如何计算时间和空间复杂性以及图灵完备性。你可能还想记住至少状态机的概念，以防你不得不编写解析器或正则表达式库。事实上，画家必须记住的颜料化学知识比这多得多。&lt;/p&gt;
&lt;p&gt;我发现，最好的想法来源不是名字中有&amp;quot;计算机&amp;quot;一词的其他领域，而是创造者居住的其他领域。绘画比计算理论是更丰富的想法来源。&lt;/p&gt;
&lt;p&gt;例如，我在大学里学到的是，一个人应该在完全接触计算机之前在纸上完整地构思一个程序。我发现我不是这样编程的。我发现我喜欢坐在计算机前编程，而不是在纸上。更糟糕的是，我不是耐心地写出完整的程序并确保它是正确的，而是倾向于只是喷出完全没有希望的代码，然后逐渐把它塑造成形。我学到的是，调试是一种最后阶段，你捕捉打字错误和疏忽。按照我的工作方式，编程似乎就是由调试组成的。&lt;/p&gt;
&lt;p&gt;很长时间以来，我对此感觉很糟糕，就像我曾经因为小学时握铅笔的方式和他们教我的不一样而感到难过一样。如果我看过其他创造者，画家或建筑师，我会意识到我所做的事情有一个名字：素描。据我所知，他们在大学教我的编程方法完全是错的。你应该在编写程序时构思程序，就像作家、画家和建筑师所做的那样。&lt;/p&gt;
&lt;p&gt;意识到这一点对软件设计有实际意义。这意味着编程语言最重要的特性应该是可塑的。编程语言是用来思考程序的，而不是表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果人们真的像他们在大学教我的那样写程序，静态类型会是个好主意。但这不是我认识的任何黑客写程序的方式。我们需要一种让我们能够涂鸦、涂抹和弄脏的语言，而不是一种你必须用一杯类型平衡在膝盖上与严格的老婶婶编译器礼貌交谈的语言。&lt;/p&gt;
&lt;p&gt;既然我们在讨论静态类型，认同创造者将使我们免于困扰科学的另一个问题：数学嫉妒。科学界的每个人都秘密认为数学家比他们聪明。我认为数学家也相信这一点。无论如何，结果是科学家倾向于使他们的工作看起来尽可能数学化。在像物理学这样的领域，这可能不会造成太大伤害，但离自然科学越远，这个问题就越大。&lt;/p&gt;
&lt;p&gt;一页公式看起来非常令人印象深刻。（提示：为了更加令人印象深刻，使用希腊变量。）因此，有很大的诱惑去做你可以正式处理的问题，而不是那些重要的，比如说，重要的问题。&lt;/p&gt;
&lt;p&gt;如果黑客认同其他创造者，比如作家和画家，他们就不会感到诱惑去做这种事情。作家和画家不遭受数学嫉妒。他们觉得他们在做完全不相关的事情。我认为黑客也是如此。&lt;/p&gt;
&lt;p&gt;如果大学和研究实验室阻止黑客做他们想做的工作，也许他们的位置是在公司。不幸的是，大多数公司也不会让黑客做他们想做的事情。大学和研究实验室强迫黑客成为科学家，公司强迫他们成为工程师。&lt;/p&gt;
&lt;p&gt;我自己直到最近才发现这一点。当雅虎收购Viaweb时，他们问我想做什么。我从来不太喜欢商业方面，说我只想黑客。当我到雅虎时，我发现黑客对他们来说意味着实现软件，而不是设计它。程序员被视为技术人员，将产品经理的愿景（如果那算是的话）翻译成代码。&lt;/p&gt;
&lt;p&gt;这似乎是大公司的默认计划。他们这样做是因为它减少了结果的标准差。只有一小部分黑客能够真正设计软件，公司经营者很难挑选出这些人。因此，大多数公司不将软件的未来委托给一个才华横溢的黑客，而是设置成由委员会设计，黑客只实现设计。&lt;/p&gt;
&lt;p&gt;如果你想赚钱，记住这一点，因为这是创业公司获胜的原因之一。大公司希望减少设计结果的标准差，因为他们想避免灾难。但当你抑制波动时，你既失去了高点，也失去了低点。这对大公司来说不是问题，因为他们不是靠做出伟大的产品获胜的。大公司靠比其他大公司少些糟糕获胜。&lt;/p&gt;
&lt;p&gt;所以如果你能找到一种方法与一家大公司进行设计战争，大到其软件是由产品经理设计的，他们将永远无法跟上你。不过，这些机会并不容易找到。很难让大公司参与设计战争，就像很难让城堡内的对手进行肉搏战一样。例如，编写一个比微软Word更好的文字处理器会很容易，但微软在其操作系统垄断的城堡内，即使你做到了，可能甚至不会注意到。&lt;/p&gt;
&lt;p&gt;进行设计战争的地方是新市场，在那里还没有人设法建立任何防御工事。在那里，你可以通过大胆的设计方法，以及让同样的人既设计又实现产品而大获全胜。微软自己一开始就是这样做的。苹果也是如此。惠普也是如此。我怀疑几乎所有成功的创业公司都是如此。&lt;/p&gt;
&lt;p&gt;所以构建伟大软件的一种方法是创办自己的创业公司。然而，这有两个问题。一是在创业公司，你必须做很多编程以外的事情。在Viaweb，如果我能有四分之一的时间黑客，我就觉得自己很幸运。我在其他四分之三的时间里不得不做的事情从乏味到可怕不等。我对此有一个基准，因为我曾经不得不离开董事会会议去补牙。我记得坐在牙医的椅子上，等待钻头，感觉就像在度假。&lt;/p&gt;
&lt;p&gt;创业公司的另一个问题是，赚钱的软件和有趣的软件之间没有太多重叠。编程语言写起来很有趣，微软的第一个产品确实是，但现在没有人会为编程语言付钱。如果你想赚钱，你往往被迫从事对任何人来说都太麻烦而无法免费解决的问题。&lt;/p&gt;
&lt;p&gt;所有创造者都面临这个问题。价格由供求关系决定，对有趣工作的需求不如解决个人客户日常问题的需求多。在外百老汇戏剧中表演不如在贸易展上穿着大猩猩服装在别人的展位工作赚钱。写小说不如为垃圾处理器写广告文案赚钱。黑客编程语言不如想办法将某公司的遗留数据库连接到他们的Web服务器赚钱。&lt;/p&gt;
&lt;p&gt;我认为这个问题的答案，在软件的情况下，是一个几乎所有创造者都知道的概念：日常工作。这个词始于音乐家，他们晚上表演。更一般地说，这意味着你做一种工作是为了钱，做另一种是为了爱。&lt;/p&gt;
&lt;p&gt;几乎所有创造者在职业生涯早期都有日常工作。画家和作家尤其如此。如果你幸运，你可以找到与你真正工作密切相关的日常工作。音乐家似乎经常在唱片店工作。从事某种编程语言或操作系统工作的黑客同样可能能够使用它获得日常工作。[1]&lt;/p&gt;
&lt;p&gt;当我说答案是为黑客提供日常工作，并在业余时间从事美丽软件工作时，我并不是在提出一个新想法。这就是开源黑客的全部内容。我要说的是，开源可能是正确的模式，因为它已经被所有其他创造者独立证实。&lt;/p&gt;
&lt;p&gt;任何雇主都不愿让黑客从事开源项目，这让我感到惊讶。在Viaweb，我们不愿意雇佣任何不这样做的人。当我们面试程序员时，我们主要关心的是他们在业余时间编写什么样的软件。除非你热爱它，否则你不能真正做好任何事情，如果你热爱黑客，你将不可避免地从事自己的项目。[2]&lt;/p&gt;
&lt;p&gt;因为黑客是创造者而不是科学家，寻找隐喻的正确地方不是科学，而是其他类型的创造者。绘画还能教给我们什么关于黑客的知识？&lt;/p&gt;
&lt;p&gt;我们可以从绘画的例子中学到的一件事，或者至少确认的是，如何学习黑客。你主要通过做来学习绘画。黑客也是如此。大多数黑客不是通过上大学编程课程来学习黑客的。他们在十三岁时通过编写自己的程序来学习黑客。即使在大学课程中，你也主要通过黑客来学习黑客。[3]&lt;/p&gt;
&lt;p&gt;因为画家在他们身后留下了作品的痕迹，你可以看着他们通过做来学习。如果你按时间顺序看一位画家的作品，你会发现每幅画都建立在以前画中学到的东西的基础上。当一幅画中有某个东西效果很好时，你通常可以在一些早期绘画中以较小的形式找到它的版本1。&lt;/p&gt;
&lt;p&gt;我认为大多数创造者都是这样工作的。作家和建筑师似乎也是如此。也许黑客应该更像画家，定期从头开始，而不是继续在一个项目上工作多年，并试图将他们以后的想法作为修订纳入其中。&lt;/p&gt;
&lt;p&gt;黑客通过做来学习黑客这一事实是黑客与科学不同的另一个标志。科学家不是通过做科学来学习科学，而是通过做实验和解决问题集。科学家开始做的工作是完美的，在这个意义上说，他们只是试图重现别人已经为他们做过的工作。最终，他们达到可以做原创工作的地步。而黑客从一开始就在做原创工作；只是非常糟糕。所以黑客从原创开始，然后变好，科学家从好开始，然后变原创。&lt;/p&gt;</description></item><item><title>黑客这个词</title><link>https://linguista.cn/person/paul_graham/essays_zh/gba/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linguista.cn/person/paul_graham/essays_zh/gba/</guid><description>&lt;p&gt;→ &lt;a href="https://linguista.cn/person/paul_graham/essays_en/gba/"&gt;English Version&lt;/a&gt;&lt;/p&gt;
&lt;div
 class="link-card group relative my-3 w-full overflow-hidden rounded-xl border border-border bg-surface transition-shadow duration-300 hover:shadow-md"
 data-url="https://www.paulgraham.com/gba.html"
&gt;
 &lt;a
 class="link-card__fallback block px-4 py-3 text-sm font-medium text-accent underline-offset-4 hover:underline"
 href="https://www.paulgraham.com/gba.html"
 target="_blank"
 rel="noopener"
 &gt;
 https://www.paulgraham.com/gba.html
 &lt;/a&gt;
&lt;/div&gt;

&lt;h1 id="黑客这个词"&gt;黑客这个词&lt;/h1&gt;
&lt;p&gt;2004年4月&lt;/p&gt;
&lt;p&gt;对大众媒体来说，&amp;ldquo;黑客&amp;quot;意味着闯入计算机的人。在程序员中，它意味着一个好的程序员。但这两种含义是相连的。对程序员来说，&amp;ldquo;黑客&amp;quot;在最字面的意义上意味着精通：能够让计算机做他想要的事情的人——不管计算机是否愿意。&lt;/p&gt;
&lt;p&gt;更令人困惑的是，名词&amp;quot;hack&amp;quot;也有两种含义。它可以是赞美，也可以是侮辱。当你用丑陋的方式做某事时，这被称为hack。但当你做某事如此聪明以至于你以某种方式击败了系统时，那也被称为hack。这个词在前一种含义中比后一种更常用，可能是因为丑陋的解决方案比 brilliant 的更常见。&lt;/p&gt;
&lt;p&gt;信不信由你，&amp;ldquo;hack&amp;quot;的两种含义也是相连的。丑陋和富有想象力的解决方案有共同之处：它们都打破了规则。在仅仅丑陋的违规（用胶带把东西 attach 到你的自行车上）和 brilliantly 富有想象力的违规（丢弃欧几里得空间）之间存在一个逐渐的连续谱。&lt;/p&gt;
&lt;p&gt;黑客文化比计算机更早。当理查德·费曼在曼哈顿计划工作时，他常常通过闯入包含秘密文件的保险箱来娱乐自己。这个传统今天仍在继续。当我们读研究生时，我的一位在MIT周围花了太多时间的黑客朋友有自己的开锁工具包。（他现在经营对冲基金，这不是一个无关的企业。）&lt;/p&gt;
&lt;p&gt;有时候很难向当局解释为什么有人会想做这种事情。我的另一个朋友曾经因为闯入计算机而与政府惹上麻烦。这最近才被宣布为犯罪，FBI发现他们通常的调查技术不起作用。警察调查显然是从动机开始的。通常的动机很少：毒品、金钱、性、复仇。智力好奇心不在FBI的动机清单上。确实，整个概念对他们来说似乎很陌生。&lt;/p&gt;
&lt;p&gt;当权者往往对黑客普遍的不服从态度感到恼火。但这种不服从是使他们成为优秀程序员的品质的副产品。当CEO用通用的企业新闻发言时，他们可能会嘲笑他，但他们也会嘲笑告诉他们某个问题无法解决的人。压制一个，你就压制了另一个。&lt;/p&gt;
&lt;p&gt;这种态度有时是装出来的。有时年轻的程序员注意到著名黑客的怪癖，并决定采用一些自己的怪癖，以便看起来更聪明。虚假版本不仅令人讨厌；这些伪装者的 prickly 态度实际上会减慢创新过程。&lt;/p&gt;
&lt;p&gt;但即使考虑到他们令人讨厌的怪癖，黑客的不服从态度也是一个净胜利。我希望它的优势能被更好地理解。&lt;/p&gt;
&lt;p&gt;例如，我怀疑好莱坞的人们对黑客对版权的态度感到困惑。它们是Slashdot上激烈讨论的 perennial 话题。但是，为什么编程的人们应该如此关心版权，在所有事情中？&lt;/p&gt;
&lt;p&gt;部分原因是有些公司使用机制来防止复制。向任何黑客展示一把锁，他的第一个念头是如何打开它。但黑客对版权和专利等措施感到警惕有更深层次的原因。他们将 increasingly 激进的措施保护&amp;quot;知识产权&amp;quot;视为对他们工作所需的 intellectual freedom 的威胁。他们是对的。&lt;/p&gt;
&lt;p&gt;正是通过在当前技术内部探查，黑客才获得了下一代的想法。不，谢谢，知识产权所有者可能会说，我们不需要任何外部帮助。但他们错了。下一代计算机技术经常——或许比不是更经常——是由外人开发的。&lt;/p&gt;
&lt;p&gt;1977年，毫无疑问IBM内部有一些团体正在开发他们期望成为下一代商业计算机的东西。他们错了。下一代商业计算机正在由两个名叫史蒂夫的长发男人在洛斯阿尔托斯的车库里以完全不同的线路开发。大约在同一时间，当权者正在合作开发官方的下一代操作系统Multics。但两个认为Multics过于复杂的家伙离开去写自己的系统。他们给它起了一个对Multics开玩笑的名字：Unix。&lt;/p&gt;
&lt;p&gt;最新的知识产权法律对导致新想法的那种探查施加了前所未有的限制。在过去，竞争对手可能使用专利来阻止你销售他们制造的东西的副本，但他们不能阻止你拆开一个来看它是如何工作的。最新的法律使这成为犯罪。如果我们不能研究当前技术来弄清楚如何改进它，我们如何开发新技术？&lt;/p&gt;
&lt;p&gt;具有讽刺意味的是，黑客自己招致了这一点。计算机是造成问题的原因。机器内的控制系统过去是物理的：齿轮、杠杆和凸轮。 increasingly，产品的大脑（从而价值）在软件中。我指的是一般意义上的软件：即数据。LP上的歌曲是物理压印在塑料中的。iPod磁盘上的歌曲只是存储在上面。&lt;/p&gt;
&lt;p&gt;数据根据定义很容易复制。互联网使副本容易分发。所以公司害怕不足为奇。但是，像经常发生的那样，恐惧模糊了他们的判断。政府用严酷的法律来保护知识产权。他们可能是好意的。但他们可能没有意识到这样的法律弊大于利。&lt;/p&gt;
&lt;p&gt;为什么程序员如此强烈地反对这些法律？如果我是一个立法者，我会对这个谜团感兴趣——出于同样的原因，如果我是一个农民，突然一天晚上听到很多咯咯声来自我的鸡舍，我会想要出去调查。黑客不笨，而这个世界上 unanimity 很罕见。所以如果他们都在咯咯叫，也许有什么不对劲。&lt;/p&gt;
&lt;p&gt;难道这样的法律，虽然意图保护美国，但实际上会伤害它吗？想想看。费曼在曼哈顿计划期间闯入保险箱有一些非常美国化的东西。很难想象当时的德国当局对这类事情有幽默感。也许这不是巧合。&lt;/p&gt;
&lt;p&gt;黑客是不守规矩的。这就是黑客的本质。这也是美国精神的本质。硅谷在美国，而不是法国、德国、英国或日本，这绝非偶然。在那些国家，人们在 lines 内着色。&lt;/p&gt;
&lt;p&gt;我在佛罗伦萨住了一段时间。但在那里呆了几个月后，我意识到我无意识希望在那里找到的东西 back 在我刚刚离开的地方。佛罗伦萨著名的原因是，在1450年，它是纽约。在1450年，它充满了你现在在美国发现的那种动荡和雄心勃勃的人。（所以我回到了美国。）&lt;/p&gt;
&lt;p&gt;美国的一个巨大优势是它为正确的那种不守规矩提供了宜人的氛围——它不仅是聪明人的家园，也是 smart-alecks 的家园。黑客 invariably 是 smart-alecks。如果我们有一个国定假日，那将是4月1日。我们对 brilliant 或可怕 cheesy 的解决方案使用同一个词，这充分说明了我们的工作。当我们炮制出一个时，我们不总是100%确定它是哪种。但只要它有正确的错误类型，那就是一个有希望的迹象。人们认为编程是精确和有条理的，这很奇怪。计算机是精确和有条理的。黑客是你在开怀大笑时做的事情。&lt;/p&gt;</description></item></channel></rss>