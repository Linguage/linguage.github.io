<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on Linguista</title>
    <link>https://linguage.github.io/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on Linguista</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 28 Sep 2025 21:29:00 +0800</lastBuildDate>
    <atom:link href="https://linguage.github.io/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>代码“劫后余生”:记一场Git灾难与抢救</title>
      <link>https://linguage.github.io/post/git-incident-2025-09-28/</link>
      <pubDate>Sun, 28 Sep 2025 21:29:00 +0800</pubDate>
      <guid>https://linguage.github.io/post/git-incident-2025-09-28/</guid>
      <description>&lt;p&gt;经过一天的工作，我昨天配置的博客评论区离奇消失，查找记录时发现更惊悚的事：我近几天的Git提交记录全部失踪，并因一个误操作导致代码回滚到三天前的基础版本，所有后期工作成果瞬间清零。我向 GPT-5-Codex 求救，它立即启动高级Git命令进行抢救。最终，在GPT的指导下，我执行了几行恢复命令，代码起死回生，成功回到了误操作前的状态。这次劫后余生的经历，让我深切体会到Git的强大与学习它的必要性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>&#34;艺术家要发布&#34;的另一面</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/artistsship/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/artistsship/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/artistsship/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/artistsship.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/artistsship.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/artistsship.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;艺术家要发布的另一面&#34;&gt;&amp;ldquo;艺术家要发布&amp;quot;的另一面&lt;/h1&gt;&#xA;&lt;p&gt;2008年11月&lt;/p&gt;&#xA;&lt;p&gt;大公司与创业公司之间的区别之一是，大公司往往已经制定了防止犯错的程序。创业公司走路就像幼儿，不断撞到东西，跌倒。大公司则更加谨慎。&lt;/p&gt;&#xA;&lt;p&gt;组织中审核的逐渐积累是一种学习，基于发生在自己或类似组织身上的灾难。例如，在与一个破产并无法交付的供应商签订合同后，公司可能会要求所有供应商在投标前证明自己有偿付能力。&lt;/p&gt;&#xA;&lt;p&gt;随着公司的发展，他们不可避免地会有更多这样的审核，要么是为了应对他们遭受的灾难，要么（可能更常见的是）通过从更大的公司雇佣带来新灾难防范习惯的人。&lt;/p&gt;&#xA;&lt;p&gt;组织从错误中学习是自然的。问题是，提出新审核的人几乎从不考虑审核本身有成本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;每个审核都有成本&#34;&gt;每个审核都有成本。&lt;/h2&gt;&#xA;&lt;p&gt;例如，考虑让供应商验证其偿付能力的情况。这难道不是仅仅谨慎吗？但实际上它可能有巨大成本。显然，双方提供和检查供应商偿付能力证明的人有直接的时间成本。但真正的成本是你从未听说过的：本会是最佳供应商的公司，但因为无法腾出精力进行验证而没有投标。或者本会是最佳供应商的公司，但偿付能力却刚好低于门槛——当然这个门槛会被定得偏高，因为没有明显的提高成本。&lt;/p&gt;&#xA;&lt;p&gt;每当组织中有人提议添加新审核时，他们应该不仅解释收益，还要解释成本。无论他们分析得多么糟糕，这个元审核至少会提醒每个人必须存在成本，并让他们去寻找它。&lt;/p&gt;&#xA;&lt;p&gt;如果公司开始这样做，他们会发现一些意外。Joel Spolsky最近在Y Combinator谈到向企业客户销售软件。他说，在大多数公司中，成本高达约1000美元的软件可以由个人经理无需任何额外批准购买。超过这个门槛，软件购买通常必须由委员会批准。但是为软件供应商处理这个过程如此昂贵，以至于收费少于50000美元没有意义。这意味着如果你制造了一个本来可能收费5000美元的东西，你必须以50000美元的价格出售。&lt;/p&gt;&#xA;&lt;p&gt;委员会的目的是确保公司不浪费钱。然而结果是公司支付了10倍的价格。&lt;/p&gt;&#xA;&lt;p&gt;购买审核总是昂贵的，因为向你销售东西越困难，它就必须成本越高。而且不是线性的。如果你足够难以销售，最擅长制造东西的人根本不想费心。唯一会向你销售的是专门向你销售的公司。那么你已经陷入了全新的低效率水平。市场机制不再保护你，因为好的供应商已经不在市场上了。&lt;/p&gt;&#xA;&lt;p&gt;这样的事情不断发生在所有最大的组织中，政府。但政府实施的审核可能导致的问题不仅仅是多付钱。政府实施的审核可能破坏整个国家的经济。直到大约1400年，中国比欧洲更富有，技术更先进。欧洲超越的一个原因是中国政府限制了长途贸易航行。因此欧洲人开始探索并最终主导世界其他地区，包括中国。&lt;/p&gt;&#xA;&lt;p&gt;在更近的时代，《萨班斯-奥克斯利法案》实际上摧毁了美国IPO市场。这不是立法者的意图。他们只是想为上市公司添加更多审核。但他们忘记了考虑成本。他们忘记了即将上市的公司通常相当紧张，而对通用电气来说可能容易承受的几个额外审核的重量，足以阻止年轻公司上市。&lt;/p&gt;&#xA;&lt;p&gt;一旦你开始思考审核的成本，你就可以开始问其他有趣的问题。成本是在增加还是减少？在某些地区是否比其他地区高？哪里会不连续地增加？如果大型组织开始问这样的问题，他们会学到一些令人恐惧的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;我认为审核的成本实际上可能在增加&#34;&gt;我认为审核的成本实际上可能在增加。&lt;/h2&gt;&#xA;&lt;p&gt;原因是软件在公司中扮演着越来越重要的角色，而编写软件的人特别受到审核的伤害。&lt;/p&gt;&#xA;&lt;p&gt;程序员与许多类型的工人不同，最好的程序员实际上更愿意努力工作。在大多数类型的工作中似乎并非如此。当我在快餐店工作时，我们并不喜欢繁忙时段。当我过去修剪草坪时，我绝对不喜欢一周下雨后草长得很长的时候。&lt;/p&gt;&#xA;&lt;p&gt;然而，程序员在写更多代码时更喜欢。或者更准确地说，在发布更多代码时更喜欢。程序员喜欢做出改变。好的程序员，无论如何。&lt;/p&gt;&#xA;&lt;p&gt;对于好的程序员来说，为创业公司工作的最大好处之一是发布的审核很少。在真正的创业公司中，根本没有外部审核。如果你早上有一个新功能的想法，你可以在午餐前编写它并将其推送到生产服务器。当你能做到这一点时，你会有更多想法。&lt;/p&gt;&#xA;&lt;p&gt;在大公司，软件必须经过各种批准才能发布。这样做的成本可能是巨大的——实际上是不连续的。最近我和三个程序员交谈，他们的创业公司几年前被一家大公司收购。当他们独立时，他们可以立即发布更改。现在，他们说，他们能在生产服务器上发布代码的最快速度是两周。&lt;/p&gt;&#xA;&lt;p&gt;这不仅让他们生产力降低。这让他们讨厌为收购者工作。&lt;/p&gt;&#xA;&lt;p&gt;这里是程序员多么喜欢能够努力工作的一个迹象：这些人会付钱来立即发布代码，像过去那样。我问他们是否愿意用收购价的10%来换取立即发布代码的能力，三个人立即说愿意。然后我问他们愿意用收购价的最大百分比来换取它。他们说他们不想思考，因为他们不想知道自己会多高，但我得到的印象可能高达一半。&lt;/p&gt;&#xA;&lt;p&gt;他们会牺牲数十万，也许是数百万美元，只是为了能够向用户交付更多软件。你知道吗？让他们这样做是完全安全的。事实上，收购者会更好；这些人不仅不会破坏任何东西，他们会完成更多工作。所以收购者实际上以更高的成本获得了更差的绩效。就像批准软件购买的委员会一样。&lt;/p&gt;&#xA;&lt;p&gt;正如难以销售的最大危险不是你多付钱，而是最好的供应商甚至不会向你销售，对程序员应用太多审核的最大危险不是你会让他们不高效，而是好的程序员甚至不想为你工作。&lt;/p&gt;&#xA;&lt;p&gt;史蒂夫·乔布斯著名的格言&amp;quot;艺术家要发布&amp;quot;有两个方面。艺术家不仅能够发布。他们坚持要发布。所以如果你不让人发布，你就不会有任何艺术家。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ANSI Common Lisp 简介</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/acl1txtt1748944359/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/acl1txtt1748944359/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/acl1txtt1748944359/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;ansi-common-lisp-简介&#34;&gt;ANSI Common Lisp 简介&lt;/h1&gt;&#xA;&lt;p&gt;ANSI Common Lisp 简介&lt;/p&gt;&#xA;&lt;p&gt;（这是Paul Graham的《ANSI Common Lisp》一书的第一章。版权1995年，Prentice-Hall。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;p&gt;John McCarthy和他的学生于1958年开始在第一个Lisp实现上工作。除了Fortran之外，Lisp是仍在使用的最古老的语言。[1] 更值得注意的是，它仍然处于编程语言技术的前沿。了解Lisp的程序员会告诉你，这种语言有某种独特之处。&lt;/p&gt;&#xA;&lt;p&gt;Lisp的独特之处部分在于它被设计为可进化的。你可以使用Lisp来定义新的Lisp操作符。当新的抽象变得流行时（例如面向对象编程），事实证明在Lisp中实现它们总是很容易的。像DNA这样的语言不会过时。&lt;/p&gt;&#xA;&lt;h2 id=&#34;新工具&#34;&gt;新工具&lt;/h2&gt;&#xA;&lt;p&gt;为什么学习Lisp？因为它让你做其他语言做不到的事情。如果你只是想写一个返回小于n的数字之和的函数，在Lisp和C中看起来会非常相似：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; Lisp&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(defun sum (n)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ((s &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (dotimes (i n s)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      (incf s i))))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* C */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; i;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;(s);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你只需要做这样的简单事情，你使用哪种语言并不重要。假设相反，你想写一个函数，它接受一个数字n，并返回一个将n加到其参数上的函数：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;; Lisp&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(defun addn (n)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;#&amp;#39;&lt;/span&gt;(lambda (x) (&lt;span style=&#34;color:#a6e22e&#34;&gt;+&lt;/span&gt; x n)))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;addn在C中是什么样的？你根本写不出来。&lt;/p&gt;&#xA;&lt;p&gt;你可能会想知道，什么时候有人会想做这样的事情？编程语言教会你不要渴望它们不能提供的东西。你必须用一种语言思考才能用其编写程序，很难渴望你无法描述的东西。当我开始编写程序时——使用Basic——我不想念递归，因为我不知道有这样的东西。我用Basic思考。我只能构想迭代算法，为什么要想念递归？&lt;/p&gt;&#xA;&lt;p&gt;如果你不怀念词法闭包（这就是前面例子中制作的东西），暂时相信Lisp程序员一直使用它们。很难找到任何长度的Common Lisp程序不利用闭包。到第112页，你自己也会使用它们。而闭包只是我们在其他语言中找不到的抽象之一。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java的外衣</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/javacover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/javacover/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/javacover/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/javacover.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/javacover.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/javacover.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;java的外衣&#34;&gt;Java的外衣&lt;/h1&gt;&#xA;&lt;p&gt;2001年4月&lt;/p&gt;&#xA;&lt;p&gt;这篇文章源于我与几位程序员关于Java为何气味可疑的对话。这不是对Java的批判！这是黑客雷达的一个案例研究。&lt;/p&gt;&#xA;&lt;p&gt;随着时间的推移，黑客对好（和坏）技术培养出了一种嗅觉。我想试着写下是什么让Java对我来说似乎可疑，这可能会很有趣。&lt;/p&gt;&#xA;&lt;p&gt;一些读过这篇文章的人认为这是试图以前所未有的方式写一些有趣的事情。其他人说我将因为看起来写我不理解的东西而陷入麻烦。所以，以防万一有任何好处，让我澄清我在这里不是在写Java（我从未使用过），而是在写黑客雷达（我对此思考很多）。&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;不能凭封面判断一本书&amp;quot;这句格言起源于书籍用普通纸板封面出售的时代，由每个购买者根据自己的品味装订。在那个时代，你不能凭封面判断一本书。但出版业从那时起进步了：现在的出版商努力使封面成为你可以判断一本书的依据。&lt;/p&gt;&#xA;&lt;p&gt;我花了很多时间在书店，我觉得我现在已经学会理解出版商想要告诉我关于一本书的一切，可能还有更多。我没有在书店度过的时间主要花在电脑前，我觉得我在某种程度上已经学会了通过封面来判断技术。这可能只是运气，但我已经让自己避免了一些最终被证明是真正糟糕的技术。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，Java对我来说似乎很糟糕。我从未写过Java程序，从未看过关于它的参考书，但我有一个预感，它不会是一种非常成功的语言。我可能被证明是错的；对技术做出预测是危险的事情。但作为某种时间胶囊，就其价值而言，这就是为什么我不喜欢Java的外观：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它被如此热情地炒作。真正的标准不需要被推广。没有人需要推广C、Unix或HTML。真正的标准在大多数人听到它之前就已经建立了。在黑客雷达屏幕上，Perl和Java一样大，或者更大，仅仅是凭借自身的优点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它的目标很低。在最初的Java白皮书中，Gosling明确表示Java的设计对习惯C的程序员来说不会太困难。它被设计成另一个C++：C加上一些从更高级语言中借来的想法。就像情景喜剧、垃圾食品或包价旅游的创造者一样，Java的设计者有意识地为不如他们聪明的人设计产品。历史上，为他人使用而设计的语言都很糟糕：Cobol、PL/I、Pascal、Ada、C++。好的语言是那些为自己的设计者设计的：C、Perl、Smalltalk、Lisp。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它有不可告人的动机。有人说过，如果人们只在有话要说时才写书，而不是因为想写书，世界会变得更美好。同样，我们一直听到Java的原因不是因为它对编程语言有什么要说的。我们听到Java作为Sun公司削弱微软计划的一部分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;没有人喜欢它。C、Perl、Python、Smalltalk和Lisp程序员都喜欢他们的语言。我从未听任何人说过他们喜欢Java。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;人们被迫使用它。我认识的许多使用Java的人使用它是因为他们觉得必须这样做。要么是他们觉得为了获得资助必须这样做，要么是他们认为客户会想要，要么是管理层告诉他们要这样做。这些都是聪明人；如果技术好，他们会自愿使用它。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它有太多的厨师。最好的编程语言是由小团体开发的。Java似乎是由一个委员会管理的。如果它最终成为一种好语言，这将是历史上委员会第一次设计出好语言。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是官僚主义的。据我对Java的一点点了解，似乎有很多做事的协议。真正的好语言不是那样的。它们让你做你想做的事，然后让路。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是伪时髦的。Sun现在假装Java是一种像Perl或Python那样的草根、开源语言努力。这个恰好由一家大公司控制。所以这种语言很可能具有与大公司生产的任何东西相同的单调笨重。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它是为大型组织设计的。大型组织的目标与黑客不同。他们想要适合大型平庸程序员团队使用的语言——具有像U-Haul卡车中的限速器那样的功能，防止傻瓜造成太大损害。黑客不喜欢对他们居高临下的语言。黑客只想要力量。历史上，为大型组织设计的语言（PL/I、Ada）都失败了，而黑客语言（C、Perl）获胜了。原因：今天的青少年黑客是明天的CTO。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;错误的人喜欢它。我最钦佩的程序员整体上没有被Java迷住。谁喜欢Java？西装革履的人，不知道一种语言与另一种的区别，但知道他们在媒体上不断听到Java；大公司的程序员，惊讶地发现还有比C++更好的东西；以及即插即用的本科生，准备好喜欢任何可能让他们找到工作的东西（这会考试吗？）。这些人的意见随风而变。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;它的爸爸陷入困境。Sun的商业模式正受到两方面的侵蚀。与台式机相同类型的廉价Intel处理器现在对服务器来说已经足够快了。而且FreeBSD似乎至少与Solaris一样适合作为服务器操作系统。Sun的广告暗示你需要Sun服务器用于工业级应用程序。如果这是真的，Yahoo会第一个排队购买Sun；但当我在那里工作时，服务器都是运行FreeBSD的Intel盒子。这对Sun的未来是个坏兆头。如果Sun遇到麻烦，他们可能会把Java拖下水。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;国防部喜欢它。国防部鼓励开发者使用Java。这在我看来是最 damning 的迹象。国防部的国防工作做得很好（虽然昂贵），但他们喜欢计划、程序和协议。他们的文化与黑客文化相反；在软件问题上他们往往会下错注。国防部最后一次真正喜欢一种编程语言是Ada。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;请记住，这不是对Java的批判，而是对其外衣的批判。我对Java的了解还不足以喜欢或不喜欢它。这只是为什么我不觉得急于学习它的解释。&lt;/p&gt;&#xA;&lt;p&gt;在尝试用一种语言编写程序之前就将其 dismissed 可能看起来 cavalier。但这是所有程序员都必须做的事情。外面的技术太多了，无法全部学习。你必须学会通过外部迹象来判断哪些值得你花时间。我同样 cavalier 地 dismissed 了Cobol、Ada、Visual Basic、IBM AS400、VRML、ISO 9000、SET协议、VMS、Novell Netware和CORBA等。它们只是气味不对。&lt;/p&gt;&#xA;&lt;p&gt;在Java的情况下我可能错了。可能一种由一家大公司推广以削弱另一家大公司、由委员会为&amp;quot;主流&amp;quot;受众设计、被炒作到天际、国防部喜欢的语言，碰巧是一种我会喜欢编程的干净、美丽、强大的语言。可能，但这似乎非常不可能。&lt;/p&gt;&#xA;&lt;p&gt;Trevor Re: Java&amp;rsquo;s Cover | Berners-Lee Re: Java | Being Popular | Sun Internal Memo | 2005: BusinessWeek Agrees&lt;/p&gt;&#xA;&lt;p&gt;日语翻译&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mac的回归</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/mac/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/mac/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/mac/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/mac.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/mac.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/mac.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;mac的回归&#34;&gt;Mac的回归&lt;/h1&gt;&#xA;&lt;p&gt;2005年3月&lt;/p&gt;&#xA;&lt;p&gt;我认识的所有最好的黑客都在逐渐转向Mac。我的朋友Robert说，他在MIT的整个研究小组最近都给自己买了Powerbook。这些人不是90年代中期苹果低谷时期购买Mac的图形设计师和祖母们。他们是你能找到的最核心的OS黑客。&lt;/p&gt;&#xA;&lt;p&gt;原因当然是OS X。Powerbook设计精美，运行FreeBSD。你还需要知道什么？&lt;/p&gt;&#xA;&lt;p&gt;我在去年年底买了一台Powerbook。当我的IBM Thinkpad的硬盘很快损坏后，它成了我唯一的笔记本电脑。当我的朋友Trevor最近出现在我家时，他拿着一台与我相同的Powerbook。&lt;/p&gt;&#xA;&lt;p&gt;对我们大多数人来说，这不是转向苹果，而是回归。尽管在90年代中期很难相信，但Mac在其时代是典型的黑客计算机。&lt;/p&gt;&#xA;&lt;p&gt;1983年秋天，我大学的一门CS课教授站起来，像先知一样宣布，很快将有一种计算机具有半MIPS的处理能力，可以放在飞机座位下，价格如此便宜，我们可以从暑假工作中节省足够的钱来买一台。整个房间都倒吸了一口气。当Mac出现时，它甚至比我们希望的还要好。它如承诺的那样小、强大和便宜。但它也是我们从未想过计算机能成为的东西：设计精美。&lt;/p&gt;&#xA;&lt;p&gt;我必须拥有一台。我不是一个人。在80年代中后期，我认识的所有黑客都在为Mac编写软件，或者想要这样做。剑桥的每个沙发床垫上似乎都躺着一本相同的胖白皮书。如果你把它翻过来，上面写着&amp;quot;Inside Macintosh&amp;quot;。&lt;/p&gt;&#xA;&lt;p&gt;然后是Linux和FreeBSD，黑客们跟随最强大的OS wherever it leads，发现自己转向了Intel盒子。如果你关心设计，你可以买一台Thinkpad，如果你能把Intel和Microsoft的标签从前面撕掉，它至少不会 actively 令人反感。[1]&lt;/p&gt;&#xA;&lt;p&gt;随着OS X的出现，黑客们回来了。当我走进剑桥的苹果商店时，就像回家一样。很多东西都变了，但空气中仍然有那种苹果的酷炫感，感觉表演是由真正关心的人运营的，而不是随机的公司交易者。&lt;/p&gt;&#xA;&lt;p&gt;那又怎样，商界可能会说。谁在乎黑客是否再次喜欢苹果？毕竟，黑客市场有多大？&lt;/p&gt;&#xA;&lt;p&gt;相当小，但相对于其规模来说很重要。当涉及计算机时，黑客现在正在做的事情，十年后每个人都会做。几乎所有的技术，从Unix到位图显示到Web，都是在CS部门和研究实验室中首先流行的，然后逐渐传播到世界其他地方。&lt;/p&gt;&#xA;&lt;p&gt;我记得1986年告诉我父亲，有一种叫做Sun的新型计算机，它是一台严肃的Unix机器，但如此小和便宜，你可以拥有一个自己坐在前面，而不是坐在连接到单个中央Vax的VT100前面。我建议，也许他应该买一些这家公司的股票。我想他真的希望他听了。&lt;/p&gt;&#xA;&lt;p&gt;1994年，我的朋友Koling想和他在台湾的女朋友交谈，为了节省长途账单，他写了一些软件，将声音转换为可以通过互联网发送的数据包。当时我们不确定这是否是互联网的适当用途，互联网当时仍然是一个准政府实体。他现在做的事情被称为VoIP，它是一个巨大且快速增长的业务。&lt;/p&gt;&#xA;&lt;p&gt;如果你想知道十年后普通人会用计算机做什么，只需在一个好大学的CS部门走一圈。无论他们在做什么，你都会做。&lt;/p&gt;&#xA;&lt;p&gt;在&amp;quot;平台&amp;quot;问题上，这种趋势更加明显，因为新颖的软件源自伟大的黑客，他们倾向于首先为他们个人使用的任何计算机编写它。软件销售硬件。Apple II的初始销售中，如果不是大多数的话，很多来自购买它来运行VisiCalc的人。为什么Bricklin和Frankston为Apple II编写VisiCalc？因为他们个人喜欢它。他们可以选择任何机器使其成为明星。&lt;/p&gt;&#xA;&lt;p&gt;如果你想吸引黑客编写销售你的硬件的软件，你必须使它成为他们自己使用的东西。仅仅使其&amp;quot;开放&amp;quot;是不够的。它必须开放且好。&lt;/p&gt;&#xA;&lt;p&gt;而开放且好正是Macs再次成为的。中间的几年创造了一种据我所知前所未有的情况：苹果在低端和高端都很受欢迎，但在中间不。我七十岁的母亲有一台Mac笔记本电脑。我拥有计算机科学博士学位的朋友都有Mac笔记本电脑。[2] 然而苹果的整体市场份额仍然很小。&lt;/p&gt;&#xA;&lt;p&gt;尽管前所未有，但我预测这种情况也是暂时的。&lt;/p&gt;&#xA;&lt;p&gt;所以爸爸，有家叫苹果的公司。他们制造一种新型计算机，设计得像Bang &amp;amp; Olufsen音响系统一样好，下面是你能买到的最好的Unix机器。是的，市盈率有点高，但我想很多人会想要这些。&lt;/p&gt;&#xA;&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;&#xA;&lt;p&gt;[1] 这些可怕的标签很像前Google搜索引擎上流行的侵入性广告。它们对客户说：你不重要。我们关心Intel和Microsoft，而不是你。&lt;/p&gt;&#xA;&lt;p&gt;[2] Y Combinator（我们希望）主要被黑客访问。操作系统的比例是：Windows 66.4%，Macintosh 18.8%，Linux 11.4%，FreeBSD 1.5%。Mac数字与五年前相比是一个很大的变化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;意大利语翻译&#34;&gt;意大利语翻译&lt;/h2&gt;&#xA;&lt;h2 id=&#34;俄语翻译&#34;&gt;俄语翻译&lt;/h2&gt;&#xA;&lt;h2 id=&#34;中文翻译&#34;&gt;中文翻译&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Progbot</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/progbot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/progbot/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/progbot/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/progbot.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/progbot.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/progbot.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;progbot&#34;&gt;Progbot&lt;/h1&gt;&#xA;&lt;p&gt;1993年1月（本文选自《On Lisp》的引言）&lt;/p&gt;&#xA;&lt;p&gt;编程风格的一个悠久原则是，程序的功能组件不应过大。如果程序的某个组件增长到难以理解的程度，它就会变成一团复杂性，如同大城市隐藏逃犯一样轻易地隐藏错误。这样的软件将难以阅读、难以测试、难以调试。&lt;/p&gt;&#xA;&lt;p&gt;根据这一原则，大程序必须被分割成片段，程序越大，分割得越多。如何分割程序？传统的方法称为自顶向下设计：你说&amp;quot;程序的目的是做这七件事，所以我把它分成七个主要子程序。第一个子程序要做这四件事，所以它又有四个自己的子程序&amp;quot;，依此类推。这个过程持续到整个程序达到适当的粒度级别——每个部分足够大以完成实质性工作，又足够小以作为单个单元被理解。&lt;/p&gt;&#xA;&lt;p&gt;有经验的Lisp程序员以不同的方式分割他们的程序。除了自顶向下设计，他们遵循一个可以称为自底向上设计的原则——改变语言以适应问题。在Lisp中，你不仅向语言的方向编写程序，还向程序的方向构建语言。当你编写程序时，你可能会想&amp;quot;我希望Lisp有这样那样的运算符&amp;quot;。于是你就去写它。之后你意识到使用新的运算符会简化程序另一部分的设计，如此类推。语言和程序共同进化。如同两个交战国家之间的边界，语言和程序之间的边界被绘制和重绘，直到最终沿着山脉和河流——你问题的自然边界——安定下来。最终，你的程序看起来就像语言是为它而设计的。当语言和程序相互适应时，你最终得到的代码是清晰、小型和高效的。&lt;/p&gt;&#xA;&lt;p&gt;值得强调的是，自底向上设计不仅仅意味着以不同的顺序编写相同的程序。当你自底向上工作时，你通常最终会得到不同的程序。你得到的不是单一的、整体的程序，而是一个具有更多抽象运算符的更大语言，以及在其中编写的更小程序。你得到的不是门楣，而是拱门。在典型的代码中，一旦抽象出仅仅是簿记的部分，剩下的内容就短得多；你构建的语言层次越高，从上到下需要走的距离就越短。这带来了几个好处：&lt;/p&gt;&#xA;&lt;p&gt;通过让语言做更多的工作，自底向上设计产生的程序更小、更灵活。较短的程序不必被分成那么多组件，更少的组件意味着更容易阅读或修改的程序。更少的组件也意味着组件之间的连接更少，因此出错的机会更少。正如工业设计师努力减少机器中的运动部件数量一样，有经验的Lisp程序员使用自底向上设计来减少程序的大小和复杂性。&lt;/p&gt;&#xA;&lt;p&gt;自底向上设计促进代码重用。当你编写两个或更多程序时，你为第一个程序编写的许多实用程序在后续程序中也会很有用。一旦你获得了大量的实用程序基础，编写新程序可能只需要从头开始使用原始Lisp所需工作的一小部分。&lt;/p&gt;&#xA;&lt;p&gt;自底向上设计使程序更容易阅读。这种类型的抽象实例要求读者理解通用运算符；功能抽象的实例要求读者理解专用子程序。&lt;/p&gt;&#xA;&lt;p&gt;[1] 因为它使你总是在寻找代码中的模式，自底向上工作有助于澄清你对程序设计的想法。如果程序的两个相距较远的组件在形式上相似，你会注意到这种相似性，并可能以更简单的方式重新设计程序。&lt;/p&gt;&#xA;&lt;p&gt;自底向上设计在Lisp以外的语言中在一定程度上也是可能的。每当看到库函数时，就在进行自底向上设计。然而，Lisp在这方面给你更广泛的能力，增强语言在Lisp风格中起着更大的作用——如此之大，以至于Lisp不仅是一种不同的语言，而是一种完全不同的编程方式。&lt;/p&gt;&#xA;&lt;p&gt;确实，这种开发风格更适合可以由小组编写的程序。然而，同时，它扩展了小组可以做的事情的极限。在《人月神话》中，Frederick Brooks提出程序员小组的生产力不会随着其规模线性增长。随着小组规模的增加，单个程序员的生产力会下降。Lisp编程的经验提出了一种更令人振奋的方式来表述这个定律：随着小组规模的减小，单个程序员的生产力会提高。相对而言，小组获胜只是因为它更小。当小组也利用Lisp使之成为可能的技术时，它可以完全获胜。&lt;/p&gt;&#xA;&lt;p&gt;新：免费下载《On Lisp》。&lt;/p&gt;&#xA;&lt;p&gt;[1] &amp;ldquo;但是如果不理解你所有的新实用程序，没有人能读懂这个程序。&amp;ldquo;要了解为什么这样的陈述通常是错误的，请参见第4.8节。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python悖论</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/pypar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/pypar/</guid>
      <description>&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/pypar.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/pypar.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/pypar.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;python悖论&#34;&gt;Python悖论&lt;/h1&gt;&#xA;&lt;p&gt;2004年8月&lt;/p&gt;&#xA;&lt;p&gt;在最近的一次演讲中，我说了一些让很多人不高兴的话：你可以让更聪明的程序员在Python项目上工作，而不是在Java项目上工作。&lt;/p&gt;&#xA;&lt;p&gt;我这样说并不是指Java程序员很笨。我的意思是Python程序员很聪明。学习一门新的编程语言需要很多工作。人们学习Python并不是因为它能给他们带来工作；他们学习它是因为他们真正喜欢编程，并且对已经知道的语言不满意。&lt;/p&gt;&#xA;&lt;p&gt;这使他们成为公司应该想要雇佣的那种程序员。因此，由于缺乏更好的名称，我称之为Python悖论：如果一个公司选择用相对冷门的语言编写其软件，他们将能够雇佣到更好的程序员，因为他们只会吸引那些足够关心它而去学习它的人。而对于程序员来说，这个悖论更加明显：如果你想找到一份好工作，应该学习的语言是那些人们不仅仅是为了找工作而学习的语言。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，只有少数公司足够聪明地意识到了这一点。但这里也有一种选择在进行：它们正是程序员最想为之工作的公司。例如，Google。当他们发布Java编程工作时，他们也希望有Python经验。&lt;/p&gt;&#xA;&lt;p&gt;我的一位朋友几乎知道所有广泛使用的语言，他在大多数项目中都使用Python。他说主要的原因是他喜欢源代码的外观。这可能是选择一种语言而不是另一种语言的轻率理由。但并没有听起来那么轻率：当你编程时，你花在阅读代码上的时间比写代码的时间多。你推着源代码团，就像雕塑家推着粘土团一样。因此，一种让源代码看起来丑陋的语言对于要求精确的程序员来说是令人发疯的，就像充满疙瘩的粘土对于雕塑家一样。&lt;/p&gt;&#xA;&lt;p&gt;提到丑陋的源代码，人们当然会想到Perl。但Perl表面的丑陋并不是我指的那种。真正的丑陋不是看起来刺耳的语法，而是不得不用错误的概念来构建程序。Perl可能看起来像一个骂人的卡通人物，但在某些情况下，它在概念上超越了Python。&lt;/p&gt;&#xA;&lt;p&gt;到目前为止，无论如何。当然，这两种语言都是不断发展的目标。但它们与Ruby（以及Icon、Joy、J、Lisp和Smalltalk）共享一个事实：它们都是由真正关心编程的人创建和使用的。而那些往往是做得好的人。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;如果你喜欢这篇文章，你可能也会喜欢&lt;a href=&#34;https://linguage.github.io/paul_graham/essays_zh/hp/&#34;&gt;黑客与画家&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>伟大的黑客</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/gh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/gh/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/gh/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/gh.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/gh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/gh.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;伟大的黑客&#34;&gt;伟大的黑客&lt;/h1&gt;&#xA;&lt;p&gt;2004年7月&lt;/p&gt;&#xA;&lt;p&gt;（本文源自2004年Oscon大会的演讲。）&lt;/p&gt;&#xA;&lt;p&gt;几个月前我完成了一本新书，在评论中我不断注意到诸如&amp;quot;挑衅性&amp;quot;和&amp;quot;争议性&amp;quot;的词语。更不用说&amp;quot;白痴&amp;quot;了。&lt;/p&gt;&#xA;&lt;p&gt;我并不是想让这本书具有争议性。我试图让它高效。我不想浪费人们的时间告诉他们他们已经知道的事情。更高效的方法只是给他们差异。但我想这必然会产生一本令人担忧的书。&lt;/p&gt;&#xA;&lt;h2 id=&#34;爱迪生们&#34;&gt;爱迪生们&lt;/h2&gt;&#xA;&lt;p&gt;最具争议的想法是：财富的差异可能并不像我们想象的那么大问题。&lt;/p&gt;&#xA;&lt;p&gt;我在书中没有说财富差异本身就是好事。我说在某些情况下它可能是好事的标志。剧烈的头痛不是好事，但它可能是好事的标志——例如，你被击中头部后正在恢复意识。&lt;/p&gt;&#xA;&lt;p&gt;财富差异可能是生产力差异的标志。（在一个人的社会中，它们是相同的。）这几乎肯定是好事：如果你的社会没有生产力差异，可能不是因为每个人都是托马斯·爱迪生。而是因为你没有托马斯·爱迪生。&lt;/p&gt;&#xA;&lt;p&gt;在低技术社会中，你看不到太多的生产力差异。如果你有一群游牧民族为火收集木棍，最好的木棍收集者比最差的能多收集多少？两倍？而当你给人们一个像电脑这样的复杂工具时，他们能用它做的事情的差异是巨大的。&lt;/p&gt;&#xA;&lt;p&gt;这不是一个新想法。Fred Brooks在1974年写过这个，他引用的研究发表于1968年。但我认为他低估了程序员之间的差异。他写了代码行数方面的生产力：最好的程序员可以在十分之一的时间内解决给定问题。但如果问题没有给定呢？在编程中，就像在许多领域一样，困难的部分不是解决问题，而是决定要解决什么问题。想象力很难衡量，但在实践中它主导着以代码行数衡量的那种生产力。&lt;/p&gt;&#xA;&lt;p&gt;生产力在任何领域都有变化，但很少有领域变化如此之大。程序员之间的差异如此之大，以至于成为一种质的差异。我不认为这是编程固有的，但在每个领域，技术都放大了生产力的差异。我认为编程中发生的事情只是因为我们有很多技术杠杆。但在每个领域，杠杆都在变长，所以我们看到的差异是随着时间的推移，越来越多的领域都会看到的。公司和国家的成功将越来越取决于他们如何应对这个问题。&lt;/p&gt;&#xA;&lt;p&gt;如果生产力的差异随着技术而增加，那么最有生产力个体的贡献不仅会不成比例地大，而且会随着时间的推移而实际增长。当你达到一个群体的90%产出由其1%的成员创造的地步时，如果有什么（无论是维京袭击，还是中央计划）将他们的生产力拖到平均水平，你就会损失惨重。&lt;/p&gt;&#xA;&lt;p&gt;如果我们想充分利用他们，我们需要了解这些特别有生产力的人。什么激励他们？他们需要什么来做他们的工作？你如何认识他们？你如何让他们来为你工作？然后当然还有这个问题，你如何成为其中一员？&lt;/p&gt;&#xA;&lt;h2 id=&#34;不仅仅是金钱&#34;&gt;不仅仅是金钱&lt;/h2&gt;&#xA;&lt;p&gt;我认识一些超级黑客，所以我坐下来思考他们有什么共同点。他们的决定性品质可能是他们真的喜欢编程。普通程序员写代码是为了付账单。伟大的黑客认为这是他们为了乐趣而做的事情，并且很高兴发现有人会为此付钱。&lt;/p&gt;&#xA;&lt;p&gt;伟大的程序员有时被认为对金钱漠不关心。这不完全正确。确实，他们真正关心的只是做有趣的工作。但如果你赚了足够的钱，你就可以做任何你想做的工作，因此黑客被赚取巨额金钱的想法所吸引。但只要他们还必须每天上班工作，他们更关心在那里做什么，而不是得到多少报酬。&lt;/p&gt;&#xA;&lt;p&gt;从经济学上讲，这是最重要的事实，因为这意味着你不必支付伟大的黑客接近他们价值的报酬。一个伟大的程序员可能比普通程序员生产力高十倍或一百倍，但他会认为能获得三倍报酬就很幸运了。正如我稍后要解释的，这部分是因为伟大的黑客不知道他们有多好。但也是因为金钱不是他们主要想要的东西。&lt;/p&gt;&#xA;&lt;p&gt;黑客想要什么？像所有工匠一样，黑客喜欢好工具。事实上，这低估了。好的黑客发现无法忍受使用坏工具。他们会拒绝在错误基础设施的项目上工作。&lt;/p&gt;&#xA;&lt;p&gt;在我曾经工作过的一家创业公司，我们公告板上钉着的一张东西是IBM的广告。那是一张AS400的图片，标题写着，我认为，&amp;ldquo;黑客鄙视它。&amp;quot;[1]&lt;/p&gt;&#xA;&lt;p&gt;当你决定为项目使用什么基础设施时，你不仅在做出技术决定。你还在做出社会决定，而这可能是两者中更重要的。例如，如果你的公司想写一些软件，用Java写似乎是一个谨慎的选择。但当你选择一种语言时，你也在选择一个社区。你能雇佣来在Java项目上工作的程序员不会像你能雇佣来在Python项目上工作的那样聪明。而你的黑客的质量可能比你选择的语言更重要。虽然，坦率地说，好的黑客更喜欢Python而不是Java这一事实应该告诉你这些语言的相对优点。&lt;/p&gt;&#xA;&lt;p&gt;商业类型更喜欢最流行的语言，因为他们将语言视为标准。他们不想在公司上下注Betamax。但语言的问题是，它们不仅仅是标准。如果你必须通过网络传输比特，务必使用TCP/IP。但编程语言不仅仅是格式。编程语言是一种表达媒介。&lt;/p&gt;&#xA;&lt;p&gt;我读到Java刚刚超过Cobol成为最流行的语言。作为标准，你不能期望更多。但作为表达媒介，你可以做得更好。在我能想到的所有伟大程序员中，我只知道一个会自愿用Java编程。而在我能想到的所有不为Sun工作的伟大程序员中，在Java方面，我一个也不知道。&lt;/p&gt;&#xA;&lt;p&gt;伟大的黑客通常也坚持使用开源软件。不仅仅是因为它更好，还因为它给他们更多控制权。好的黑客坚持控制权。这是使他们成为好黑客的部分原因：当某些东西坏了时，他们需要修复它。你希望他们对你为他们编写的软件有这种感觉。当他们对操作系统有同样的感觉时，你不应该感到惊讶。&lt;/p&gt;&#xA;&lt;p&gt;几年前，一个风险投资家朋友告诉我他参与的一家新创业公司。听起来很有希望。但下次我和他交谈时，他们说他们决定在Windows NT上构建软件，并刚刚聘请了一位非常有经验的NT开发者担任首席技术官。当我听到这个时，我想，这些人注定要失败。第一，CTO不可能是第一流黑客，因为要成为杰出的NT开发者，他必须自愿多次使用NT，我无法想象一个伟大的黑客会这样做；第二，即使他很好，如果项目必须在NT上构建，他也很难雇佣到优秀的人才。[2]&lt;/p&gt;&#xA;&lt;h2 id=&#34;最后的边疆&#34;&gt;最后的边疆&lt;/h2&gt;&#xA;&lt;p&gt;除了软件，黑客最重要的工具可能是他的办公室。大公司认为办公室空间的功能是表达等级。但黑客不仅仅为此使用办公室：他们将办公室作为思考的地方。如果你是一家技术公司，他们的思想就是你的产品。所以让黑客在嘈杂、分散注意力的环境中工作，就像在油漆厂空气中充满烟尘。&lt;/p&gt;&#xA;&lt;p&gt;连环漫画Dilbert有很多关于隔间的说法，这是有充分理由的。我认识的所有黑客都鄙视它们。仅仅被中断的前景就足以阻止黑客处理困难问题。如果你想在有隔间的办公室里完成真正的工作，你只有两个选择：在家工作，或在别人不在的时候早点来、晚点来或周末来。公司没有意识到这是出了问题的标志吗？办公室环境应该是有助于你工作的东西，而不是你尽管如此才工作的东西。&lt;/p&gt;&#xA;&lt;p&gt;像思科这样的公司为每个人都有一间隔间而自豪，即使是CEO。但他们不像他们想象的那么先进；显然他们仍然将办公室空间视为等级的标志。还要注意，思科以很少在内部进行产品开发而闻名。他们通过收购创造新技术的创业公司来获得新技术——大概在那里黑客确实有安静的工作地方。&lt;/p&gt;&#xA;&lt;p&gt;一家理解黑客需求的大公司是微软。我曾经看到过微软的招聘广告，有一张门的大图片。为我们工作，前提是，我们会给你一个可以真正完成工作的地方。而且你知道，微软在大公司中之所以非凡，是因为他们能够在内部开发软件。也许不太好，但足够好。&lt;/p&gt;&#xA;&lt;p&gt;如果公司希望黑客有生产力，他们应该看看他们在家里做什么。在家里，黑客可以自己安排事情，以便完成最多的工作。当黑客在家工作时，他们不在嘈杂、开放的空间工作；他们在有门的房间里工作。他们在舒适、社区化的地方工作，周围有人，需要思考时可以散步，而不是在停车场英亩的玻璃盒子里。他们有可以在感到疲倦时小睡的沙发，而不是坐在桌前昏迷，假装工作。没有吸尘器人员在每晚黑客黄金时间呼啸而过。没有会议，或者，天哪，公司静修或团队建设练习。当你看他们在电脑上做什么时，你会发现它强化了我之前关于工具的说法。他们在工作时可能必须使用Java和Windows，但在家里，当他们可以自由选择时，你更可能发现他们使用Perl和Linux。&lt;/p&gt;&#xA;&lt;p&gt;事实上，这些关于Cobol或Java是最流行语言的统计数据可能会产生误导。如果我们想知道什么工具最好，我们应该看的是黑客在可以自由选择时选择什么——也就是说，在他们自己的项目中。当你问这个问题时，你会发现开源操作系统已经占据了主导市场份额，排名第一的语言可能是Perl。&lt;/p&gt;&#xA;&lt;h2 id=&#34;有趣&#34;&gt;有趣&lt;/h2&gt;&#xA;&lt;p&gt;除了好工具，黑客想要有趣的项目。什么使项目有趣？嗯，显然像隐形飞机或特效软件那样明显性感的应用程序会很有趣。但任何应用程序如果提出新颖的技术挑战，都可能很有趣。所以很难预测黑客会喜欢哪些问题，因为有些只有在工作的人发现新的解决方案时才变得有趣。在ITA（编写Orbitz内部软件的公司）之前，从事机票价格搜索的人可能认为这是可以想象的最无聊的应用程序。但ITA通过以更雄心勃勃的方式重新定义问题使其变得有趣。&lt;/p&gt;&#xA;&lt;p&gt;我认为谷歌也发生了同样的事情。当谷歌成立时，所谓门户网站的传统看法是搜索很无聊且不重要。但谷歌的人不认为搜索无聊，这就是为什么他们做得这么好。&lt;/p&gt;&#xA;&lt;p&gt;这是管理者可以有所作为的领域。就像父母对孩子说，我打赌你不能在十分钟内清理整个房间，一个好的管理者有时可以将问题重新定义为更有趣的问题。史蒂夫·乔布斯似乎特别擅长这个，部分原因只是因为他有高标准。在Mac之前有很多小型、便宜的电脑。他将问题重新定义为：制造一个漂亮的。这可能比任何胡萝卜或大棒更能驱动开发者。&lt;/p&gt;&#xA;&lt;p&gt;他们确实做到了。当Mac首次出现时，你甚至不必打开它就知道它会很好；你可以从机箱上看出来。几周前我在剑桥的街上走，在某个人的垃圾里我看到了一个似乎是Mac手提箱的东西。我往里看，里面有一台Mac SE。我带回家插上电，它启动了。快乐的Macintosh脸，然后是finder。我的天，它是如此简单。就像&amp;hellip;&amp;hellip;谷歌。&lt;/p&gt;&#xA;&lt;p&gt;黑客喜欢为有高标准的人工作。但仅仅精确是不够的。你必须坚持正确的事情。这通常意味着你必须自己是一个黑客。我偶尔看到过关于如何管理程序员的文章。真的应该有两篇文章：一篇是关于如果你自己是程序员该做什么，另一篇是关于如果你不是该做什么。而第二篇可能可以浓缩成两个词：放弃。&lt;/p&gt;&#xA;&lt;p&gt;问题不在于日常管理。真正好的黑客几乎是自我管理的。问题是，如果你不是黑客，你无法分辨谁是好黑客。一个类似的问题解释了为什么美国汽车如此丑陋。我称之为设计悖论。你可能认为你可以通过雇佣伟大的设计师来设计产品而使产品美丽。但如果你自己没有好品味，你如何认识好设计师？根据定义，你无法从他的作品集中判断。你也不能看他获得的奖项或工作，因为在设计领域，就像在大多数领域一样，这些往往是由时尚和交际驱动的，而实际能力排在第三位。没有办法：你无法在不知道什么是美丽的情况下管理一个旨在生产美丽的过程。美国汽车丑陋是因为美国汽车公司由品味差的人经营。&lt;/p&gt;&#xA;&lt;p&gt;这个国家的许多人认为品味是难以捉摸的，甚至是轻浮的。它都不是。要推动设计，管理者必须是公司产品最苛刻的用户。如果你真的有好品味，你可以像史蒂夫·乔布斯那样，使满足你成为好人喜欢解决的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;讨厌的小问题&#34;&gt;讨厌的小问题&lt;/h2&gt;&#xA;&lt;p&gt;很容易说什么样的问题不是有趣的：那些你必须解决很多讨厌小问题，而不是解决几个大的、清晰的问题。最糟糕的项目之一是为充满错误的软件编写接口。另一个是当你必须为个别客户的复杂和定义不清的需求定制东西。对黑客来说，这类项目是千刀万剐的死亡。&lt;/p&gt;&#xA;&lt;p&gt;讨厌小问题的区别特征是你从中学不到任何东西。编写编译器很有趣，因为它教你什么是编译器。但为有错误的软件编写接口教不了你任何东西，因为错误是随机的。[3] 所以不仅仅是挑剔使好黑客避免讨厌的小问题。这更多是自我保护的问题。处理讨厌的小问题会让你变笨。好黑客避免它就像模特避免奶酪汉堡一样。&lt;/p&gt;&#xA;&lt;p&gt;当然，有些问题固有这种特征。由于供需关系，它们报酬特别高。所以找到方法让伟大黑客处理繁琐问题的公司会非常成功。你会怎么做？&lt;/p&gt;&#xA;&lt;p&gt;这种情况发生的一个地方是创业公司。在我们的创业公司，我们有Robert Morris担任系统管理员。这就像让滚石乐队在犹太成年礼上演奏。你雇佣不到那种人才。但人们会为他们创始人的公司做任何艰苦的工作。[4]&lt;/p&gt;&#xA;&lt;p&gt;大公司通过分割公司来解决这个问题。他们通过建立独立的研发部门来吸引聪明的人为他们工作，员工不必直接处理客户讨厌的小问题。[5] 在这个模型中，研发部门的功能就像矿山。他们产生新想法；也许公司其余部分能够使用它们。&lt;/p&gt;&#xA;&lt;p&gt;你可能不必走到这种极端。自底向上编程提供了另一种分割公司的方法：让聪明的人作为工具制造者工作。如果你的公司制造做x的软件，让一个组构建用于编写这类软件的工具，另一个组使用这些工具编写应用程序。这样你可能能够让聪明的人写99%的代码，但仍然让他们像在传统研发部门那样与用户几乎隔离。工具制造者会有用户，但他们只是公司自己的开发者。[6]&lt;/p&gt;&#xA;&lt;p&gt;如果微软使用这种方法，他们的软件就不会充满安全漏洞，因为编写实际应用程序的较不聪明的人不会做分配内存这样的低级工作。他们不会直接用C编写Word，而是将Word语言的大型乐高积木拼在一起。（Duplo，我相信是技术术语。）&lt;/p&gt;&#xA;&lt;h2 id=&#34;聚集&#34;&gt;聚集&lt;/h2&gt;&#xA;&lt;p&gt;除了有趣的问题，好黑客喜欢的还有其他好黑客。伟大的黑客倾向于聚集在一起——有时如此壮观，就像在施乐帕洛阿尔托研究中心。所以你不会以线性比例吸引好黑客，因为你为他们创造的环境有多好。聚集的倾向意味着它更像是环境的平方。所以赢家通吃。在任何给定时间，只有大约十个或二十个黑客最想工作的地方，如果你不是其中之一，你不仅会有更少的伟大黑客，你会是零。&lt;/p&gt;&#xA;&lt;p&gt;拥有伟大的黑客本身并不足以使公司成功。这对谷歌和ITA很有效，它们是现在的两个热点，但它没有帮助思维机器或施乐。Sun曾经有一段好时光，但他们的商业模式是下降电梯。在这种情况下，即使最好的黑客也救不了你。&lt;/p&gt;&#xA;&lt;p&gt;不过，我认为，在其他条件相同的情况下，能够吸引伟大黑客的公司将具有巨大优势。有人会不同意这一点。当我们在1990年代走访风险投资公司时，几家告诉我们软件公司不是通过编写伟大的软件获胜，而是通过品牌、主导渠道和做正确的交易。&lt;/p&gt;&#xA;&lt;p&gt;他们似乎真的相信这一点，我想我知道为什么。我认为许多风险投资家寻找的，至少在无意识中，是下一个微软。当然，如果微软是你的模型，你不应该寻找希望通过编写伟大软件获胜的公司。但风险投资家寻找下一个微软是错误的，因为没有创业公司能成为下一个微软，除非其他公司准备在恰到好处的时刻弯腰成为下一个IBM。&lt;/p&gt;&#xA;&lt;p&gt;使用微软作为模型是错误的，因为他们的整个文化源自那一次幸运的突破。微软是一个坏的数据点。如果你把他们扔出去，你会发现好产品确实倾向于在市场上获胜。风险投资家应该寻找的是下一个苹果，或下一个谷歌。&lt;/p&gt;&#xA;&lt;p&gt;我想比尔·盖茨知道这一点。谷歌让他担心的不是他们品牌的力量，而是他们有更好的黑客。[7]&lt;/p&gt;&#xA;&lt;h2 id=&#34;认可&#34;&gt;认可&lt;/h2&gt;&#xA;&lt;p&gt;那么谁是伟大的黑客？你遇到时如何知道？结果证明这非常困难。即使是黑客也说不出来。我现在很确定我的朋友Trevor Blackwell是一个伟大的黑客。你可能读过Slashdot上关于他如何制作自己的Segway的报道。这个项目的显著之处是他在一天内写了所有软件（顺便说一句，用Python）。&lt;/p&gt;&#xA;&lt;p&gt;对Trevor来说，这是家常便饭。但当我第一次遇到他时，我认为他是个十足的白痴。他站在Robert Morris的办公室里对他喋喋不休地说着什么，我记得我站在他身后向Robert做疯狂的手势，把这个疯子赶出办公室，这样我们就可以去吃午饭了。Robert说他一开始也误判了Trevor。显然当Robert第一次遇到他时，Trevor刚刚开始一个新计划，涉及在一堆索引卡上写下他生活各方面的所有内容，他随身携带。他也刚从加拿大来，有浓重的加拿大口音和mullet发型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你本不该有老板</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/boss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/boss/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/boss/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/boss.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/boss.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/boss.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;你本不该有老板&#34;&gt;你本不该有老板&lt;/h1&gt;&#xA;&lt;p&gt;想要创业吗？获得Y Combinator的资助。&lt;/p&gt;&#xA;&lt;p&gt;2008年3月，2008年6月修订&lt;/p&gt;&#xA;&lt;p&gt;技术倾向于将正常与自然分开。我们的身体不是被设计来吃富裕国家人们吃的食物，也不是来进行这么少的运动。我们的工作方式可能也有类似的问题：正常的工作对我们智力的伤害可能就像白面粉或糖对我们身体的伤害一样。&lt;/p&gt;&#xA;&lt;p&gt;在与创业创始人共事几年后，我开始怀疑这一点。我现在已经与200多个创始人合作过，我注意到在自己创业公司工作的程序员与在大组织工作的程序员之间有明显的区别。我不会说创始人看起来更快乐， necessarily；创业可能非常有压力。也许最好的说法是，他们在你的身体在长跑时比坐在沙发上吃甜甜圈时更快乐的意义上更快乐。&lt;/p&gt;&#xA;&lt;p&gt;虽然他们在统计上不正常，但创业创始人似乎在以对人类更自然的方式工作。&lt;/p&gt;&#xA;&lt;p&gt;去年我在非洲，看到很多以前只在动物园里见过的野生动物。它们看起来多么不同，这很了不起。特别是狮子。野外的狮子似乎有十倍的活力。它们就像是不同的动物。我怀疑为自己工作对人类来说感觉更好，就像生活在野外对像狮子这样广泛活动的捕食者来说一定感觉更好一样。动物园的生活更容易，但这不是它们被设计的生活。&lt;/p&gt;&#xA;&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;&#xA;&lt;p&gt;在大公司工作有什么不自然的？问题的根源在于人类不是被设计在如此大的群体中工作。&lt;/p&gt;&#xA;&lt;p&gt;当你在野外看到动物时，你注意到的另一件事是，每个物种都在特定大小的群体中茁壮成长。一群黑斑羚可能有100只成年个体；狒狒可能20只；狮子很少10只。人类似乎也被设计在群体中工作，我读到的关于狩猎采集者的内容与组织研究和我的经验相符，表明理想的大小大致是：8人的群体工作良好；到20人时它们变得难以管理；50人的群体真的很笨拙。[1] 无论上限是多少，我们显然不是被设计在几百人的群体中工作。然而——由于与技术而非人性有关的原因——很多人在拥有数百或数千员工的公司工作。&lt;/p&gt;&#xA;&lt;p&gt;公司知道那么大的群体无法工作，所以它们将自己分成足够小以一起工作的单位。但为了协调这些，它们必须引入新的东西：老板。&lt;/p&gt;&#xA;&lt;p&gt;这些较小的群体总是按树状结构排列。你的老板是你的群体附着到树上的点。但是当你使用这个技巧将大群体分成小群体时，会发生一些奇怪的事情，我从未听有人明确提及。在你上一级的群体中，你的老板代表你的整个群体。10个经理的群体不仅仅是10个人以通常方式一起工作的群体。它真的是群体的群体。这意味着为了让10个经理的群体像只是10个个体一样一起工作，每个经理工作的群体必须像一个人一样工作——工人和经理之间只能分享相当于一个人的自由。&lt;/p&gt;&#xA;&lt;p&gt;在实践中，一群人永远无法像一个人一样行动。但在以这种方式分成群体的大组织中，压力总是在那个方向上。每个群体都尽力像人类被设计工作的小个体群体一样工作。创造它的目的就是如此。当你传播这种约束时，结果是每个人获得的行动自由与整个树的大小成反比。[2]&lt;/p&gt;&#xA;&lt;p&gt;任何在大组织工作过的人都感受到过这一点。即使你的群体只有10个人，你也能感受到在100名员工的公司和10,000名员工的公司工作的区别。&lt;/p&gt;&#xA;&lt;h2 id=&#34;玉米糖浆&#34;&gt;玉米糖浆&lt;/h2&gt;&#xA;&lt;p&gt;大组织中的10人群体是一种虚假的部落。你与之互动的人数大约是正确的。但缺少了一些东西：个人主动性。狩猎采集部落的自由度要高得多。领导者比部落其他成员有更多的权力，但他们通常不像老板那样告诉他们做什么和什么时候做。&lt;/p&gt;&#xA;&lt;p&gt;这不是你老板的错。真正的问题是在你上面的层级群体中，你的整个群体是一个虚拟的人。你的老板只是约束传递给你的方式。&lt;/p&gt;&#xA;&lt;p&gt;所以在大组织中的10人群体中工作同时感觉既对又错。表面上它感觉像是你被设计工作的群体类型，但缺少了一些重要的东西。大公司的工作就像高果糖玉米糖浆：它具有你喜欢的东西的一些品质，但灾难性地缺乏其他品质。&lt;/p&gt;&#xA;&lt;p&gt;确实，食物是解释通常工作方式有什么问题的绝佳隐喻。&lt;/p&gt;&#xA;&lt;p&gt;例如，在大公司工作是默认要做的事情，至少对程序员来说。能有多糟糕？嗯，食物很清楚地显示了这一点。如果你今天被随机放在美国的一个地方，你周围几乎所有的食物对你都是有害的。人类不是被设计来吃白面粉、精制糖、高果糖玉米糖浆和氢化植物油的。然而，如果你分析普通杂货店的内容，你可能会发现这四种成分占了大部分热量。&amp;ldquo;正常&amp;quot;食物对你非常糟糕。唯一吃人类被设计实际吃的东西的人是伯克利的几个穿Birkenstock鞋的怪人。&lt;/p&gt;&#xA;&lt;p&gt;如果&amp;quot;正常&amp;quot;食物对我们如此糟糕，为什么它如此普遍？主要有两个原因。一是它有更直接的吸引力。你可能在吃那个披萨一小时后感觉糟糕，但吃前几口感觉很好。另一个是规模经济。生产垃圾食品可以规模化；生产新鲜蔬菜不行。这意味着（a）垃圾食品可以非常便宜，（b）值得花很多钱来营销它。&lt;/p&gt;&#xA;&lt;p&gt;如果人们必须在便宜、大量营销、短期有吸引力的东西和昂贵、晦涩、长期有吸引力的东西之间选择，你认为大多数人会选择哪个？&lt;/p&gt;&#xA;&lt;p&gt;工作也是如此。普通的麻省理工学院毕业生想在谷歌或微软工作，因为它是一个公认的品牌，很安全，他们会立即得到高薪。这是他们午餐吃的披萨的工作等价物。缺点只有在以后才会显现，而且只是一种模糊的不适感。&lt;/p&gt;&#xA;&lt;p&gt;同时，创业公司的创始人和早期员工，就像伯克利的穿Birkenstock鞋的怪人：虽然只是人口的极少数，但他们是像人类被设计那样生活的人。在人工世界里，只有极端主义者自然地生活。&lt;/p&gt;&#xA;&lt;h2 id=&#34;程序员&#34;&gt;程序员&lt;/h2&gt;&#xA;&lt;p&gt;大公司工作的限制性对程序员来说尤其困难，因为编程的本质是构建新事物。销售人员每天做大致相同的推销；支持人员回答大致相同的问题；但一旦你写了一段代码，你就不需要再写它了。所以像程序员被设计那样工作的程序员总是在创造新事物。当你是一个组织的一部分，其结构给予每个人的自由与树的大小成反比时，当你做新事情时，你会面临阻力。&lt;/p&gt;&#xA;&lt;p&gt;这似乎是规模大的必然结果。即使在最聪明的公司也是如此。最近我与一个创始人交谈，他考虑一毕业就创业，但去了谷歌工作，因为他认为在那里会学到更多。他没有学到预期的那么多。程序员通过做来学习，而他想做的大多数事情，他都不能——有时因为公司不让他，但常常因为公司的代码不让他。在遗留代码的阻力、在如此大的组织中进行开发的开销，以及其他群体拥有的接口施加的限制之间，他只能尝试他想做的事情的一小部分。他说他在自己的创业公司学到了更多，尽管他必须做公司的所有杂事以及编程，因为至少当他编程时，他可以做任何他想做的事情。&lt;/p&gt;&#xA;&lt;p&gt;下游的障碍向上游传播。如果不允许你实现新想法，你就会停止有新想法。反之亦然：当你做任何你想做的事情时，你对做什么有更多的想法。所以为自己工作使你的大脑更强大，就像低限制排气系统使发动机更强大一样。&lt;/p&gt;&#xA;&lt;p&gt;为自己工作不一定要意味着创业，当然。但在大公司的常规工作和自己的创业公司之间做决定的程序员可能会在创业中学到更多。&lt;/p&gt;&#xA;&lt;p&gt;通过调整你工作的公司规模，你可以调整你获得的自由量。如果你创办公司，你将有最多的自由。如果你成为前10名员工之一，你将拥有几乎与创始人一样多的自由。即使是100人的公司也会感觉与1000人的公司不同。&lt;/p&gt;&#xA;&lt;p&gt;在小公司工作不确保自由。大组织的树状结构设置了自由的的上限，而不是下限。小公司的头可能仍然选择成为暴君。关键是大组织被其结构 compelled 成为暴君。&lt;/p&gt;&#xA;&lt;h2 id=&#34;后果&#34;&gt;后果&lt;/h2&gt;&#xA;&lt;p&gt;这对组织和个人都有真正的后果。一个是公司随着规模变大不可避免地会变慢，无论它们多么努力保持创业精神。这是每个大组织被迫采用的树状结构的结果。&lt;/p&gt;&#xA;&lt;p&gt;或者说，大组织只有避免树状结构才能避免变慢。而且由于人性限制了可以一起工作的群体规模，我能想象的更大群体避免树状结构的唯一方法是没有结构：让每个群体实际上是独立的，像市场经济组成部分那样一起工作。&lt;/p&gt;&#xA;&lt;p&gt;这可能值得探索。我怀疑已经有一些高度可分的业务倾向于这种方式。但我不知道有任何技术公司这样做。&lt;/p&gt;&#xA;&lt;p&gt;公司可以做的比构建自己为海绵少的一件事是：保持小规模。如果我是对的，那么在每个阶段保持公司尽可能小确实有回报。特别是技术公司。这意味着雇佣最好的人加倍重要。平庸的雇佣伤害你两次：他们完成的更少，但它们也使你变大，因为你需要更多人来解决给定的问题。&lt;/p&gt;&#xA;&lt;p&gt;对个人来说结果是一样的：瞄准小规模。在大组织工作总是会糟糕，组织越大，越糟糕。&lt;/p&gt;&#xA;&lt;p&gt;几年前我写的一篇文章中，我建议即将毕业的 seniors 在创办自己的公司之前为另一家公司工作几年。我现在要修改这个。如果你愿意，可以为另一家公司工作，但只在小公司，如果你想创办自己的创业公司，就继续吧。&lt;/p&gt;&#xA;&lt;p&gt;我建议大学毕业生不要立即创业的原因是我觉得大多数人会失败。而且他们会失败。但有雄心的程序员做自己的事情并失败比去大公司工作更好。当然他们会学到更多。他们甚至在财务上可能更好。很多二十出头的人陷入债务，因为他们的费用增长比离开学校时看起来如此高的工资更快。至少如果你创业并失败，你的净资产将是零而不是负数。[3]&lt;/p&gt;&#xA;&lt;p&gt;我们现在资助了这么多不同类型的创始人，我们有足够的数据看到模式，在大公司工作似乎没有好处。工作过几年的人确实比刚毕业的人看起来更好，但只是因为他们年长那么多。&lt;/p&gt;&#xA;&lt;p&gt;来自大公司的人往往看起来有点保守。很难说有多少是大公司使他们那样的，有多少是使他们首先在大公司工作的自然保守。但很大一部分肯定是学到的。我知道因为我看到它消失了。&lt;/p&gt;&#xA;&lt;p&gt;看到这种情况发生如此多次是让我相信为自己工作，或者至少为小群体工作，是程序员的自然生活方式的事情之一。到达Y Combinator的创始人经常有难民般的被压抑神态。三个月后他们 transformed：他们有如此多的信心，似乎长高了几英寸。[4] 这听起来很奇怪，他们似乎同时更担心和更快乐。这正是我描述野外狮子看起来的方式。&lt;/p&gt;&#xA;&lt;p&gt;看着员工转变为创始人使清楚两个人之间的差异主要是由于环境——特别是大公司的环境对程序员有毒。在他们自己创业公司工作的头几周，他们似乎活了过来，因为他们终于以人们被设计的方式工作了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;&#xA;&lt;p&gt;[1] 当我说人类被 meant 或设计以某种方式生活时，我指的是通过进化。&lt;/p&gt;&#xA;&lt;p&gt;[2] 不仅仅是叶子受苦。约束向上和向下传播。所以经理也受到约束；他们不能只是做事情，而必须通过下属行动。&lt;/p&gt;&#xA;&lt;p&gt;[3] 不要用信用卡为你的创业融资。用债务为创业融资通常是愚蠢的举动，而信用卡债务是最愚蠢的。信用卡债务是个坏主意， period。它是邪恶公司为绝望和愚蠢的人设置的陷阱。&lt;/p&gt;&#xA;&lt;p&gt;[4] 我们资助的创始人曾经更年轻（最初我们鼓励本科生申请），前几次我看到这个时，我常想知道他们是否真的在身体上长高了。&lt;/p&gt;&#xA;&lt;p&gt;感谢Trevor Blackwell、Ross Boucher、Aaron Iba、Abby Kirigin、Ivan Kirigin、Jessica Livingston和Robert Morris阅读本文的草稿。&lt;/p&gt;</description>
    </item>
    <item>
      <title>创造者的日程表，管理者的日程表</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/makersschedule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/makersschedule/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/makersschedule/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/makersschedule.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/makersschedule.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/makersschedule.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;创造者的日程表管理者的日程表&#34;&gt;创造者的日程表，管理者的日程表&lt;/h1&gt;&#xA;&lt;p&gt;2009年7月&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;&amp;hellip;仅仅意识到有约会，有时就会困扰一整天。&amp;rdquo;&#xA;– 查尔斯·狄更斯&lt;/p&gt;&#xA;&lt;p&gt;程序员如此讨厌会议的一个原因是，他们与其他人的日程表类型不同。会议对他们来说成本更高。&lt;/p&gt;&#xA;&lt;p&gt;有两种类型的日程表，我称之为管理者的日程表和创造者的日程表。管理者的日程表是为老板设计的。它体现在传统的约会簿中，每天被划分为一小时的时间段。如果需要，你可以为单个任务屏蔽几个小时，但默认情况下你每小时都会改变正在做的事情。&lt;/p&gt;&#xA;&lt;p&gt;当你这样使用时间时，与某人会面只是一个实际问题。在你的日程表中找一个空闲的时间段，预约他们，就完成了。&lt;/p&gt;&#xA;&lt;p&gt;大多数有权力的人都在管理者的日程表上。这是指挥的日程表。但还有一种使用时间的方式在创造事物的人中很常见，比如程序员和作家。他们通常更喜欢至少以半天为单位使用时间。你无法在一小时的时间内很好地写作或编程。那 barely 是足够开始的时间。&lt;/p&gt;&#xA;&lt;p&gt;当你按照创造者的日程表工作时，会议是灾难性的。一个会议可以毁掉整个下午，因为它把下午分成两部分，每部分都太小，无法做任何困难的事情。而且你必须记得去参加会议。这对于管理者的日程表上的人来说不是问题。下一个小时总是有事情；唯一的问题是什么。但当创造者的日程表上的人有会议时，他们必须考虑它。&lt;/p&gt;&#xA;&lt;p&gt;对于创造者日程表上的人来说，开会就像抛出异常。它不仅让你从一个任务切换到另一个任务；它改变了你工作的模式。&lt;/p&gt;&#xA;&lt;p&gt;我发现一个会议有时会影响一整天。一个会议通常会破坏至少半天，通过打乱上午或下午。此外，有时还有连锁效应。如果我知道下午会被打断，我在上午开始一些雄心勃勃的事情的可能性就会稍微降低。我知道这听起来可能过于敏感，但如果你是创造者，想想你自己的情况。当想到有一整天的时间可以工作，没有任何约会时，你的精神不会振奋吗？嗯，这意味着当你没有这样的时间时，你的精神会相应地低落。而雄心勃勃的项目按定义接近你能力的极限。士气的小幅下降就足以扼杀它们。&lt;/p&gt;&#xA;&lt;p&gt;每种类型的日程表本身都运作良好。当它们相遇时，问题就出现了。由于大多数有权力的人都在管理者的日程表上，他们有能力让每个人都按照他们的频率共振，如果他们想的话。但更聪明的人会克制自己，如果他们知道为他们工作的一些人需要大块的时间来工作。&lt;/p&gt;&#xA;&lt;p&gt;我们的情况是不寻常的。几乎所有的投资者，包括我认识的所有风险投资家，都在管理者的日程表上。但Y Combinator按照创造者的日程表运行。Rtm、Trevor和我这样做是因为我们一直如此，Jessica也主要是如此，因为她与我们同步。&lt;/p&gt;&#xA;&lt;p&gt;如果开始有更多像我们这样的公司，我不会感到惊讶。我怀疑创始人可能越来越能够抵抗，或至少推迟，转变为管理者，就像几十年前他们开始能够抵抗从牛仔裤换成西装一样。&lt;/p&gt;&#xA;&lt;p&gt;我们如何在创造者的日程表上为这么多创业公司提供建议？通过使用在创造者的日程表中模拟管理者日程表的经典设备：办公时间。我每周几次留出一大块时间来见我们资助的创始人。这些时间块是在我工作日的末尾，我写了一个注册程序，确保给定办公时间内的所有预约都集中在末尾。因为它们在我的一天结束时到来，这些会议从来不会中断。（除非他们的工作日与我的同时结束，会议可能会中断他们的，但既然他们预约了，对他们来说一定是值得的。）在繁忙时期，办公时间有时会变得足够长，以至于压缩了一天，但它们从不中断它。&lt;/p&gt;&#xA;&lt;p&gt;当我们在90年代为自己的创业公司工作时，我发展出了另一个划分一天的技巧。我每天从晚餐编程到大约凌晨3点，因为在晚上没有人能打断我。然后我会睡到大约上午11点，进来工作直到晚餐，我称之为&amp;quot;业务事情&amp;quot;。我从来没有用这些术语思考过，但实际上我每天都有两个工作日，一个在管理者的日程表上，一个在创造者的日程表上。&lt;/p&gt;&#xA;&lt;p&gt;当你按照管理者的日程表工作时，你可以做一些在创造者的日程表上永远不想做的事情：你可以进行试探性会议。你可以见某人只是为了互相认识。如果你的日程表有空闲的时间段，为什么不呢？也许结果你们可以在某种程度上互相帮助。&lt;/p&gt;&#xA;&lt;p&gt;硅谷的商界人士（实际上是整个世界）一直在进行试探性会议。如果你在管理者的日程表上，它们实际上是免费的。它们如此普遍，以至于有独特的语言来提议它们：例如，说你想要&amp;quot;喝杯咖啡&amp;quot;。&lt;/p&gt;&#xA;&lt;p&gt;但是，如果你在创造者的日程表上，试探性会议的成本非常可怕。这使我们陷入某种困境。每个人都认为，像其他投资者一样，我们在管理者的日程表上运行。所以他们向我们介绍他们认为我们应该见面的人，或者给我们发邮件提议我们喝杯咖啡。在这一点上，我们有两个选择，都不好：我们可以与他们见面，失去半天的工作；或者我们可以尝试避免与他们见面，可能会冒犯他们。&lt;/p&gt;&#xA;&lt;p&gt;直到最近，我们自己对问题的根源还不清楚。我们只是想当然地认为我们必须要么破坏我们的日程表，要么冒犯人。但现在我意识到发生了什么，也许有第三种选择：写一些解释两种类型日程表的东西。也许最终，如果管理者的日程表和创造者的日程表之间的冲突开始被更广泛地理解，它会变得不那么成问题。&lt;/p&gt;&#xA;&lt;p&gt;我们这些在创造者日程表上的人愿意妥协。我们知道我们必须有一定数量的会议。我们只要求那些在管理者日程表上的人理解成本。&lt;/p&gt;&#xA;&lt;p&gt;感谢 Sam Altman、Trevor Blackwell、Paul Buchheit、Jessica Livingston 和 Robert Morris 阅读本文的草稿。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;相关：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何做你喜欢的事&lt;/li&gt;&#xA;&lt;li&gt;好的和坏的拖延&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>另一条道路</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/road/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/road/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/road/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/road.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/road.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/road.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;另一条道路&#34;&gt;另一条道路&lt;/h1&gt;&#xA;&lt;p&gt;2001年9月&lt;/p&gt;&#xA;&lt;p&gt;（本文解释了为什么下一代软件的大部分可能是基于服务器的，这对程序员意味着什么，以及这种新型软件为什么是创业公司的绝佳机会。本文源自在BBN实验室的一次演讲。）&lt;/p&gt;&#xA;&lt;p&gt;1995年夏天，我的朋友Robert Morris和我决定创办一家创业公司。当时，围绕Netscape IPO的公关活动正如火如荼地进行，媒体上有很多关于电子商务的讨论。那时网络上可能只有三十家实际的商店，都是手工制作的。如果将来会有很多在线商店，就需要制作它们的软件，所以我们决定写一些这样的软件。&lt;/p&gt;&#xA;&lt;p&gt;在最初的一周左右，我们打算将其制作成一个普通的桌面应用程序。然后有一天我们想到让软件在我们的Web服务器上运行，使用浏览器作为界面。我们尝试重写软件使其在Web上工作，很明显这是正确的方法。如果我们编写的软件在服务器上运行，对用户和我们自己都会容易得多。&lt;/p&gt;&#xA;&lt;p&gt;结果证明这是一个好计划。现在，作为Yahoo Store，这个软件是最受欢迎的在线商店构建器，拥有约14,000个用户。&lt;/p&gt;&#xA;&lt;p&gt;当我们开始Viaweb时，几乎没有人理解我们说软件在服务器上运行是什么意思。直到一年后Hotmail推出，人们才开始理解。现在每个人都知道这是一个有效的方法。我们现在所做的事情有了一个名字：应用服务提供商，或ASP。&lt;/p&gt;&#xA;&lt;p&gt;我认为下一代软件的大部分都将按照这个模型编写。即使是损失最大的微软，似乎也看到将一些东西移出桌面是不可避免的。如果软件从桌面移到服务器上，对开发者来说将意味着一个完全不同的世界。本文描述了我们作为这个新世界的首批访客所看到的令人惊讶的事情。就软件确实转移到服务器上的程度而言，我在这里描述的就是未来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;下一件大事&#34;&gt;下一件大事？&lt;/h2&gt;&#xA;&lt;p&gt;当我们回顾桌面软件时代时，我想我们会惊叹于人们忍受的不便，就像我们现在惊叹于早期车主忍受的不便一样。在最初的二三十年里，你必须是一个汽车专家才能拥有汽车。但汽车是一个如此巨大的进步，以至于很多不是汽车专家的人也想拥有它们。&lt;/p&gt;&#xA;&lt;p&gt;计算机现在正处于这个阶段。当你拥有桌面计算机时，你最终会学到比你想要知道的更多关于其内部情况的知识。但超过一半的美国家庭都拥有一台。我母亲有一台计算机，她用它来收发邮件和记账。大约一年前，她收到Apple的一封信，为她提供新操作系统的折扣，这让她感到担忧。当一个65岁的女性只想用计算机来收发邮件和记账时，却不得不考虑安装新的操作系统，这就有问题了。普通用户甚至不应该知道&amp;quot;操作系统&amp;quot;这个词，更不用说&amp;quot;设备驱动程序&amp;quot;或&amp;quot;补丁&amp;quot;了。&lt;/p&gt;&#xA;&lt;p&gt;现在有另一种交付软件的方式可以拯救用户免于成为系统管理员。基于Web的应用程序是在Web服务器上运行并使用Web页面作为用户界面的程序。对于普通用户来说，这种新型软件将比桌面软件更容易、更便宜、更便携、更可靠，而且通常更强大。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的软件，大多数用户除了他们使用的应用程序外，不必考虑任何其他事情。所有混乱、变化的东西都将位于某处的服务器上，由擅长这种事情的人维护。因此，你通常不需要特定的计算机来使用软件。你只需要一个带有键盘、屏幕和Web浏览器的东西。也许它会有无线互联网接入。也许它也会是你的手机。无论它是什么，都将是消费电子产品：价格约200美元，人们主要根据外观选择的东西。你将在互联网服务上花费比硬件更多的钱，就像你现在对电话所做的那样。[1]&lt;/p&gt;&#xA;&lt;p&gt;点击到达服务器并返回需要大约十分之一秒，所以重度交互软件的用户，如Photoshop，仍然希望计算在桌面上进行。但如果你看大多数人使用计算机做的那种事情，十分之一秒的延迟不会成为问题。我母亲真的不需要桌面计算机，有很多像她这样的人。&lt;/p&gt;&#xA;&lt;h2 id=&#34;用户的胜利&#34;&gt;用户的胜利&lt;/h2&gt;&#xA;&lt;p&gt;我家附近有一辆车，保险杠上贴着&amp;quot;死也不愿不便&amp;quot;。大多数人，在大多数时候，会选择需要最少工作的选择。如果基于Web的软件获胜，那将是因为它更方便。对于用户和开发者来说，它似乎都会更方便。&lt;/p&gt;&#xA;&lt;p&gt;使用纯基于Web的应用程序，你只需要一个连接到互联网的浏览器。所以你可以在任何地方使用基于Web的应用程序。当你在桌面计算机上安装软件时，你只能在该计算机上使用它。更糟糕的是，你的文件被困在那台计算机上。随着人们习惯网络，这种模式的不便越来越明显。&lt;/p&gt;&#xA;&lt;p&gt;这里的开端是基于Web的电子邮件。现在数百万人意识到，无论你在哪里，都应该能够访问电子邮件。如果你能看到你的邮件，为什么不能看到你的日历？如果你能和同事讨论文档，为什么不能编辑它？为什么你的任何数据都应该被困在某个远处桌子的计算机上？&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;你的计算机&amp;quot;的整个概念正在消失，被&amp;quot;你的数据&amp;quot;所取代。你应该能够从任何计算机访问你的数据。或者更确切地说，任何客户端，而客户端不一定是计算机。&lt;/p&gt;&#xA;&lt;p&gt;客户端不应该存储数据；它们应该像电话一样。事实上，它们可能会变成电话，或者反之亦然。随着客户端变小，你有另一个理由不在它们上保存数据：随身携带的东西可能会丢失或被盗。把PDA留在出租车里就像磁盘崩溃，只是你的数据交给了别人而不是被蒸发掉了。&lt;/p&gt;&#xA;&lt;p&gt;使用纯基于Web的软件，你的数据和应用程序都不会保存在客户端上。所以你不需要安装任何东西来使用它。当没有安装时，你不必担心安装出错。应用程序和你的操作系统之间不可能存在不兼容性，因为软件不在你的操作系统上运行。&lt;/p&gt;&#xA;&lt;p&gt;因为它不需要安装，所以在你&amp;quot;购买&amp;quot;之前尝试基于Web的软件将是容易且常见的。你应该期望能够免费试用任何基于Web的应用程序，只需访问提供它的网站即可。在Viaweb，我们的整个网站就像一个大箭头，指向用户试驾。&lt;/p&gt;&#xA;&lt;p&gt;试驾后，注册服务只需要填写一个简短的表格（越简短越好）。这应该是用户必须做的最后工作。有了基于Web的软件，你应该无需额外付费、做任何工作，甚至可能无需知道就能获得新版本。&lt;/p&gt;&#xA;&lt;p&gt;升级不会像现在那样令人震惊。随着时间的推移，应用程序将悄然变得更强大。这需要开发者付出一些努力。他们必须设计软件，使其能够在不使用户困惑的情况下更新。这是一个新问题，但有解决方法。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的应用程序，每个人都使用相同的版本，错误一旦发现就可以修复。所以基于Web的软件应该比桌面软件的错误少得多。在Viaweb，我怀疑我们任何时候有过十个已知的错误。这比桌面软件好几个数量级。&lt;/p&gt;&#xA;&lt;p&gt;基于Web的应用程序可以同时被多个人使用。这对于协作应用程序来说显然是一个优势，但我敢打赌，一旦用户意识到这是可能的，他们会开始在大多数应用程序中想要这个功能。例如，让两个人编辑同一个文档通常是有用的。Viaweb允许多个用户同时编辑一个站点，更多是因为这是编写软件的正确方式，而不是因为我们期望用户想要这样做，但结果证明很多人确实这样做了。&lt;/p&gt;&#xA;&lt;p&gt;当你使用基于Web的应用程序时，你的数据会更安全。磁盘崩溃不会成为过去的事情，但用户不会再听到它们。它们将发生在服务器集群中。提供基于Web应用程序的公司实际上会进行备份——不仅因为他们会有真正的系统管理员担心这些事情，而且因为丢失用户数据的ASP将陷入巨大的麻烦。当人们在自己的磁盘崩溃中丢失数据时，他们不会太生气，因为他们只能生自己的气。当公司为他们丢失数据时，他们会更生气。&lt;/p&gt;&#xA;&lt;p&gt;最后，基于Web的软件应该对病毒不那么脆弱。如果客户端除了浏览器外不运行任何东西，运行病毒的机会就更少，本地也没有数据可以损坏。攻击服务器本身的程序会发现它们防御得很好。[2]&lt;/p&gt;&#xA;&lt;p&gt;对于用户来说，基于Web的软件压力会更小。我认为如果你查看普通Windows用户的内心，你会发现对符合这种描述的软件有着巨大且基本未被利用的渴望。释放出来，它可能是一股强大的力量。&lt;/p&gt;&#xA;&lt;h2 id=&#34;代码之城&#34;&gt;代码之城&lt;/h2&gt;&#xA;&lt;p&gt;对于开发者来说，基于Web和桌面软件之间最显著的区别是，基于Web的应用程序不是单一的代码片段。它将是不同类型程序的集合，而不是单一的大二进制文件。因此设计基于Web的软件更像设计城市而不是建筑：除了建筑物，你还需要道路、路标、公用设施、警察和消防部门，以及增长和各种灾难的计划。&lt;/p&gt;&#xA;&lt;p&gt;在Viaweb，软件包括相当大的应用程序，用户直接与之对话；这些程序使用的程序；在后台持续运行寻找问题的程序；如果出现问题尝试重新启动事物的程序；偶尔运行以编译统计信息或构建搜索索引的程序；我们明确运行以垃圾收集资源或移动或恢复数据的程序；假装是用户的程序（以测量性能或暴露错误）；诊断网络问题的程序；进行备份的程序；外部服务的接口；驱动令人印象深刻的表盘集合显示实时服务器统计的软件（对访客来说很受欢迎，但对我们来说也是不可或缺的）；对开源软件的修改（包括错误修复）；以及大量的配置文件和设置。在我们被Yahoo收购后，Trevor Blackwell编写了一个精彩的程序，可以在不关闭商店的情况下将商店迁移到全国的新服务器。程序通过传呼机呼叫我们，向用户发送传真和电子邮件，与信用卡处理商进行交易，并通过套接字、管道、http请求、ssh、udp数据包、共享内存和文件相互交谈。Viaweb的一部分甚至由程序的缺失组成，因为Unix安全的关键之一是不运行人们可能用来闯入服务器的不必要实用程序。&lt;/p&gt;&#xA;&lt;p&gt;这并不以软件结束。我们花了很多时间思考服务器配置。我们自己从组件构建服务器——部分是为了省钱，部分是为了得到我们想要的东西。我们必须考虑我们的上游ISP是否与所有骨干网有足够快的连接。我们与RAID供应商连续约会。&lt;/p&gt;&#xA;&lt;p&gt;但硬件不仅仅是要担心的事情。当你控制它时，你可以为用户做更多。对于桌面应用程序，你可以指定某些最低硬件要求，但你不能添加更多。如果你管理服务器，你可以一步让所有用户能够传呼别人，或发送传真，或通过电话发送命令，或处理信用卡等，只需安装相关硬件即可。我们总是寻找用硬件添加功能的新方法，不仅因为它让用户高兴，而且作为将自己与竞争对手区分开来的方式——竞争对手要么因为他们销售桌面软件，要么通过ISP转售基于Web的应用程序，不能直接控制硬件。&lt;/p&gt;&#xA;&lt;p&gt;因为基于Web应用程序中的软件将是程序的集合而不是单一的二进制文件，它可以用多种不同的语言编写。当你编写桌面软件时，你实际上被迫用与底层操作系统相同的语言编写应用程序——即C和C++。因此，这些语言（尤其是在非技术人员如经理和风险投资家中）被认为是&amp;quot;严肃&amp;quot;软件开发的语言。但这只是桌面软件必须交付方式的人工产物。对于基于服务器的软件，你可以使用任何你想要的语言。[3] 今天，许多顶级黑客使用远离C和C++的语言：Perl、Python，甚至Lisp。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，没有人能告诉你使用什么语言，因为你控制整个系统，一直到硬件。不同的语言适合不同的任务。你可以为每个任务使用最适合的语言。当你有竞争对手时，&amp;ldquo;你可以&amp;quot;意味着&amp;quot;你必须&amp;rdquo;（我们稍后会回到这一点），因为如果你不利用这种可能性，你的竞争对手会。&lt;/p&gt;&#xA;&lt;p&gt;我们的大多数竞争对手使用C和C++，这使得他们的软件明显 inferior，因为（除其他外），他们无法解决CGI脚本的无状态性问题。如果你要改变什么，所有的改变都必须在一个页面上发生，底部有一个更新按钮。正如我在其他地方写过的，通过使用许多人仍然认为是研究语言的Lisp，我们能够让Viaweb编辑器的行为更像桌面软件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;发布&#34;&gt;发布&lt;/h2&gt;&#xA;&lt;p&gt;在这个新世界中最重要的变化之一是你进行发布的方式。在桌面软件业务中，进行发布是一个巨大的创伤，整个公司都在努力推出一个单一的、巨大的代码片段。明显的比较会让人联想到这个过程和最终产品。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，你可以像为自己编写的程序那样几乎实时地进行更改。你以一系列增量更改而不是偶尔的大爆炸形式发布软件。一个典型的桌面软件公司可能一年进行一两次发布。在Viaweb，我们通常一天进行三到五次发布。&lt;/p&gt;&#xA;&lt;p&gt;当你切换到这个新模式时，你会意识到软件开发受到发布方式的影响有多大。你在桌面软件业务中看到的一些最令人讨厌的问题是由于发布的灾难性性质造成的。&lt;/p&gt;&#xA;&lt;p&gt;当你每年只发布一个新版本时，你倾向于批量处理错误。在发布日期之前的某个时间，你组装一个新版本，其中一半的代码被撕掉并替换，引入了无数错误。然后一队QA人员介入并开始计算它们，程序员们处理这个列表，修复它们。他们通常不会到达列表的末尾，事实上，没有人确定末尾在哪里。这就像从池塘里捞碎石。你永远不知道软件内部发生了什么。充其量你最终得到一种统计上的正确性。&lt;/p&gt;&#xA;&lt;p&gt;有了基于服务器的软件，大多数更改都是小而增量的。这本身就不太可能引入错误。这也意味着当你准备发布软件时，你知道最需要仔细测试什么：你最后改变的东西。你对代码的控制要牢固得多。作为一个一般规则，你确实知道它内部发生了什么。当然你没有记住源代码，但当你阅读源代码时，你这样做就像飞行员扫描仪表盘，而不是像侦探试图解开一些谜团。&lt;/p&gt;&#xA;&lt;p&gt;桌面软件培养了对错误的某种宿命论。你知道你正在发布充满错误的东西，你甚至建立了补偿机制（例如补丁发布）。那么为什么还要担心几个更多的错误呢？很快你就会发布你知道有问题的整个功能。苹果今年早些时候就这样做了。他们感到压力要发布他们的新操作系统，其发布日期已经四次推迟，但一些软件（对CD和DVD的支持）还没有准备好。解决方案？他们在没有完成部分的情况下发布了操作系统，用户将不得不稍后安装它们。&lt;/p&gt;&#xA;&lt;p&gt;有了基于Web的软件，你永远不必在软件能够工作之前发布它，你可以一旦它能够工作就发布它。&lt;/p&gt;&#xA;&lt;p&gt;行业资深人士可能会想，说你在软件能够工作之前永远不必发布软件听起来是个好主意，但当你承诺在某个日期之前交付软件的新版本时会发生什么？有了基于Web的软件，你不会做出这样的承诺，因为没有版本。你的软件逐渐而持续地变化。一些变化可能比其他变化更大，但版本的概念自然不适合基于Web的软件。&lt;/p&gt;&#xA;&lt;p&gt;如果有人记得Viaweb，这可能听起来很奇怪，因为我们总是在宣布新版本。这完全是为了公关目的。我们了解到，行业媒体是以版本号思考的。他们会为主要版本提供主要报道，意思是版本号的新第一位数字，而对于点版本，通常最多只有一个段落，意思是小数点后的新数字。&lt;/p&gt;&#xA;&lt;p&gt;我们的一些竞争对手提供桌面软件，实际上有版本号。对于这些发布，仅仅这个事实在我们看来就是他们落后的证据，他们会获得各种宣传。我们不想错过，所以我们也开始给我们的软件版本号。当我们想要一些宣传时，我们会列出自上次&amp;quot;发布&amp;quot;以来我们添加的所有功能，在软件上贴上一个新版本号，并发布新闻稿说新版本立即可用。令人惊讶的是，从来没有人指责我们这样做。&lt;/p&gt;&#xA;&lt;p&gt;到我们被收购时，我们已经这样做了三次，所以我们处于版本4。如果我没记错的话，是版本4.1。在Viaweb成为Yahoo Store后，不再如此迫切需要宣传，所以尽管软件继续发展，版本号的整个概念被悄然放弃了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;错误&#34;&gt;错误&lt;/h2&gt;&#xA;&lt;p&gt;基于Web软件的另一个主要技术优势是你可以重现大多数错误。用户的数据就在你的磁盘上。如果有人破坏了你的软件，你不必像桌面软件那样猜测发生了什么：你应该能够在他们在电话上与你交谈时重现错误。如果你在应用程序中内置了注意错误的代码，你甚至可能已经知道它。&lt;/p&gt;&#xA;&lt;p&gt;基于Web的软件全天候使用，所以你所做的一切都会立即受到考验。错误很快就会出现。&lt;/p&gt;&#xA;&lt;p&gt;软件公司有时被指控让用户调试他们的软件。而这正是我所倡导的。对于基于Web的软件，这实际上是一个好计划，因为错误更少且短暂。当你逐渐发布软件时，一开始你得到的错误会少得多。当你能够重现错误并立即发布更改时，你可以在大多数错误出现时找到并修复它们。我们任何时候都没有足够的错误需要正式的错误跟踪系统。&lt;/p&gt;&#xA;&lt;p&gt;当然，你应该在发布之前测试更改，所以不应该发布主要错误。那些不可避免地漏掉的少数错误将涉及边界情况，并且只会在有人打电话抱怨之前影响少数遇到它们的用户。只要你立即修复错误，对于普通用户来说，净效果是错误少得多。我怀疑普通Viaweb用户曾经看到过错误。&lt;/p&gt;&#xA;&lt;p&gt;修复新错误比修复旧错误更容易。在你刚刚编写的代码中找到错误通常相当快。当它出现时，你往往在查看源代码之前就知道哪里错了，因为你已经在潜意识中担心它了。修复六个月前编写的代码中的错误（如果你一年发布一次，这是平均情况）要多花很多工作。而且由于你对代码的理解不够，你更有可能以丑陋的方式修复它，甚至引入更多错误。[4]&lt;/p&gt;&#xA;&lt;p&gt;当你及早发现错误时，你也会得到更少的复合错误。复合错误是两个相互作用的独立错误：你下楼时绊倒，当你伸手抓住栏杆时，它从你手中脱落。在软件中，这种错误是最难发现的，而且往往具有最严重的后果。[5] 传统的&amp;quot;打破一切然后过滤错误&amp;quot;方法本质上会产生很多复合错误。而以一系列小更改发布的软件本质上不会这样。地板不断被清扫干净，任何可能后来卡在什么东西里的松散物体。&lt;/p&gt;&#xA;&lt;p&gt;如果你使用一种称为函数式编程的技术，这会有所帮助。函数式编程意味着避免副作用。你更可能在研究论文中看到它，而不是商业软件，但对于基于Web的应用程序，它结果非常有用。将整个程序写成纯函数式代码很难，但你可以用这种方式编写实质性的部分。它使你软件的这些部分更容易测试，因为它们没有状态，在你不断制作和测试小修改的情况下，这非常方便。我用这种风格编写了Viaweb编辑器的大部分，我们使我们的脚本语言RTML成为一种纯函数式语言。&lt;/p&gt;&#xA;&lt;p&gt;来自桌面软件业务的人会发现这难以置信，但在Viaweb，错误几乎成了一种游戏。由于大多数发布的错误都涉及边界情况，遇到它们的用户可能是高级用户，他们在测试极限。高级用户对错误更宽容，特别是因为你可能是在添加他们要求的功能时引入了它们的。事实上，因为错误很少，你必须做复杂的事情才能看到它们，高级用户常常为抓住一个而感到自豪。他们会怀着更多是胜利而不是愤怒的精神致电支持，好像他们从我们这里得分了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>垃圾邮件过滤计划</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/spam/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/spam/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/spam/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/spam.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/spam.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/spam.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;垃圾邮件过滤计划&#34;&gt;垃圾邮件过滤计划&lt;/h1&gt;&#xA;&lt;p&gt;2002年8月&lt;/p&gt;&#xA;&lt;p&gt;（本文描述了在我们构建的用于测试Arc的反垃圾邮件网络邮件阅读器中使用的垃圾邮件过滤技术。改进的算法在《更好的贝叶斯过滤》中有描述。）我认为可以阻止垃圾邮件，而基于内容的过滤器是实现这一目标的方法。垃圾邮件发送者的致命弱点是他们的消息。他们可以绕过你设置的任何其他障碍。至少到目前为止是这样。但他们必须传递他们的信息，无论是什么。如果我们能够编写识别他们消息的软件，就没有办法能够绕过它。&lt;/p&gt;&#xA;&lt;p&gt;对收件人来说，垃圾邮件很容易识别。如果你雇佣某人阅读你的邮件并丢弃垃圾邮件，他们会毫无困难地做到这一点。我们需要做多少工作，除了人工智能之外，来自动化这个过程？&lt;/p&gt;&#xA;&lt;p&gt;我认为我们将能够用相当简单的算法解决这个问题。事实上，我发现你可以使用不比单个词的垃圾邮件概率的贝叶斯组合更多的东西来相当好地过滤现在的垃圾邮件。使用一个稍微调整的（如下所述）贝叶斯过滤器，我们现在在每1000封垃圾邮件中遗漏少于5封，误报率为0。&lt;/p&gt;&#xA;&lt;p&gt;统计方法通常不是人们编写垃圾邮件过滤器时首先尝试的方法。大多数黑客的第一本能是尝试编写识别垃圾邮件单个特征的软件。你看着垃圾邮件，想，这些家伙竟然敢给我发送以&amp;quot;亲爱的朋友&amp;quot;开头的邮件，或者主题行全是大写并以八个感叹号结尾的邮件。我可以用大约一行代码过滤掉这些东西。&lt;/p&gt;&#xA;&lt;p&gt;于是你这样做了，开始时它有效。几个简单的规则会大量减少你收到的垃圾邮件。仅仅查找&amp;quot;点击&amp;quot;这个词就会捕获我垃圾邮件语料库中79.7%的邮件，误报率只有1.2%。&lt;/p&gt;&#xA;&lt;p&gt;在尝试统计方法之前，我花了大约六个月编写查找单个垃圾邮件特征的软件。我发现的是，识别最后百分之几的垃圾邮件变得非常困难，而且当我使过滤器更严格时，我得到了更多的误报。&lt;/p&gt;&#xA;&lt;p&gt;误报是被错误识别为垃圾邮件的无辜邮件。对于大多数用户来说，错过合法邮件比收到垃圾邮件糟糕一个数量级，因此产生误报的过滤器就像带有死亡风险的痤疮治疗。&lt;/p&gt;&#xA;&lt;p&gt;用户收到的垃圾邮件越多，他们注意到一封无辜邮件坐在垃圾邮件文件夹中的可能性就越小。奇怪的是，你的垃圾邮件过滤器越好，误报就变得越危险，因为当过滤器真的很好时，用户更可能忽略它们捕获的一切。&lt;/p&gt;&#xA;&lt;p&gt;我不知道为什么我这么长时间才尝试统计方法。我想这是因为我对试图自己识别垃圾邮件特征上了瘾，好像我在和垃圾邮件发送者玩某种竞争游戏。（非黑客通常不会意识到这一点，但大多数黑客非常有竞争心。）当我尝试统计分析时，我立即发现它比我聪明得多。它当然发现了像&amp;quot;virtumundo&amp;quot;和&amp;quot;teens&amp;quot;这样的术语是垃圾邮件的良好指标。但它还发现&amp;quot;per&amp;quot;和&amp;quot;FL&amp;quot;和&amp;quot;ff0000&amp;quot;是垃圾邮件的良好指标。事实上，&amp;ldquo;ff0000&amp;rdquo;（亮红色的html）结果证明和任何色情术语一样是垃圾邮件的良好指标。&lt;/p&gt;&#xA;&lt;p&gt;以下是我如何进行统计过滤的概述。我从一个垃圾邮件语料库和一个非垃圾邮件语料库开始。目前每个语料库中大约有4000条消息。我扫描每个语料库中每条消息的整个文本，包括标题、嵌入的html和javascript。我目前认为字母数字字符、破折号、撇号和美元符号是标记的一部分，其他一切都是标记分隔符。（这里可能还有改进的空间。）我忽略全是数字的标记，我也忽略html注释，甚至不将它们视为标记分隔符。&lt;/p&gt;&#xA;&lt;p&gt;我计算每个标记（目前忽略大小写）在每个语料库中出现的次数。在这个阶段，我最终得到两个大的哈希表，每个语料库一个，将标记映射到出现次数。&lt;/p&gt;&#xA;&lt;p&gt;接下来我创建第三个哈希表，这次将每个标记映射到包含它的电子邮件是垃圾邮件的概率，我计算如下[1]：(let ((g (* 2 (or (gethash word good) 0))) (b (or (gethash word bad) 0))) (unless (&amp;lt; (+ g b) 5) (max .01 (min .99 (float (/ (min 1 (/ b nbad)) (+ (min 1 (/ g ngood)) (min 1 (/ b nbad))))))))) 其中word是我们计算其概率的标记，good和bad是我在第一步创建的哈希表，ngood和nbad分别是非垃圾邮件和垃圾邮件的数量。&lt;/p&gt;&#xA;&lt;p&gt;我将此解释为代码以显示几个重要细节。我想稍微偏向概率以避免误报，通过反复试验，我发现一个好的方法是将good中的所有数字加倍。这有助于区分偶尔确实出现在合法邮件中的词和几乎从不出现的词。我只考虑总共出现超过五次的词（实际上，由于加倍，在非垃圾邮件中出现三次就足够了）。然后是关于给在一个语料库中出现但不在另一个语料库中出现的词分配什么概率的问题。同样通过反复试验，我选择了.01和.99。这里可能还有调整的空间，但随着语料库的增长，这种调整无论如何都会自动发生。&lt;/p&gt;&#xA;&lt;p&gt;特别细心的人会注意到，虽然为了计算出现次数的目的我将每个语料库视为一个长文本流，但在计算垃圾邮件概率时，我使用每个语料库中的邮件数量，而不是它们的组合长度作为除数。这增加了另一个轻微的偏向以防止误报。&lt;/p&gt;&#xA;&lt;p&gt;当新邮件到达时，它被扫描成标记，最有趣的十五个标记，其中有趣度是通过它们的垃圾邮件概率与中性的.5相差多远来衡量的，被用来计算邮件是垃圾邮件的概率。如果probs是十五个单独概率的列表，你这样计算组合概率：(let ((prod (apply #&amp;rsquo;* probs))) (/ prod (+ prod (apply #&amp;rsquo;* (mapcar #&amp;rsquo;(lambda (x) (- 1 x)) probs))))) 实践中出现的一个问题是给你从未见过的词分配什么概率，即没有出现在词概率哈希表中的词。我再次通过反复试验发现，.4是一个好数字。如果你以前从未见过一个词，它可能是相当无辜的；垃圾邮件词往往太熟悉了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于Web应用的Lisp</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/lwba/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/lwba/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/lwba/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/lwba.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/lwba.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/lwba.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;基于web应用的lisp&#34;&gt;基于Web应用的Lisp&lt;/h1&gt;&#xA;&lt;p&gt;在《击败平均值》的链接被发布在slashdot上之后，一些读者希望更详细地了解我们在Viaweb中使用Lisp获得的具体技术优势。对于那些感兴趣的人，以下是我2001年4月在剑桥BBN实验室的演讲节选。&lt;/p&gt;&#xA;&lt;p&gt;BBN演讲节选（ASCII）&lt;/p&gt;</description>
    </item>
    <item>
      <title>大学本科</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/college/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/college/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/college/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/college.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/college.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/college.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;大学本科&#34;&gt;大学本科&lt;/h1&gt;&#xA;&lt;p&gt;想要创业吗？获得Y Combinator的资助。2005年3月&lt;/p&gt;&#xA;&lt;p&gt;（本文的部分内容始于对给我写信提问的学生的回复。）&lt;/p&gt;&#xA;&lt;p&gt;最近我收到了几封计算机科学本科生的邮件，询问在大学应该做什么。我可能不是最好的建议来源，因为我在大学主修的是哲学。但我上了很多计算机科学的课程，以至于大多数计算机科学专业的学生都以为我是其中一员。我当然是个黑客，至少如此。&lt;/p&gt;&#xA;&lt;h2 id=&#34;黑客技术&#34;&gt;黑客技术&lt;/h2&gt;&#xA;&lt;p&gt;在大学里应该做什么才能成为一个优秀的黑客？你可以做两件主要的事情：在编程方面变得非常出色，并学习很多关于特定、酷炫问题的知识。这两件事被证明是等价的，因为每一件都会推动你去做另一件。&lt;/p&gt;&#xA;&lt;p&gt;在编程方面变得出色的方法是（a）大量地（b）解决难题。而让你自己解决难题的方法是从事一些非常引人入胜的项目。这个项目很可能不是课堂作业。我的朋友罗伯特在本科时通过编写网络软件学到了很多。他的一个项目是将哈佛连接到阿帕网；它曾经是最初的节点之一，但到1984年连接已经断开了。这项工作不仅不是为了课堂，而且因为他把所有时间都花在上面而忽视了学业，他被学校开除了一年。最终一切都平衡了，现在他是麻省理工学院的教授。但如果你不走那个极端，你可能会更快乐；这当时给他带来了很多担忧。&lt;/p&gt;&#xA;&lt;p&gt;在编程方面变得出色的另一种方法是找到其他擅长编程的人，学习他们的知识。程序员倾向于根据他们做的工作类型和他们使用的工具将自己分成部落，有些部落比其他部落更聪明。看看你周围，看看聪明的人似乎在做什么；通常都有原因。&lt;/p&gt;&#xA;&lt;p&gt;你周围一些最聪明的人是教授。所以找到有趣工作的一个方法是自愿担任研究助理。教授对那些能为他们解决繁琐的系统管理类型问题的人特别感兴趣，所以这是进门的一种方式。他们害怕的是那些不可靠和为了简历而工作的人。助理往往导致工作量净增加，这太常见了。所以你必须明确你会带来净减少。&lt;/p&gt;&#xA;&lt;p&gt;如果他们说不要，不要气馁。拒绝几乎总是比被拒绝者想象的要少个人色彩。继续下一个。（这也适用于约会。）&lt;/p&gt;&#xA;&lt;p&gt;小心，因为虽然大多数教授都很聪明，但并不是所有人都从事有趣的工作。教授必须发表新颖的结果才能推进他们的职业生涯，但在更有趣的研究领域竞争更激烈。所以那些不那么有抱负的教授所做的是发表一系列论文，这些论文的结论之所以新颖，是因为没有其他人关心它们。你最好避免这些。&lt;/p&gt;&#xA;&lt;p&gt;我从来没有当过研究助理，所以推荐那条路线我觉得有点不诚实。我通过写自己的东西学会了编程，特别是通过尝试逆向工程Winograd的SHRDLU。我对那个程序的痴迷就像母亲对新生婴儿一样。&lt;/p&gt;&#xA;&lt;p&gt;无论独自工作有什么缺点，优点是这个项目完全是你自己的。你永远不必妥协或询问任何人的许可，如果你有新的想法，你可以坐下来开始实现它。&lt;/p&gt;&#xA;&lt;p&gt;在你自己的项目中，你不必担心新颖性（像教授那样）或盈利能力（像企业那样）。唯一重要的是项目在技术上的难度，这与应用的性质没有相关性。像数据库这样的&amp;quot;严肃&amp;quot;应用在技术上往往是琐碎和枯燥的（如果你曾遭受失眠之苦，试试阅读关于数据库的技术文献），而像游戏这样的&amp;quot;琐碎&amp;quot;应用往往非常复杂。我确信有一些游戏公司正在开发的产品，其智力内容比大学计算机科学系底部十分之九的研究还要多。&lt;/p&gt;&#xA;&lt;p&gt;如果我现在在大学，我可能会从事图形学工作：例如，一个网络游戏，或者一个3D动画工具。当我是本科生时，没有足够的周期让图形学变得有趣，但现在很难想象有什么更有趣的工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数学&#34;&gt;数学&lt;/h2&gt;&#xA;&lt;p&gt;当我在大学时，很多教授相信（或至少希望）计算机科学是数学的一个分支。这种想法在哈佛最强烈，那里直到1980年代甚至没有计算机科学专业；在此之前，人们必须主修应用数学。但在康奈尔大学也几乎一样糟糕。当我告诉可怕的康威教授我对人工智能感兴趣（那时是个热门话题）时，他告诉我应该主修数学。我仍然不确定他认为人工智能需要数学，还是他认为人工智能是无稽之谈，主修一些严谨的学科会治愈我这种愚蠢的抱负。&lt;/p&gt;&#xA;&lt;p&gt;事实上，作为黑客，你需要的数学比大多数大学系愿意承认的要少得多。我认为你需要的除了高中数学加上计算理论的一些概念外，不需要太多。如果你想避免编写n²算法，你必须知道什么是n²算法。当然，除非你计划编写数学应用。例如，机器人技术全是数学。&lt;/p&gt;&#xA;&lt;p&gt;虽然对于大多数类型的黑客技术，你从字面上不需要数学，在知道1001个微分公式技巧的意义上，数学本身非常值得学习。它几乎是任何类型工作的宝贵隐喻来源。出于这个原因，我希望我在大学时学了更多数学。&lt;/p&gt;&#xA;&lt;p&gt;像许多人一样，我在童年时被数学虐待过。我学会将数学视为公式的集合，这些公式既不美丽，与我的生活也没有任何关系（尽管试图将它们翻译成&amp;quot;文字问题&amp;quot;），但必须记住以便在考试中取得好成绩。&lt;/p&gt;&#xA;&lt;p&gt;你在大学能做的最有价值的事情之一可能是了解数学的真正含义。这可能不容易，因为许多优秀的数学家都是糟糕的老师。虽然有许多关于数学的通俗书籍，但似乎很少有好的。我能想到的最好的是W.W.索耶的。当然还有欧几里得。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一切&#34;&gt;一切&lt;/h2&gt;&#xA;&lt;p&gt;托马斯·赫胥黎说&amp;quot;尝试了解一切的一些事情和一件事的一切。&amp;ldquo;大多数大学都以这个理想为目标。&lt;/p&gt;&#xA;&lt;p&gt;但什么是&amp;quot;一切&amp;rdquo;？对我来说，它意味着人们在诚实解决难题的过程中学到的一切。所有这样的工作往往是相关的，因为一个领域的想法和技术通常可以成功移植到其他领域。即使是那些看起来相当遥远的领域。例如，我写文章的方式和写软件的方式一样：我坐下来尽可能快地敲出一个蹩脚的版本1，然后花几周时间重写它。&lt;/p&gt;&#xA;&lt;p&gt;解决难题本身并不足够。中世纪的炼金术士在解决一个难题，但他们的方法是如此虚假，以至于研究它几乎学不到什么，除了可能关于人们欺骗自己的能力。不幸的是，我在大学尝试学习的那种人工智能有同样的缺陷：一个非常困难的问题，轻率地使用完全不足的技术来解决。大胆？更接近欺诈。社会科学也相当虚假，因为它们受到知识时尚的太大影响。如果一个物理学家遇到100年前的同事，他可以教他一些新东西；如果一个心理学家遇到100年前的同事，他们只会陷入意识形态争论。是的，当然，通过上心理学课你会学到一些东西。重点是，通过上另一个系的课，你会学到更多。&lt;/p&gt;&#xA;&lt;p&gt;在我看来，值得学习的系是数学、硬科学、工程、历史（特别是经济和社会历史，以及科学史）、建筑学和古典文学。艺术史概论课程可能是值得的。现代文学很重要，但了解它的方法就是阅读。我对音乐了解不够，无法发表意见。&lt;/p&gt;&#xA;&lt;p&gt;你可以跳过社会科学、哲学和最近为应对政治压力而创建的各个系。这些领域当然谈论重要问题。但它们谈论问题的方式是无用的。例如，哲学谈论我们对彼此的义务等；但你可以从一位明智的祖母或E.B.怀特那里学到更多关于这方面的知识，而不是从一位学术哲学家。&lt;/p&gt;&#xA;&lt;p&gt;我在这里是从经验出发说话。当人们嘲笑克林顿说&amp;quot;这取决于&amp;rsquo;是&amp;rsquo;这个词的含义是什么&amp;quot;时，我可能应该感到被冒犯。我在大学上了大约五门关于&amp;quot;是&amp;quot;这个词的含义的课。&lt;/p&gt;&#xA;&lt;p&gt;找出哪些领域值得学习的另一种方法是创建辍学图表。例如，我知道许多人从数学转向计算机科学，因为他们发现数学太难了，没有人做相反的事情。人们不会无缘无故地做困难的事情；除非一个问题相应地（或至少log(n)）更有回报，否则没有人会去解决更难的问题。所以可能数学比计算机科学更值得学习。通过类似的比较，你可以为大学中的所有系制作一个图表。在底部你会发现智力内容最少的科目。&lt;/p&gt;&#xA;&lt;p&gt;如果你使用这种方法，你会得到与我刚才给出的大致相同的答案。&lt;/p&gt;&#xA;&lt;p&gt;语言课程是一个异常。我认为它们更好地被视为课外活动，就像陶艺课程一样。当结合在讲这种语言的国家生活一段时间时，它们会更有用。我一时兴起在大一时学习了阿拉伯语。这是很多工作，唯一持久的好处是一种奇怪的能力来识别闪米特语词根，以及对人们如何识别单词的一些见解。&lt;/p&gt;&#xA;&lt;p&gt;工作室艺术和创意写作课程是变数。通常你不会被教太多：你只是在老师模糊的监督下做（或不做）你想做的任何事情，然后坐在一起为彼此的创作提供&amp;quot;批评&amp;quot;。但写作和艺术都是人们诚实解决的非常困难的问题，所以它们值得做，特别是如果你能找到一位好老师。&lt;/p&gt;&#xA;&lt;h2 id=&#34;工作&#34;&gt;工作&lt;/h2&gt;&#xA;&lt;p&gt;当然，大学生必须考虑的不仅仅是学习。还有两个实际问题需要考虑：工作和研究生院。&lt;/p&gt;&#xA;&lt;p&gt;理论上，通识教育不应该提供职业培训。但每个人都知道这有点谎言。每所大学的黑客都学习实用技能，而且不是偶然的。&lt;/p&gt;&#xA;&lt;p&gt;为找工作而学习的内容取决于你想要的工作类型。如果你想在大公司工作，学习如何在Windows上编写Blub程序。如果你想在一家酷的小公司或研究实验室工作，学习在Linux上使用Ruby会更好。如果你想创办自己的公司，我认为这会越来越普遍，掌握你能找到的最强大的工具，因为你将要与竞争对手比赛，他们将是你的马。&lt;/p&gt;&#xA;&lt;p&gt;你应该在大学学习的技能和工作中使用的技能之间没有直接的相关性。在大学里你应该目标稍微高一些。&lt;/p&gt;&#xA;&lt;p&gt;在锻炼中，足球运动员可能卧推300磅，尽管在比赛过程中他可能永远不必施加类似的力量。同样，如果你的教授试图让你学习比工作中需要的更先进的东西，可能不仅仅是因为他们是学者，脱离现实世界。他们可能在试图用你的大脑举重。&lt;/p&gt;&#xA;&lt;p&gt;你在课堂上写的程序与你将在现实世界中写的程序在三个关键方面不同：它们很小；你可以从头开始；问题通常是人为的和预定的。在现实世界中，程序更大，往往涉及现有代码，通常需要你在解决问题之前弄清楚问题是什么。&lt;/p&gt;&#xA;&lt;p&gt;你不必等到离开（甚至进入）大学才学习这些技能。例如，如果你想学习如何处理现有代码，你可以为开源项目做贡献。你想要为之工作的雇主会对此印象深刻，就像课堂作业的好成绩一样。&lt;/p&gt;&#xA;&lt;p&gt;在现有的开源项目中，你在第三种技能上没有太多练习，即决定要解决什么问题。但没有什么能阻止你开始自己的新项目。好雇主会对这更印象深刻。&lt;/p&gt;&#xA;&lt;p&gt;你应该尝试解决什么类型的问题？回答这个问题的一种方法是询问你作为用户需要什么。例如，我偶然发现了一个很好的垃圾邮件过滤算法，因为我想停止接收垃圾邮件。现在我希望我有一个邮件阅读器，能以某种方式防止我的收件箱填满。我倾向于使用我的收件箱作为待办事项列表。但这就像用螺丝刀开瓶子；人们真正想要的是一个开瓶器。&lt;/p&gt;&#xA;&lt;h2 id=&#34;研究生院&#34;&gt;研究生院&lt;/h2&gt;&#xA;&lt;p&gt;研究生院怎么样？你应该去吗？你如何进入一所好的研究生院？&lt;/p&gt;&#xA;&lt;p&gt;原则上，研究生院是研究的专业培训，除非你想把研究作为职业，否则你不应该去。然而，获得计算机科学博士学位的人中有一半没有进入研究界。我去研究生院不是为了成为教授。我去是因为我想学到更多。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你主要对黑客技术感兴趣并且你去研究生院，你会发现很多其他人在同样地不在他们的元素中。如果你周围有一半的人以同样的方式不在他们的元素中，你真的不在你的元素中吗？&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;计算机科学&amp;quot;中有一个根本问题，在这种情况下就显现出来了。没有人确定&amp;quot;研究&amp;quot;应该是什么。很多研究是黑客技术，不得不被塞进学术论文的形式以产生又一个出版量。&lt;/p&gt;&#xA;&lt;p&gt;所以问你是否会在研究生院如鱼得水有点误导性，因为很少有人真正在计算机科学中如鱼得水。整个领域在自己的皮肤中感到不舒服。所以你主要对黑客技术感兴趣这一事实不应该阻止你去研究生院。只是要警告你，你将不得不做很多你不喜欢的事情。&lt;/p&gt;&#xA;&lt;p&gt;第一将是你的论文。几乎每个人在完成时都讨厌他们的论文。这个过程往往会产生令人不快的结果，就像用全麦面粉制作并烘烤十二小时的蛋糕。很少有论文是被愉快地阅读的，尤其是它们的作者。&lt;/p&gt;&#xA;&lt;p&gt;但在你之前有成千上万的人忍受了写论文的痛苦。除此之外，研究生院接近天堂。许多人记得这是他们一生中最快乐的时光。几乎所有其余的人，包括我，记得如果他们不必写论文，这本来会是一段美好的时期。&lt;/p&gt;&#xA;&lt;p&gt;研究生院的危险在于你 upfront 看不到可怕的部分。博士计划开始作为大学第2部分，有几年的课程。所以当你面对写论文的恐怖时，你已经进入几年了。如果你现在退出，你将成为研究生院辍学生，你可能不会喜欢这个想法。当罗伯特因为编写1988年的互联网蠕虫而被研究生院开除时，我非常羡慕他找到了一种没有失败耻辱的退出方式。&lt;/p&gt;&#xA;&lt;p&gt;总体而言，研究生院可能比大多数选择更好。你会遇到很多聪明人，你忧郁的拖延至少会是一个强大的共同纽带。当然，最后你有一个博士学位。我忘记了那一点。我想那是值得的。&lt;/p&gt;&#xA;&lt;p&gt;博士学位的最大优势（当然，除了是学术界的工会卡）可能是它给你一些基线信心。例如，我家的霍尼韦尔恒温器有着最糟糕的用户界面。我的母亲有相同的型号，勤奋地花了一天时间阅读用户手册来学习如何操作它。她认为问题出在她身上。但我可以对自己说&amp;quot;如果拥有计算机科学博士学位的人都无法理解这个恒温器，那它一定是设计得很糟糕。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;在这个不温不火的推荐之后，如果你仍然想去研究生院，我可以给你关于如何进入的可靠建议。我的很多朋友现在是计算机科学教授，所以我有关于招生的内幕。这与大学完全不同。在大多数大学，招生官员决定谁被录取。对于博士计划，教授决定。他们努力做好这件事，因为他们录取的人将要为他们工作。&lt;/p&gt;&#xA;&lt;p&gt;显然，在最好的学校，只有推荐信真正重要。标准化测试毫无价值，成绩也很少价值。文章主要是通过说愚蠢的话来取消自己资格的机会。教授唯一信任的是推荐信，最好来自他们认识的人。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你想进入博士计划，关键是给教授留下印象。从我当教授的朋友那里，我知道什么给他们留下印象：不仅仅是试图给他们留下印象。他们对取得好成绩的学生或想成为他们的研究助理以便进入研究生院的学生不感兴趣。他们对取得好成绩并且想成为他们的研究助理的学生印象深刻，因为他们真正对这个话题感兴趣。&lt;/p&gt;&#xA;&lt;p&gt;所以你在大学能做的最好的事情，无论你想进入研究生院还是只想擅长黑客技术，是找出你真正喜欢的东西。很难欺骗教授让你进入研究生院，也不可能欺骗问题让你解决它们。大学是伪装停止工作的地方。从这一点开始，除非你想去大公司工作，这就像回到高中，前进的唯一方法是通过做你喜欢的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;&#xA;&lt;p&gt;[1] 似乎没有人介意，这表明阿帕网（后来成为互联网）在1984年是多么不重要。&lt;/p&gt;&#xA;&lt;p&gt;[2] 这就是为什么当我成为雇主时，我不关心GPA。事实上，我们积极寻找从学校辍学的人。我们曾经在哈佛周围张贴海报说&amp;quot;你是否因为把所有时间花在某个自己的项目上而在课堂上表现不佳而被踢出学校？来为我们工作吧！&amp;ldquo;我们设法找到了一个这样的人，他是个优秀的黑客。&lt;/p&gt;&#xA;&lt;p&gt;当哈佛将本科生开除一年时，他们必须找工作。想法是向他们展示现实世界是多么糟糕，这样他们会明白他们在大学里是多么幸运。这个计划在我们来找工作的那个家伙身上适得其反，因为他比在学校时更有趣，那年从股票期权中赚的钱比他任何教授的薪水都多。所以他没有在年底悔改地爬回来，而是又请了一年假去了欧洲。他最终大约在26岁毕业。&lt;/p&gt;</description>
    </item>
    <item>
      <title>将程序装在脑中</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/head/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/head/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/head/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/head.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/head.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/head.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;将程序装在脑中&#34;&gt;将程序装在脑中&lt;/h1&gt;&#xA;&lt;p&gt;2007年8月&lt;/p&gt;&#xA;&lt;p&gt;一个优秀的程序员密集地工作在他自己的代码上时，可以像数学家把持一个他在解决的问题那样把持它。数学家不像学校教的那样在纸上工作来回答问题。他们在脑子里做得更多：他们试图充分理解问题空间，能够像漫步在你成长房屋的记忆中那样漫步其中。在最佳状态下，编程也是如此。你把整个程序装在脑中，你可以随意操纵它。&lt;/p&gt;&#xA;&lt;p&gt;这在项目开始时特别有价值，因为最初最重要的是能够改变你正在做的事情。不仅仅是以不同的方式解决问题，而是改变你正在解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;你的代码是你对你正在探索的问题的理解。所以只有当你把代码装在脑中时，你才真正理解这个问题。&lt;/p&gt;&#xA;&lt;p&gt;把程序装进脑中并不容易。如果你离开一个项目几个月，当你回到它时，可能需要几天才能真正再次理解它。即使你在积极地处理一个程序，每天开始工作时也需要半小时才能把它装进脑中。这是最好的情况。在典型办公条件下工作的普通程序员永远不会进入这种模式。或者更戏剧性地说，在典型办公条件下工作的普通程序员永远不会真正理解他们正在解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;即使是最优秀的程序员并不总是把他们正在处理的整个程序都装在脑中。但你可以做一些事情来帮助：&lt;/p&gt;&#xA;&lt;h2 id=&#34;避免干扰&#34;&gt;避免干扰。&lt;/h2&gt;&#xA;&lt;p&gt;干扰对许多类型的工作都是有害的，但对编程尤其有害，因为程序员倾向于在他们能处理的细节极限上运作。&lt;/p&gt;&#xA;&lt;p&gt;干扰的危险不在于它持续多久，而在于它使你的大脑混乱的程度。程序员可以离开办公室去吃个三明治而不会失去脑中的代码。但错误的干扰可以在30秒内抹去你的大脑。&lt;/p&gt;&#xA;&lt;p&gt;奇怪的是，有计划的干扰可能比没有计划的干扰更糟。如果你知道一小时后有个会议，你甚至不会开始处理困难的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;长时间工作&#34;&gt;长时间工作。&lt;/h2&gt;&#xA;&lt;p&gt;因为每次开始处理一个程序都有固定成本，所以在几个长时段中工作比在许多短时段中工作更有效率。当然，总会有一个点，因为你累了而变得愚蠢。这因人而异。我听说过人们连续36小时编程，但我能管理的最多只有18小时左右，而且我在不超过12小时的块中工作效果最好。&lt;/p&gt;&#xA;&lt;p&gt;最佳状态不是你身体能忍受的极限。分解项目既有优势也有成本。有时当你在休息后回到问题时，你会发现你的潜意识留下了答案等着你。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用简洁的语言&#34;&gt;使用简洁的语言。&lt;/h2&gt;&#xA;&lt;p&gt;更强大的编程语言使程序更短。程序员似乎至少部分地用他们用来编写程序的语言来思考程序。语言越简洁，程序越短，就越容易装进脑中并保持在那里。&lt;/p&gt;&#xA;&lt;p&gt;你可以通过使用一种称为自底向上编程的风格来增强强大语言的效果，在这种风格中，你编写多层程序，较低的层作为其上层的编程语言。如果你正确地这样做，你只需要把最顶层装在脑中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;不断重写你的程序&#34;&gt;不断重写你的程序。&lt;/h2&gt;&#xA;&lt;p&gt;重写程序通常会得到更清晰的设计。但即使不会，它也有优势：你必须完全理解一个程序才能重写它，所以没有更好的方法把它装进脑中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;写可重读的代码&#34;&gt;写可重读的代码。&lt;/h2&gt;&#xA;&lt;p&gt;所有程序员都知道写可读代码是好的。但你自己是最重要的读者。特别是在开始时；原型是与自己的对话。当为自己写作时，你有不同的优先事项。如果为别人写作，你可能不想让代码太密集。程序的某些部分可能最容易读，如果你把东西摊开，像一本入门教科书。而如果你写代码是为了让它容易重新装进脑中，最好追求简洁。&lt;/p&gt;&#xA;&lt;h2 id=&#34;小组工作&#34;&gt;小组工作。&lt;/h2&gt;&#xA;&lt;p&gt;当你在脑中操纵一个程序时，你的视野倾向于停在你拥有的代码边缘。其他部分你理解得不够好，更重要的是，不能随意处理。所以程序员数量越少，项目就能越完全地变异。如果只有一个程序员，通常开始时是这样，你可以做全面重新设计。&lt;/p&gt;&#xA;&lt;h2 id=&#34;不要让多个人编辑同一段代码&#34;&gt;不要让多个人编辑同一段代码。&lt;/h2&gt;&#xA;&lt;p&gt;你永远不会像理解自己的代码那样理解别人的代码。无论你多么彻底地读过它，你只是读了它，而不是写了它。所以如果一段代码由多个作者编写，他们中没有人像单个作者那样理解它。&lt;/p&gt;&#xA;&lt;p&gt;当然你不能安全地重新设计别人正在处理的东西。不仅仅是你必须请求许可。你甚至不让自己考虑这样的事情。重新设计有几个作者的代码就像改变法律；重新设计你独自控制的代码就像看到模糊图像的另一种解释。&lt;/p&gt;&#xA;&lt;p&gt;如果你想让几个人在一个项目上工作，把它分成组件，每个给一个人。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从小开始&#34;&gt;从小开始。&lt;/h2&gt;&#xA;&lt;p&gt;随着你对程序越来越熟悉，它变得更容易装在脑中。一旦你确信你已经完全探索了某些部分，你就可以开始把它们当作黑盒处理。但当你开始处理一个项目时，你被迫看到一切。如果你开始的问题太大，你可能永远无法完全把握它。所以如果你需要写一个大的、复杂的程序，开始的最佳方式可能不是为它写规范，而是写一个解决子集问题的原型。无论计划有什么优势，它们往往被能够把程序装在脑中的优势所抵消。&lt;/p&gt;&#xA;&lt;p&gt;程序员们经常偶然做到这八点，这很引人注目。有人有了一个新项目的想法，但因为不是正式批准的，他必须在下班时间做——结果证明更有生产力，因为没有干扰。受到他对新项目的热情驱使，他连续工作许多小时。因为它最初只是一个实验，他使用的是&amp;quot;脚本&amp;quot;语言而不是&amp;quot;生产&amp;quot;语言——实际上它强大得多。他完全重写程序几次；这对正式项目是不合理的，但这是爱的劳动，他想要它完美。而且因为除了他没有人会看到它，他省略了除笔记类型外的任何注释。他被迫在小团队中工作，因为他要么还没有告诉任何人这个想法，要么它看起来如此无望以至于不允许其他人在其上工作。即使有一个团队，他们也不能让多个人编辑同一段代码，因为它变化太快，那是不可能的。项目从小开始是因为想法一开始很小；他只是有一些很酷的黑客技巧想试试。&lt;/p&gt;&#xA;&lt;p&gt;更引人注目的是有多少正式批准的项目设法把这八件事都做错了。事实上，如果你看看大多数组织中软件编写的方式，几乎就像他们在故意做错事情。在某种意义上，他们确实如此。自从有组织以来，其定义性品质之一就是把个人当作可互换的部件。这对更可并行化的任务很有效，比如打仗。在历史上大部分时间里，一支训练有素的专业士兵军队可以指望打败一群个人战士，无论多么勇敢。但拥有想法不是很可并行化的。而程序就是：想法。&lt;/p&gt;&#xA;&lt;p&gt;组织不喜欢依赖个人天才的想法不仅仅是真的，它是同义反复。不这样做是组织定义的一部分。至少是我们当前组织概念的一部分。&lt;/p&gt;&#xA;&lt;p&gt;也许我们可以定义一种新型的组织，结合个人的努力而不要求他们可互换。可以说市场就是这种形式的组织，尽管把市场描述为退化情况可能更准确——当组织不可能时默认得到的情况。&lt;/p&gt;&#xA;&lt;p&gt;可能我们能做到的最好的是某种hack，比如让一个组织的编程部分以不同于其他部分的方式工作。也许最佳解决方案是大公司甚至不尝试内部开发想法，而只是购买它们。但无论解决方案是什么，第一步是意识到存在问题。&amp;ldquo;软件公司&amp;quot;这个短语本身就有矛盾。这两个词在相反的方向上拉扯。任何大型组织中的优秀程序员都会与之冲突，因为组织的设计是为了防止程序员追求的目标。&lt;/p&gt;&#xA;&lt;p&gt;优秀的程序员无论如何都能完成很多事情。但这往往需要对雇佣他们的组织进行实际上反抗的行为。如果更多的人理解程序员的行为方式是由他们工作的需求驱动的，这可能会有所帮助。他们长时间工作，期间推掉所有其他义务，直接投入编程而不是先写规范，重写已经工作的代码，这不是因为他们不负责任。他们更喜欢独自工作，或者对探头说你好的人咆哮，这不是因为他们不友好。这个表面上随机的令人讨厌习惯集合有一个单一的解释：将程序装在脑中的力量。&lt;/p&gt;&#xA;&lt;p&gt;无论理解这一点是否能帮助大型组织，它肯定能帮助他们的竞争对手。大公司的最弱点是他们不让个别程序员做出伟大的工作。所以如果你是一个小创业公司，这是攻击他们的地方。接手那些必须在一个大脑中解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;感谢Sam Altman、David Greenspan、Aaron Iba、Jessica Livingston、Robert Morris、Peter Norvig、Lisa Randall、Emmett Shear、Sergei Tsarev和Stephen Wolfram阅读本文的草稿。&lt;/p&gt;</description>
    </item>
    <item>
      <title>我所从事的工作</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/worked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/worked/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/worked/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/worked.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/worked.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/worked.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;我所从事的工作&#34;&gt;我所从事的工作&lt;/h1&gt;&#xA;&lt;p&gt;2021年2月&lt;/p&gt;&#xA;&lt;p&gt;大学前，我在课外主要从事的两件事是写作和编程。我不写文章。我写的是当时初学写作的人应该写的东西，可能现在还是：短篇小说。我的故事很糟糕。几乎没有情节，只有感情强烈的角色，我以为这让他们显得深刻。&lt;/p&gt;&#xA;&lt;p&gt;我尝试编写的第一个程序是在我们学区用于当时称为&amp;quot;数据处理&amp;quot;的IBM 1401上。那时我在九年级，所以是13或14岁。学区的1401恰好在我们的初中的地下室，我的朋友Rich Draves和我获得了使用它的许可。那里就像一个小型的邦德反派巢穴，所有这些看起来外星般的机器——CPU、磁盘驱动器、打印机、卡片阅读器——坐在明亮的荧光灯下的抬高地板上。&lt;/p&gt;&#xA;&lt;p&gt;我们使用的语言是Fortran的早期版本。你必须在打孔卡上键入程序，然后将它们堆叠在卡片阅读器中并按下按钮将程序加载到内存中并运行。结果通常是在极其响亮的打印机上打印一些东西。&lt;/p&gt;&#xA;&lt;p&gt;我对1401感到困惑。我无法弄清楚如何使用它。回想起来，我能用它做的事情不多。程序的唯一输入形式是存储在打孔卡上的数据，而我没有任何存储在打孔卡上的数据。唯一的选择是做不依赖任何输入的事情，比如计算π的近似值，但我的数学知识不足以做任何有趣的这类事情。所以我不奇怪我不记得我编写的任何程序，因为它们不可能做太多事情。我最清晰的记忆是我了解到程序可能不会终止的那一刻，当我的一个程序没有终止时。在没有分时系统的机器上，这既是社会错误也是技术错误，正如数据中心经理的表情所表明的那样。&lt;/p&gt;&#xA;&lt;p&gt;有了微型计算机，一切都改变了。现在你可以有一台电脑就坐在你面前，在桌子上，它可以在运行时响应你的按键，而不仅仅是处理一堆打孔卡然后停止。[1]&lt;/p&gt;&#xA;&lt;p&gt;我的朋友中第一个拥有微型计算机的人是自己组装的。它是由Heathkit作为套件出售的。我生动地记得看着它坐在它前面，直接在电脑中键入程序时我感到多么印象深刻和羡慕。&lt;/p&gt;&#xA;&lt;p&gt;那时候计算机很昂贵，我纠缠了多年才说服我父亲在1980年左右买了一台TRS-80。当时黄金标准是Apple II，但TRS-80已经足够好了。这是我真正开始编程的时候。我编写了简单的游戏，一个预测我的模型火箭能飞多高的程序，以及我的父亲用来写至少一本书的文字处理器。内存中只有大约2页文本的空间，所以他一次写2页然后打印出来，但这比打字机好多了。&lt;/p&gt;&#xA;&lt;p&gt;虽然我喜欢编程，但我没打算在大学里学习它。在大学里我要学习哲学，这听起来强大得多。对于我天真的高中自我来说，这似乎是对终极真理的研究，相比之下其他领域研究的东西将只是领域知识。当我到达大学时，我发现其他领域占据了思想空间的很大部分，这些所谓的终极真理没有太多空间留下来。哲学似乎只剩下其他领域的人认为可以安全忽略的边缘情况。&lt;/p&gt;&#xA;&lt;p&gt;我18岁时无法把这些变成语言。我当时只知道我不断选修哲学课程，而它们总是很无聊。所以我决定转向AI。&lt;/p&gt;&#xA;&lt;p&gt;AI在1980年代中期很流行，但有两件事特别让我想要从事它：海因莱因的一部名为《月亮是一个严厉的女人》的小说，其中有一个名为Mike的智能计算机，以及一个展示Terry Winograd使用SHRDLU的PBS纪录片。我没有尝试重读《月亮是一个严厉的女人》，所以我不知道它老化得如何，但当我读它时，我完全被它的世界吸引住了。似乎只是时间问题，我们就会有Mike，当我看到Winograd使用SHRDLU时，似乎那时间将是几年。你所要做的就是教SHRDLU更多的词语。&lt;/p&gt;&#xA;&lt;p&gt;那时康奈尔大学没有任何AI课程，甚至研究生课程也没有，所以我开始尝试自学。这意味着学习Lisp，因为在那些日子Lisp被认为是AI的语言。当时常用的编程语言相当原始，程序员的想法也相应地如此。康奈尔的默认语言是一种类似Pascal的语言，称为PL/I，其他地方的情况也类似。学习Lisp如此迅速地扩展了我对程序的概念，以至于我花了几年时间才开始感觉到新的限制在哪里。这更像它；这是我对大学期望的。它没有像应该的那样在课堂上发生，但没关系。接下来的几年我很顺利。我知道我要做什么。&lt;/p&gt;&#xA;&lt;p&gt;对于我的本科论文，我逆向工程了SHRDLU。天啊，我多么喜欢在这个程序上工作。这是一段令人愉悦的代码，但更令人兴奋的是我的信念——现在很难想象，但在1985年并不独特——它已经在攀登智能的较低坡度。&lt;/p&gt;&#xA;&lt;p&gt;我进入了康奈尔的一个不要求你选择专业的项目。你可以选修任何你喜欢的课程，选择任何你喜欢放在学位上的东西。我当然选择了&amp;quot;人工智能&amp;quot;。当我拿到实际的物理文凭时，我惊恐地发现引号被包括在内，这使它们读作引号。当时这困扰着我，但现在看来可笑地准确，原因我即将发现。&lt;/p&gt;&#xA;&lt;p&gt;我申请了3所研究生院：MIT和耶鲁，当时以AI闻名，以及哈佛，我访问过因为Rich Draves去那里，也是Bill Woods的故乡，他发明了我在我的SHRDLU克隆中使用的解析器类型。只有哈佛接受了我，所以我就去了那里。&lt;/p&gt;&#xA;&lt;p&gt;我不记得那一刻是什么时候发生的，或者甚至是否有特定的时刻，但在研究生第一年期间，我意识到AI，当时实践的方式，是一个骗局。我的意思是那种AI，其中被告知&amp;quot;狗坐在椅子上&amp;quot;的程序将其转换为某种正式表示并将其添加到它知道的事情列表中。&lt;/p&gt;&#xA;&lt;p&gt;这些程序真正显示的是，自然语言的一个子集是一种形式语言。但是一个非常适当的子集。很明显，他们能做的事情和真正理解自然语言之间有一个不可逾越的鸿沟。事实上，这不仅仅是教SHRDLU更多词语的问题。整个AI方式，用代表概念的显式数据结构，是行不通的。它的 brokenness 确实，像经常发生的那样，产生了大量机会来写关于可以应用的各种创可贴的论文，但它永远不会给我们带来Mike。&lt;/p&gt;&#xA;&lt;p&gt;所以我环顾四周，看看我能从计划的残骸中挽救什么，那就是Lisp。我从经验中知道Lisp本身就很有趣，不仅仅是因为它与AI的联系，尽管那时这是人们关心它的主要原因。所以我决定专注于Lisp。事实上，我决定写一本关于Lisp黑客技术的书。想到我开始写那本书时对Lisp黑客技术了解得多么少，真是令人害怕。但是没有什么比写一本关于某件事的书更能帮助你学习它了。这本书，《On Lisp》，直到1993年才出版，但我在研究生院写了大部分。&lt;/p&gt;&#xA;&lt;p&gt;计算机科学是两个部分之间不安的联盟：理论和系统。理论家证明事情，系统家建造事情。我想建造事情。我对理论有很大的尊重——确实，一种偷偷摸摸的怀疑，认为它是两个部分中更令人钦佩的——但建造事情似乎令人兴奋得多。&lt;/p&gt;&#xA;&lt;p&gt;然而，系统工作的问题在于它不持久。你今天编写的任何程序，无论多好，最多几十年后就会过时。人们可能在脚注中提到你的软件，但没有人会实际使用它。而且，它会显得非常无力的工作。只有对领域历史有了解的人才会意识到，在它的时代，它曾经是好的。&lt;/p&gt;&#xA;&lt;p&gt;有一次，计算机实验室里有一些多余的施乐Dandelions。任何想要一个来玩的人都可以有一个。我短暂地被诱惑了，但按照现在的标准它们太慢了；有什么意义呢？也没有其他人想要一个，所以它们被运走了。这就是系统工作的下场。&lt;/p&gt;&#xA;&lt;p&gt;我不仅要建造事情，还要建造会持久的事情。&lt;/p&gt;&#xA;&lt;p&gt;在这种不满的状态下，我在1988年去CMU拜访Rich Draves，他在那里读研究生。有一天我去参观卡内基研究所，我小时候在那里花了很多时间。在那里看一幅画时，我意识到一些可能看起来显而易见的事情，但对我来说是一个巨大的惊喜。在那里，就在墙上，是一些你可以制造的东西，它会持久。绘画不会过时。一些最好的已经有几百年历史了。&lt;/p&gt;&#xA;&lt;p&gt;而且这是你可以谋生的事情。当然不像写软件那么容易，但我认为如果你真正勤奋且生活非常节俭，必须有可能赚足够的钱生存。作为艺术家，你可以真正独立。你不会有老板，甚至不需要获得研究经费。&lt;/p&gt;&#xA;&lt;p&gt;我一直喜欢看画。我能画画吗？我不知道。我从未想象过这是可能的。我在理智上知道人们制造艺术——它不是自发出现的——但制造它的人似乎是不同的物种。他们要么生活在很久以前，要么是在《生活》杂志的简介中做奇怪事情的神秘天才。实际上能够制造艺术，把这个动词放在这个名词前面，似乎几乎是奇迹性的。&lt;/p&gt;&#xA;&lt;p&gt;那年秋天我开始在哈佛选修艺术课程。研究生可以在任何系选修课程，我的导师Tom Cheatham非常随和。即使他知道我选修的奇怪课程，他也什么都没说。&lt;/p&gt;&#xA;&lt;p&gt;所以现在我在计算机科学博士项目中，却计划成为艺术家，却又真正热爱Lisp黑客技术和努力编写《On Lisp》。换句话说，像许多研究生一样，我精力充沛地从事多个不是我的论文的项目。&lt;/p&gt;&#xA;&lt;p&gt;我没有看到摆脱这种局面的方法。我不想退学，但我还能怎么出去呢？我记得当我的朋友Robert Morris因编写1988年互联网蠕虫而被康奈尔开除时，我羡慕他找到了如此壮观的方式来离开研究生院。&lt;/p&gt;&#xA;&lt;p&gt;然后在1990年4月的一天，墙上出现了一道裂缝。我遇到了Cheatham教授，他问我是否已经足够进展可以在那年六月毕业。我的论文一个字都没有写，但一定是我一生中最快的思考，我决定在剩下的5周左右的时间内尝试写一篇，尽可能重用《On Lisp》的部分，我能够毫无察觉地延迟回答&amp;quot;是的，我想是的。我几天内给你一些东西阅读。&amp;quot;&lt;/p&gt;&#xA;&lt;p&gt;我选择了continuations的应用作为主题。回想起来我应该写关于宏和嵌入式语言。那里有一个几乎未被探索的整个世界。但我只想离开研究生院，我快速写的论文足够了，勉强而已。&lt;/p&gt;&#xA;&lt;p&gt;与此同时，我在申请艺术学院。我申请了两所：美国的RISD，和佛罗伦萨的Accademia di Belli Arti，因为它是最古老的艺术学校，我想象它会很好。RISD接受了我，而我从未收到Accademia的回音，所以我去了普罗维登斯。&lt;/p&gt;&#xA;&lt;p&gt;我申请了RISD的BFA项目，这实际上意味着我必须再次上大学。这听起来不像那么奇怪，因为我只有25岁，艺术学校里充满了不同年龄的人。RISD把我算作转学大二学生，说我必须那年夏天做基础课程。基础课程是每个人都必须参加的基础科目课程，如绘画、色彩和设计。&lt;/p&gt;&#xA;&lt;p&gt;在夏末，我得到了一个大惊喜：一封来自Accademia的信，被延迟了因为他们把它寄到了剑桥英格兰而不是剑桥马萨诸塞州，邀请我那年秋天在佛罗伦萨参加入学考试。现在只有几周时间了。我善良的女房东让我把我的东西留在她的阁楼里。我有一些从研究生院咨询工作中节省的钱；如果我生活节俭，可能足够一年。现在我必须做的就是学习意大利语。&lt;/p&gt;&#xA;&lt;p&gt;只有stranieri（外国人）必须参加这个入学考试。回想起来，这很可能是排除他们的一种方式，因为有那么多stranieri被在佛罗伦萨学习艺术的想法吸引，否则意大利学生会被数量超过。那年夏天从RISD基础课程来看，我在绘画和素描方面处于不错的状态，但我仍然不知道我是如何通过书面考试的。我记得我通过写关于塞尚来回答散文问题，并且我把智力水平提高到尽可能高，以充分利用我有限的词汇量。[2]&lt;/p&gt;&#xA;&lt;p&gt;我只到25岁，已经有如此明显的模式。我又一次即将进入一些庄严的机构，希望学习一些有声望的科目，又一次即将失望。Accademia绘画系的学生和教员是你能想象到的最友好的人，但他们早就达成了一个安排，学生不会要求教员教任何东西，反过来教员也不会要求学生学习任何东西。同时，所有相关者都会在外表上坚持19世纪画室的惯例。我们确实有一个那些小火炉中的一个，用引火柴喂养，你在19世纪画室绘画中看到的那种，一个裸体模特坐在尽可能靠近而不被烧伤的地方。除了我，几乎没有人画她。其余的学生把时间花在聊天上，或者偶尔尝试模仿他们在美国艺术杂志中看到的东西。&lt;/p&gt;&#xA;&lt;p&gt;我们的模特原来就住在我家楼下街。她通过模特工作和为当地古董商制作赝品来谋生。她会从书中复制一个模糊的旧绘画，然后他会拿走副本并虐待它使其看起来旧。[3]&lt;/p&gt;&#xA;&lt;p&gt;当我在Accademia当学生时，我开始在晚上在我的卧室里画静物画。这些画作很小，因为房间很小，因为我把它们画在剩余的画布碎料上，那是我当时唯一能负担得起的。画静物画不同于画人，因为主体，顾名思义，不能移动。人们一次只能坐大约15分钟，当他们坐下时也不会坐得很稳。所以画人的传统方式是知道如何画一个通用的人，然后你修改它以匹配你正在画的特定人。而静物画，如果你愿意，可以从你看到的东西像素级复制。你当然不想停在那里，否则你只得到摄影准确性，而使静物画有趣的是它经过了一个头脑。你想强调视觉线索，告诉你，例如，颜色在某个点突然变化的原因是它是一个物体的边缘。通过微妙地强调这样的事情，你可以使绘画比照片更现实，不仅仅是在某种隐喻意义上，而是在严格的信息理论意义上。[4]&lt;/p&gt;&#xA;&lt;p&gt;我喜欢画静物画是因为我对看到的东西好奇。在日常生活中，我们没有意识地意识到我们看到的很多东西。大多数视觉感知是由低级过程处理的，它们只告诉你的大脑&amp;quot;那是水滴&amp;quot;而不告诉你像最亮和最暗点在哪里这样的细节，或者&amp;quot;那是灌木&amp;quot;而不告诉你每片叶子的形状和位置。这是大脑的一个特征，而不是bug。在日常生活中，注意到每片灌木上的每片叶子会让人分心。但当你必须画什么东西时，你必须更仔细地看，当你这样做时，有很多可看的。在尝试画人们通常视为理所当然的东西几天后，你可能仍在注意到新事情，就像尝试写关于人们通常视为理所当然的东西的文章几天后一样。&lt;/p&gt;&#xA;&lt;p&gt;这不是唯一的绘画方式。我不是100%确定它甚至是画画的不错方式。但这似乎是一个足够好的赌注，值得尝试。&lt;/p&gt;&#xA;&lt;p&gt;我们的老师Ulivi教授是个好人。他看到我努力工作，给了我一个好成绩，他写在每个学生都有的某种护照上。但Accademia除了意大利语外没有教我任何东西，而我的钱快用完了，所以在第一年结束时我回到了美国。&lt;/p&gt;&#xA;&lt;p&gt;我想回到RISD，但我现在破产了而RISD非常昂贵，所以我决定找一年的工作然后在下个秋天回到RISD。我在一家叫做Interleaf的公司找到了一份工作，它制作用于创建文档的软件。你的意思是像微软Word？完全正确。这就是我学到低端软件往往吃掉高端软件的方式。但Interleaf还有几年的寿命。[5]&lt;/p&gt;&#xA;&lt;p&gt;Interleaf做了相当大胆的事情。受Emacs启发，他们添加了一种脚本语言，甚至使脚本语言成为Lisp的一种方言。现在他们想要一个Lisp黑客来用它写东西。这是我最接近正常工作的事情，我在此向我的老板和同事道歉，因为我是一个糟糕的员工。他们的Lisp是巨大C蛋糕上的最薄糖衣，因为我不知道C也不想学习它，我从未理解大部分软件。而且我非常不负责任。那时候编程工作意味着在某些工作时间内每天出现。这对我来说似乎不自然，而在这一点上世界其他地区正在转向我的思维方式，但当时造成了很多摩擦。在一年结束时，我花了很多时间秘密地研究《On Lisp》，那时我已经获得了出版合同。&lt;/p&gt;&#xA;&lt;p&gt;好的部分是我得到了巨额金钱，特别是按艺术学生标准。在佛罗伦萨，支付我的房租部分后，我其他一切的预算是每天7美元。现在我每小时得到的报酬比那多4倍以上，即使我只是坐在会议上。通过节俭生活，我不仅设法节省了足够的钱回到RISD，还还清了我的大学贷款。&lt;/p&gt;&#xA;&lt;p&gt;我在Interleaf学到了一些有用的东西，尽管它们主要是关于不该做什么的。我学到技术公司最好由产品人而不是销售人运营（尽管销售是真正的技能，擅长它的人真的很擅长），当代码被太多人编辑时会导致bug，如果办公室空间令人沮丧那么便宜的办公室空间不是 bargain，计划会议不如走廊对话，大的官僚客户是危险的资金来源，以及常规办公时间和黑客的最佳时间，或常规办公室和最佳地点之间没有太多重叠。&lt;/p&gt;&#xA;&lt;p&gt;但我学到的最重要的东西，也是我在Viaweb和Y Combinator中使用的东西，是低端吃掉高端：成为&amp;quot;入门级&amp;quot;选项是好的，即使那会不那么有声望，因为如果你不是，别人会是，并且会把你压在天花板上。这反过来意味着声望是一个危险信号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>拖累盲区</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/schlep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/schlep/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/schlep/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/schlep.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/schlep.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/schlep.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;拖累盲区&#34;&gt;拖累盲区&lt;/h1&gt;&#xA;&lt;p&gt;2012年1月&lt;/p&gt;&#xA;&lt;p&gt;伟大的创业想法就在我们眼皮底下未被利用。我们看不到它们的一个原因是我称之为拖累盲区的现象。Schlep最初是一个意第绪语单词，但已经在美国通用。它意味着一项繁琐、不愉快的任务。&lt;/p&gt;&#xA;&lt;p&gt;没有人喜欢拖累，但黑客尤其不喜欢它们。大多数开始创业的黑客希望他们能够只写一些聪明的软件，把它放在某个服务器上，看着钱滚滚而来——而不必与用户交谈，或与其他公司谈判，或处理其他人的破损代码。也许这是可能的，但我还没有看到。&lt;/p&gt;&#xA;&lt;p&gt;我们在Y Combinator做的许多事情之一是教导黑客们拖累的不可避免性。不，你不能只通过写代码来创业。我记得我自己经历了这种认识。在1995年的某个时刻，我仍然试图说服自己我可以只通过写代码来创业。但我很快从经验中学到，拖累不仅是不可避免的，而且基本上就是商业的组成部分。&lt;/p&gt;&#xA;&lt;p&gt;一个公司是由它愿意承担的拖累来定义的。拖累应该像对待冷水游泳池一样处理：直接跳进去。这并不是说你应该刻意寻求不愉快的工作，而是说你永远不应该回避它，如果它在通往伟大事物的道路上。&lt;/p&gt;&#xA;&lt;p&gt;我们对拖累的厌恶最危险的部分是其中大部分是无意识的。你的无意识甚至不会让你看到涉及痛苦拖累的想法。这就是拖累盲区。&lt;/p&gt;&#xA;&lt;p&gt;这种现象不仅仅限于创业。大多数人不会有意识地决定不拥有与奥林匹克运动员一样好的身体状况。例如，他们的无意识为他们做决定，回避所涉及的工作。&lt;/p&gt;&#xA;&lt;p&gt;我所知道的拖累盲区最突出的例子是Stripe，或者更确切地说是Stripe的想法。十多年来，每个曾经不得不在线处理付款的黑客都知道这个体验有多痛苦。成千上万的人一定知道这个问题。然而当他们开始创业时，他们决定建立食谱网站，或者本地活动聚合器。为什么？为什么在你可以修复世界上最重要基础设施之一的组件时，要从事很少有人关心也没有人会为之付钱的问题？因为拖累盲区阻止人们甚至考虑修复付款的想法。&lt;/p&gt;&#xA;&lt;p&gt;可能没有人申请Y Combinator做食谱网站项目时首先问&amp;quot;我们应该修复付款，还是建立食谱网站？&amp;ldquo;然后选择了食谱网站。虽然修复付款的想法就在明面上，但他们从未看到它，因为他们的无意识回避所涉及的复杂性。你将不得不与银行达成协议。你怎么做到的？而且你在转移资金，所以你将不得不处理欺诈，以及试图闯入你服务器的人。而且可能还有各种法规需要遵守。开始像这样的创业公司比开始食谱网站创业公司要令人畏惧得多。&lt;/p&gt;&#xA;&lt;p&gt;这种可怕性使得雄心勃勃的想法具有双重价值。除了它们的内在价值之外，它们就像被低估的股票，因为在创始人中对它们的需求较少。如果你选择一个雄心勃勃的想法，你将有更少的竞争，因为其他人都会被所涉及的挑战吓倒。（这对于创业一般也是正确的。）&lt;/p&gt;&#xA;&lt;p&gt;你如何克服拖累盲区？坦率地说，对拖累盲区最有价值的解药可能是无知。大多数成功的创始人可能会说，如果他们在开始创业时知道他们必须克服的障碍，他们可能永远不会开始。也许这就是为什么最成功的创业公司经常有年轻创始人的原因之一。&lt;/p&gt;&#xA;&lt;p&gt;在实践中，创始人与问题一起成长。但似乎没有人能够预见到这一点，即使是更年长、更有经验的创始人。所以年轻创始人有优势的原因是他们犯两个错误，这些错误相互抵消。他们不知道他们能成长多少，但他们也不知道他们需要成长多少。年长的创始人只犯第一个错误。&lt;/p&gt;&#xA;&lt;p&gt;无知不能解决所有问题。有些想法如此明显地涉及令人担忧的拖累，任何人都能看到它们。你如何看到这样的想法？我推荐的技巧是自己退出画面。不要问&amp;quot;我应该解决什么问题？&amp;ldquo;而是问&amp;quot;我希望别人为我解决什么问题？&amp;ldquo;如果在Stripe之前有人不得不处理付款的人尝试问这个问题，Stripe会是他们首先希望的事情之一。&lt;/p&gt;&#xA;&lt;p&gt;现在成为Stripe已经太晚了，但世界上仍然有很多破损的东西，如果你知道如何看到它。&lt;/p&gt;&#xA;&lt;p&gt;感谢萨姆·奥特曼、保罗·布赫海特、帕特里克·克里森、亚伦·伊巴、杰西卡·利文斯顿、埃米特·谢尔和哈吉·塔加阅读本文的草稿。&lt;/p&gt;</description>
    </item>
    <item>
      <title>欢迎来到Lisp</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/acl2txtt1748944359/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/acl2txtt1748944359/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/acl2txtt1748944359/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;欢迎来到lisp&#34;&gt;欢迎来到Lisp&lt;/h1&gt;&#xA;&lt;p&gt;本章旨在让你尽快开始编程。到本章结束时，你将了解足够的Common Lisp知识来开始编写程序。&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-形式&#34;&gt;2.1 形式&lt;/h2&gt;&#xA;&lt;p&gt;对于Lisp来说尤其如此，你通过使用它来学习它，因为Lisp是一种交互式语言。任何Lisp系统都包含一个称为toplevel的交互式前端。你将Lisp表达式输入到toplevel中，系统会显示它们的值。Lisp通常会显示一个提示符来告诉你它在等待你输入内容。许多Common Lisp实现使用&amp;gt;作为toplevel提示符。这就是我们在这里要使用的。&lt;/p&gt;&#xA;&lt;p&gt;最简单的Lisp表达式之一是整数。如果我们在提示符后输入1，&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;系统将打印它的值，然后是另一个提示符，表示它准备好接受更多输入。在这种情况下，显示的值与我们输入的相同。像1这样的数字被称为求值为自身。&lt;/p&gt;&#xA;&lt;p&gt;当我们输入需要一些工作来求值的表达式时，生活变得更加有趣。例如，如果我们想要将两个数字相加，我们输入类似这样的内容：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+ 2 3)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在表达式(+ 2 3)中，+被称为运算符，数字2和3被称为参数。在日常生活中，我们会将这个表达式写为2 + 3，但在Lisp中，我们将+运算符放在前面，后面跟着参数，整个表达式用一对括号括起来：(+ 2 3)。这被称为前缀表示法，因为运算符在前。&lt;/p&gt;&#xA;&lt;p&gt;这种写表达式的方式起初可能看起来很奇怪，但实际上这种表示法是Lisp最棒的特点之一。例如，如果我们想要将三个数字相加，在普通表示法中我们必须使用+两次，2 + 3 + 4，而在Lisp中我们只需添加另一个参数：(+ 2 3 4)&lt;/p&gt;&#xA;&lt;p&gt;我们通常使用+的方式是，它必须恰好有两个参数：一个在左边，一个在右边。前缀表示法的灵活性意味着，在Lisp中，+可以接受任意数量的参数，包括无参数：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+ 2)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+ 2 3)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;5&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+ 2 3 4)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;9&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (+ 2 3 4 5)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;14&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为运算符可以接受不同数量的参数，我们需要括号来表示表达式的开始和结束。表达式可以嵌套。也就是说，表达式中的参数本身可能是复杂的表达式：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; (/ (- 7 1) (- 4 2))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用英语来说，这是七减一，除以四减二。&lt;/p&gt;</description>
    </item>
    <item>
      <title>简洁即力量</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/power/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/power/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/power/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/power.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/power.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/power.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;简洁即力量&#34;&gt;简洁即力量&lt;/h1&gt;&#xA;&lt;p&gt;2002年5月&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;通过代数符号将大量意义压缩到一个小空间中，这是另一个有助于我们习惯性推理的因素。&amp;rdquo; - 查尔斯·巴贝奇，引自艾弗森的图灵奖演讲&lt;/p&gt;&#xA;&lt;p&gt;在LL1邮件列表上关于《书呆子的复仇》所提出问题的讨论中，保罗·普雷斯科德写了一些让我印象深刻的话。Python的目标是规范性和可读性，而不是简洁性。表面上看来，这对编程语言来说似乎是一个相当不利的评价。据我所知，简洁性=力量。如果是这样，那么替换后我们得到Python的目标是规范性和可读性，而不是力量。这似乎不是一个你想要做出的权衡（如果这确实是一个权衡的话）。这几乎等同于说Python的目标不是作为一种有效的编程语言。&lt;/p&gt;&#xA;&lt;p&gt;简洁性等于力量吗？在我看来，这是一个重要的问题，可能是对任何对语言设计感兴趣的人来说最重要的问题，直接面对这个问题会很有用。我还不确定答案是否是简单的&amp;quot;是&amp;quot;，但这似乎是一个很好的开始假设。&lt;/p&gt;&#xA;&lt;h2 id=&#34;假设&#34;&gt;假设&lt;/h2&gt;&#xA;&lt;p&gt;我的假设是简洁性就是力量，或者足够接近，除了在病态的例子中，你可以将它们视为相同。&lt;/p&gt;&#xA;&lt;p&gt;在我看来，简洁性就是编程语言的意义所在。计算机对于直接用机器语言被告知要做什么同样满意。我认为我们开发高级语言的主要原因是获得杠杆作用，这样我们就可以用高级语言的10行代码来表达（更重要的是思考）需要1000行机器语言才能完成的事情。换句话说，高级语言的主要目的是使源代码更小。&lt;/p&gt;&#xA;&lt;p&gt;如果更小的源代码是高级语言的目的，而某种东西的力量是它实现其目的的程度，那么编程语言力量的衡量标准就是它使你的程序变得多小。&lt;/p&gt;&#xA;&lt;p&gt;相反，不能使你的程序更小的语言在编程语言应该做的事情上做得不好，就像一把不好切的刀或难以辨认的印刷品。&lt;/p&gt;&#xA;&lt;h2 id=&#34;衡量标准&#34;&gt;衡量标准&lt;/h2&gt;&#xA;&lt;p&gt;但是从什么意义上来说更小呢？代码大小最常见的衡量标准是代码行数。但我认为这个衡量标准最常见是因为它最容易测量。我不认为有人真正相信它是程序长度的真正测试。不同的语言对于在一行中放多少内容有不同的约定；在C语言中，很多行只有一个或两个分隔符。&lt;/p&gt;&#xA;&lt;p&gt;另一个简单的测试是程序中的字符数，但这也不是很好；一些语言（例如Perl）只是使用比其他语言更短的标识符。&lt;/p&gt;&#xA;&lt;p&gt;我认为程序大小的更好衡量标准是元素的数量，其中元素是如果你画一个表示源代码的树，会成为不同节点的任何东西。变量或函数的名称是一个元素；整数或浮点数是一个元素；一段字面文本是一个元素；模式元素或格式指令是一个元素；新块是一个元素。有一些边界情况（-5是两个元素还是一个？）但我认为大多数情况对每种语言都是相同的，所以它们不会对比较产生太大影响。&lt;/p&gt;&#xA;&lt;p&gt;这个衡量标准需要充实，在特定语言的情况下可能需要解释，但我认为它试图衡量正确的东西，即程序拥有的部分数量。我认为在这个练习中你会画的树就是你为了构思程序而必须在头脑中构建的东西，它的大小与你必须做的工作量成正比，无论是写还是读。&lt;/p&gt;&#xA;&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;&#xA;&lt;p&gt;这种衡量标准可以让我们比较不同的语言，但至少对我而言，这不是它的主要价值。简洁性测试的主要价值是作为设计语言的指导。语言之间最有用的比较是同一种语言的两个潜在变体之间的比较。我能在语言中做什么来使程序更短？&lt;/p&gt;&#xA;&lt;p&gt;如果程序的概念负荷与其复杂性成正比，而给定的程序员可以容忍固定的概念负荷，那么这与问&amp;quot;我能做什么来让程序员完成最多工作？&amp;ldquo;是相同的。这在我看来与问&amp;quot;我如何设计一种好的语言？&amp;ldquo;是相同的。&lt;/p&gt;&#xA;&lt;p&gt;（顺便说一句，没有什么比设计语言更能明显地证明&amp;quot;所有语言都是等价的&amp;quot;这个老生常谈是错误的了。当你设计一种新语言时，你不断地比较两种语言——如果我做了x的语言，如果我没做x的语言——来决定哪个更好。如果这真是一个无意义的问题，你不妨抛硬币。）&lt;/p&gt;&#xA;&lt;p&gt;以简洁性为目标似乎是寻找新想法的好方法。如果你能做一些让许多不同程序更短的事情，这可能不是巧合：你可能发现了一个有用的新抽象。你甚至可以编写一个程序来帮助搜索源代码中的重复模式。在其他语言中，那些以简洁性著称的语言是寻找新想法的地方：Forth、Joy、Icon。&lt;/p&gt;&#xA;&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;&#xA;&lt;p&gt;据我所知，第一个写这些相关文章的人是弗雷德·布鲁克斯在《人月神话》中。他写道，无论使用什么语言，程序员每天似乎生成大致相同数量的代码。我在二十出头第一次读到这个时，这是一个很大的惊喜，似乎有巨大的含义。这意味着（a）让软件写得更快的方法是使用更简洁的语言，（b）花功夫这样做的人可以把不这样做的竞争对手远远甩在后面。&lt;/p&gt;&#xA;&lt;p&gt;布鲁克斯的假设，如果它是真的，似乎处于黑客精神的核心。从那以后的几年里，我密切关注我能得到的关于这个问题的任何证据，从正式研究到个人项目的轶事。我没有看到任何与他相矛盾的证据。&lt;/p&gt;&#xA;&lt;p&gt;我还没有看到我认为决定性的证据，我也不期望看到。像卢茨·普雷克特尔对编程语言的比较这样的研究，虽然产生了我期望的那种结果，但往往使用太短的问题，无法成为有意义的测试。语言的更好测试是在需要一个月编写的程序中发生什么。而真正的测试，如果你像我一样相信语言的主要目的是为了便于思考（而不仅仅是在你思考完后告诉计算机要做什么），是你能用它写出什么新东西。所以任何需要满足预定义规范的语言比较都在测试稍微错误的东西。&lt;/p&gt;&#xA;&lt;p&gt;语言的真正测试是你发现和解决新问题的能力，而不是你用它解决别人已经制定的问题的能力。这是两个完全不同的标准。在艺术中，像刺绣和马赛克这样的媒介，如果你事先知道你想制作什么，效果很好，但如果你不知道，就绝对糟糕。当你想在制作过程中发现图像时——就像你必须处理像人物图像这样复杂的东西一样——你需要使用更流动的媒介，如铅笔、水墨或油画。实际上，挂毯和马赛克的制作方式是先制作一幅画，然后复制它。（&amp;ldquo;卡通&amp;quot;这个词最初用来描述用于这个目的的画。）&lt;/p&gt;&#xA;&lt;p&gt;这意味着我们永远不可能对编程语言的相对力量有准确的比较。我们会有精确的比较，但不会有准确的比较。特别是，为了比较语言而进行的明确研究，因为它们可能会使用小问题，并且必须使用预定义的问题，往往会低估更强大语言的力量。&lt;/p&gt;&#xA;&lt;p&gt;来自现场的报告，虽然它们必然不如&amp;quot;科学&amp;quot;研究精确，但可能更有意义。例如，爱立信的乌尔夫·维格进行了一项研究，结论是Erlang比C++简洁4-10倍，开发软件的速度也相应更快：爱立信内部开发项目之间的比较表明，包括软件开发的所有阶段在内的每行/小时生产力相似，几乎与使用的语言（Erlang、PLEX、C、C++或Java）无关。区分不同语言的成为源代码量。该研究还明确处理了布鲁克斯书中只是隐含的一点（因为他测量的是调试代码的行数）：用更强大语言编写的程序往往有更少的错误。这本身就成为一个目的，在网络交换机等应用中，可能比程序员的生产力更重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;味道测试&#34;&gt;味道测试&lt;/h2&gt;&#xA;&lt;p&gt;最终，我认为你必须凭直觉行事。用这种语言编程感觉如何？我认为找到（或设计）最好语言的方法是对语言让你思考的出色程度变得高度敏感，然后选择/设计感觉最好的语言。如果某些语言功能笨拙或限制性，别担心，你会知道的。&lt;/p&gt;&#xA;&lt;p&gt;这种高度敏感是有代价的。你会发现你无法忍受在笨拙的语言中编程。我觉得在没有宏的语言中编程是无法忍受的限制性，就像习惯动态类型的人发现必须回到必须声明每个变量类型、不能制作不同类型对象列表的语言中编程是无法忍受的限制性一样。我不是唯一一个这样的人。我知道许多Lisp黑客都经历过这种情况。事实上，编程语言相对力量的最准确衡量标准可能是了解该语言的人愿意接受任何使用该语言的工作的百分比，不管应用领域如何。&lt;/p&gt;&#xA;&lt;h2 id=&#34;限制性&#34;&gt;限制性&lt;/h2&gt;&#xA;&lt;p&gt;我认为大多数黑客都知道语言感觉限制性是什么意思。当你有这种感觉时发生了什么？我认为这与当你想走的街道被封锁，你必须绕很长的路才能到达你想去的地方时的感觉相同。你有想说的话，但语言不允许你说。&lt;/p&gt;&#xA;&lt;p&gt;这里真正发生的事情，我认为，是限制性语言是一种不够简洁的语言。问题不仅仅是你不能说你计划说的话。而是语言让你绕的弯路更长。试试这个思维实验。假设你想写某个程序，语言不允许你按计划的方式表达它，而是强迫你用某种更短的方式写程序。至少对我来说，这不会感觉很有限制性。这就像你想走的街道被封锁，十字路口的警察给你指了一条捷径而不是绕路。太好了！&lt;/p&gt;&#xA;&lt;p&gt;我认为限制性的感觉大部分（百分之九十？）来自于被迫使你在语言中写的程序比你头脑中的更长。限制性主要是缺乏简洁性。所以当一种语言感觉有限制性时，这（大部分）意味着它不够简洁，而当一种语言不够简洁时，它会感觉有限制性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;可读性&#34;&gt;可读性&lt;/h2&gt;&#xA;&lt;p&gt;我开始引用的引言提到了另外两个品质，规范性和可读性。我不确定性规范性是什么，或者规范和可读的代码比仅仅可读的代码有什么优势，如果有的话。但我想我知道可读性是什么意思，我认为它也与简洁性有关。&lt;/p&gt;&#xA;&lt;p&gt;我们必须小心区分单行代码的可读性和整个程序的可读性。重要的是后者。我同意Basic的一行代码可能比Lisp的一行代码更易读。但用Basic编写的程序行数会比用Lisp编写的相同程序多（特别是当你进入格林斯彭之地时）。阅读Basic程序的总工作量肯定会更大。总工作量 = 每行工作量 × 行数&lt;/p&gt;&#xA;&lt;p&gt;我不像确信力量与简洁性成正比那样确信可读性与简洁性成正比，但简洁性肯定是可读性的一个因素（在数学意义上；见上面的公式）。所以，说语言的目标是可读性而不是简洁性可能甚至没有意义；这就像说目标是可读性，而不是可读性。&lt;/p&gt;&#xA;&lt;p&gt;每行可读性对第一次遇到语言的用户来说，意味着源代码看起来不具威胁性。所以每行可读性可能是一个好的营销决策，即使它是一个糟糕的设计决策。它与让人们分期付款的非常成功的技术同构：不是用高昂的前期价格吓唬他们，而是告诉他们低月付款。分期付款对买方来说是净亏损，而每行可读性对程序员来说可能也是如此。买方将进行很多很多低月付款；而程序员将阅读很多很多单独可读的行。&lt;/p&gt;&#xA;&lt;p&gt;这种权衡比编程语言更早。如果你习惯于阅读小说和报纸文章，你第一次阅读数学论文的经历可能会令人沮丧。阅读一页可能需要半小时。然而，我很确定符号不是问题，尽管感觉上可能是。数学论文难读是因为思想难。如果你用散文表达相同的思想（正如数学家在发展出简洁的符号之前必须做的那样），它们不会更容易读，因为论文会增长到一本书的大小。&lt;/p&gt;&#xA;&lt;h2 id=&#34;到什么程度&#34;&gt;到什么程度？&lt;/h2&gt;&#xA;&lt;p&gt;许多人拒绝了简洁性=力量的想法。我认为与其简单地争论它们相同或不同，不如问：简洁性在多大程度上等于力量？因为很明显，简洁性是高级语言重要目的的大部分。如果不是全部，那么它们还有什么其他目的，相对而言，这些其他功能有多重要？&lt;/p&gt;&#xA;&lt;p&gt;我提出这个不仅仅是为了让辩论更加文明。我真的想知道答案。如果有的话，语言什么时候会因为过于简洁而对自己不利？&lt;/p&gt;&#xA;&lt;p&gt;我开始的假设是，除了在病态的例子中，我认为简洁性可以被视为等同于力量。我的意思是，在任何任何人会设计的语言中，它们都是相同的，但如果有人想要设计一种语言来明确反驳这个假设，他们可能能够做到。实际上，我甚至不确定这一点。&lt;/p&gt;&#xA;&lt;h2 id=&#34;语言而不是程序&#34;&gt;语言，而不是程序&lt;/h2&gt;&#xA;&lt;p&gt;我们应该清楚我们讨论的是语言的简洁性，而不是单个程序的简洁性。单个程序当然可能写得太密集。&lt;/p&gt;&#xA;&lt;p&gt;我在《On Lisp》中写过这个。一个复杂的宏可能需要节省自身长度的许多倍才能证明其合理性。如果编写某个复杂的宏每次使用都能为你节省十行代码，而宏本身是十行代码，那么如果你使用超过一次，你就会在行数上获得净节省。但这可能仍然是一个坏举动，因为宏定义比普通代码更难读。你可能需要使用宏十次或二十次才能在可读性上获得净改善。&lt;/p&gt;&#xA;&lt;p&gt;我确信每种语言都有这样的权衡（虽然我怀疑随着语言变得更强大，赌注会更高）。每个程序员肯定都见过一些聪明人使用可疑的编程技巧使代码略微缩短的例子。&lt;/p&gt;&#xA;&lt;p&gt;所以对此没有争论——至少，不是我争论。单个程序当然可能因为过于简洁而对自己不利。问题是，语言会吗？语言能强迫程序员编写在元素上很短但以整体可读性为代价的代码吗？&lt;/p&gt;&#xA;&lt;p&gt;很难想象语言过于简洁的一个原因是，如果有一些过于紧凑的方式来表达某些东西，可能也会有更长的表达方式。例如，如果你觉得使用大量宏或高阶函数的Lisp程序太密集，如果你愿意，你可以编写与Pascal同构的代码。如果你不想在Arc中将对高阶函数的调用表示为阶乘（rec zero 1 * 1-），你也可以写出递归定义：(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))&lt;/p&gt;</description>
    </item>
    <item>
      <title>编程语言修复了什么</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/fix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/fix/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/fix/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/fix.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/fix.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/fix.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;编程语言修复了什么&#34;&gt;编程语言修复了什么&lt;/h1&gt;&#xA;&lt;p&gt;凯文·凯勒her建议了一种比较编程语言的有趣方式：用每种语言所要解决的问题来描述它。令人惊讶的是，有多少语言可以用这种方式很好地描述。&lt;/p&gt;&#xA;&lt;p&gt;Algol：汇编语言太底层了。&lt;/p&gt;&#xA;&lt;p&gt;Pascal：Algol没有足够的数据类型。&lt;/p&gt;&#xA;&lt;p&gt;Modula：Pascal对于系统编程来说太弱了。&lt;/p&gt;&#xA;&lt;p&gt;Simula：Algol在模拟方面不够好。&lt;/p&gt;&#xA;&lt;p&gt;Smalltalk：Simula中的一切都不是对象。&lt;/p&gt;&#xA;&lt;p&gt;Fortran：汇编语言太底层了。&lt;/p&gt;&#xA;&lt;p&gt;Cobol：Fortran太吓人了。&lt;/p&gt;&#xA;&lt;p&gt;PL/1：Fortran没有足够的数据类型。&lt;/p&gt;&#xA;&lt;p&gt;Ada：每种现有语言都缺少某些东西。&lt;/p&gt;&#xA;&lt;p&gt;Basic：Fortran太吓人了。&lt;/p&gt;&#xA;&lt;p&gt;APL：Fortran在操作数组方面不够好。&lt;/p&gt;&#xA;&lt;p&gt;J：APL需要自己的字符集。&lt;/p&gt;&#xA;&lt;p&gt;C：汇编语言太底层了。&lt;/p&gt;&#xA;&lt;p&gt;C++：C太底层了。&lt;/p&gt;&#xA;&lt;p&gt;Java：C++是一个混乱的东西。而且微软要打压我们。&lt;/p&gt;&#xA;&lt;p&gt;C#：Java被Sun控制着。&lt;/p&gt;&#xA;&lt;p&gt;Lisp：图灵机是描述计算的笨拙方式。&lt;/p&gt;&#xA;&lt;p&gt;Scheme：MacLisp是一个混乱的东西。&lt;/p&gt;&#xA;&lt;p&gt;T：Scheme没有库。&lt;/p&gt;&#xA;&lt;p&gt;Common Lisp：Lisp有太多方言。&lt;/p&gt;&#xA;&lt;p&gt;Dylan：Scheme没有库，而且Lisp语法太吓人了。&lt;/p&gt;&#xA;&lt;p&gt;Perl：Shell脚本/awk/sed不够像编程语言。&lt;/p&gt;&#xA;&lt;p&gt;Python：Perl是一个混乱的东西。&lt;/p&gt;&#xA;&lt;p&gt;Ruby：Perl是一个混乱的东西，而且Lisp语法太吓人了。&lt;/p&gt;&#xA;&lt;p&gt;Prolog：编程不够像逻辑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>让另外95%的优秀程序员进来</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/95/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/95/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/95.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/95.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/95.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;让另外95的优秀程序员进来&#34;&gt;让另外95%的优秀程序员进来&lt;/h1&gt;&#xA;&lt;p&gt;让另外95%的优秀程序员进来 2014年12月&lt;/p&gt;&#xA;&lt;p&gt;美国科技公司希望政府让移民更容易，因为它们说在美国找不到足够的程序员。反移民人士说，与其让外国人占据这些工作，我们应该培训更多的美国人成为程序员。谁是对的？&lt;/p&gt;&#xA;&lt;p&gt;科技公司是对的。反移民人士不理解的是，合格的程序员和杰出的程序员之间在能力上存在巨大差异，虽然你可以培训人们成为合格的程序员，但你无法培训他们成为杰出的程序员。杰出的程序员对编程有天生的才能和兴趣，这不仅仅是培训的产物。[1]&lt;/p&gt;&#xA;&lt;p&gt;美国占世界人口不到5%。这意味着如果使某人成为优秀程序员的特质是均匀分布的，那么95%的优秀程序员都出生在美国以外。&lt;/p&gt;&#xA;&lt;p&gt;反移民人士必须编造一些解释来说明科技公司为使移民更容易而付出的所有努力。所以他们声称这是因为它们想压低工资。但如果你与创业公司交谈，你会发现几乎所有达到一定规模的公司都经历了法律上的周折来让程序员进入美国，在那里他们支付给这些程序员的工资与支付给美国人的相同。为什么他们要为以相同价格获得程序员而额外费心？唯一的解释是他们在说实话：根本没有足够多的优秀程序员可供分配。[2]&lt;/p&gt;&#xA;&lt;p&gt;我问了一家拥有约70名程序员的创业公司的CEO，如果他能获得所有他想要的优秀程序员，他会再雇佣多少。他说&amp;quot;明天早上我们就会雇佣30名。&amp;ldquo;而这是一家总是在招聘战中获胜的热门创业公司。整个硅谷都是如此。创业公司在人才方面如此受限。&lt;/p&gt;&#xA;&lt;p&gt;如果更多的美国人接受编程培训那将是很好的，但没有任何培训能够改变95比5这样压倒性的比例。特别是由于其他国家也在培训程序员。除非发生灾难，否则大多数优秀程序员都出生在美国以外这一事实将永远成立。大多数在任何方面优秀的人都出生在美国以外这一事实也将永远成立。[3]&lt;/p&gt;&#xA;&lt;p&gt;卓越的表现意味着移民。一个只占世界人口百分之几的国家只有在某个领域有大量移民工作的情况下才能在该领域表现出色。&lt;/p&gt;&#xA;&lt;p&gt;但整个讨论都理所当然地认为：如果我们让更多的优秀程序员进入美国，他们会想要来。现在这是真的，我们没有意识到我们有多么幸运。如果我们想保持这个选择开放，最好的方法是利用它：世界上越多的优秀程序员在这里，其余的就会越想要来这里。&lt;/p&gt;&#xA;&lt;p&gt;如果我们不这样做，美国可能会彻底完蛋。我意识到这是强烈的措辞，但对此犹豫不决的人似乎没有意识到这里发挥作用的力量有多大。技术给最好的程序员带来了巨大的杠杆作用。程序员的世界市场似乎正在变得更加流动性。而且由于优秀的人喜欢优秀的同事，这意味着最好的程序员可能会聚集在少数几个中心。可能主要在一个中心。&lt;/p&gt;&#xA;&lt;p&gt;如果大多数优秀程序员聚集在一个中心，而那个中心不在这里怎么办？这个场景现在可能看起来不太可能，但如果未来50年的变化与过去50年一样大，它就不会不太可能了。&lt;/p&gt;&#xA;&lt;p&gt;我们有可能仅仅通过每年让几千名优秀程序员进入美国就确保美国保持技术超级大国的地位。让这个机会溜走将是一个多么巨大的错误。这很容易成为这一代美国政客后来出名的决定性错误。与该规模的其他潜在错误不同，修复它的成本为零。&lt;/p&gt;&#xA;&lt;p&gt;所以，请继续吧。&lt;/p&gt;&#xA;&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;&#xA;&lt;p&gt;[1] 优秀程序员比普通程序员好多少？好到你甚至无法直接衡量差异。优秀程序员不仅仅是更快地完成相同的工作。优秀程序员会发明普通程序员甚至想不到的东西。这并不意味着优秀程序员的价值无限大，因为任何发明都有有限的市场价值。但很容易想象在某些情况下，优秀程序员可能会发明价值达到普通程序员工资100倍甚至1000倍的东西。&lt;/p&gt;&#xA;&lt;p&gt;[2] 有少数咨询公司出租大量通过H1-B签证带入的外国程序员。一定要打击这些。应该很容易写立法来区分它们，因为它们与技术公司如此不同。但反移民人士声称像谷歌和脸书这样的公司是由相同的动机驱动是不诚实的。廉价但平庸的程序员涌入是他们最不想要的事情；那会毁掉他们。&lt;/p&gt;&#xA;&lt;p&gt;[3] 虽然这篇文章谈论的是程序员，但我们需要引进的群体更广泛，从设计师到程序员再到电气工程师。作为通用术语，最好的可能是&amp;quot;数字人才&amp;rdquo;。似乎让论证过于狭窄比用新词混淆每个人要好。&lt;/p&gt;&#xA;&lt;p&gt;感谢萨姆·奥特曼、约翰·科利森、帕特里克·科利森、杰西卡·利文斯顿、杰夫·拉尔斯顿、弗雷德·威尔逊和卡萨尔·尤尼斯阅读本文的草稿。&lt;/p&gt;&#xA;&lt;p&gt;西班牙语翻译&lt;/p&gt;&#xA;&lt;hr&gt;</description>
    </item>
    <item>
      <title>超越平均水平</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/avg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/avg/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/avg/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/avg.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/avg.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/avg.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;超越平均水平&#34;&gt;超越平均水平&lt;/h1&gt;&#xA;&lt;p&gt;2001年4月&lt;/p&gt;&#xA;&lt;p&gt;如果你想知道什么是编程的&amp;quot;秘密&amp;quot;，那么就是编程语言之间存在很大的差异。这不仅仅是理论问题。实际上，这会对创业公司产生很大影响。&lt;/p&gt;&#xA;&lt;p&gt;创业公司成功的可能性有多大？如果你考虑所有的创业公司，大多数都会失败。但如果你只考虑那些成功的创业公司，它们都有一个共同点：它们使用某种秘密武器。它们做了一些大公司无法做的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;语言的差异&#34;&gt;语言的差异&lt;/h2&gt;&#xA;&lt;p&gt;编程语言之间存在巨大差异。有些语言比其他语言强大得多。如果你使用一种强大的语言，你可以比使用较弱语言的程序员更快地完成工作。&lt;/p&gt;&#xA;&lt;p&gt;大多数程序员对编程语言之间的差异了解甚少。他们知道一些语言比其他语言更&amp;quot;高级&amp;quot;，但他们不理解这些差异有多大。他们不理解使用强大语言可以给你带来多大的优势。&lt;/p&gt;&#xA;&lt;p&gt;使用强大语言不仅仅是写代码更快的问题。它是关于你能做什么的问题。在较弱的语言中，有些事情根本做不了，或者做起来非常困难。在强大的语言中，这些事情很容易。&lt;/p&gt;&#xA;&lt;h2 id=&#34;lisp的优势&#34;&gt;Lisp的优势&lt;/h2&gt;&#xA;&lt;p&gt;Lisp是最强大的编程语言之一。它比大多数其他语言强大得多。使用Lisp的程序员比使用其他语言的程序员有巨大的优势。&lt;/p&gt;&#xA;&lt;p&gt;Lisp的优势不是微小的。它是巨大的。使用Lisp的团队可以比使用其他语言的团队小得多，但仍然完成更多的工作。&lt;/p&gt;&#xA;&lt;p&gt;Viaweb就是一个例子。Viaweb是第一个基于Web的应用程序。它让用户可以在线构建商店。我们三个人使用Lisp构建了Viaweb。我们的竞争对手使用其他语言，如C++和Perl。他们需要更多的人来完成同样的工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么更多的人不使用lisp&#34;&gt;为什么更多的人不使用Lisp？&lt;/h2&gt;&#xA;&lt;p&gt;如果Lisp如此强大，为什么更多的人不使用它？&lt;/p&gt;&#xA;&lt;p&gt;一个原因是Lisp与其他语言非常不同。大多数程序员习惯使用类似C的语言。Lisp看起来很奇怪。&lt;/p&gt;&#xA;&lt;p&gt;另一个原因是Lisp并不适合所有事情。它不是最好的系统编程语言。如果你正在编写设备驱动程序，C可能更好。&lt;/p&gt;&#xA;&lt;p&gt;但Lisp非常适合编写Web应用程序。这就是我们选择它用于Viaweb的原因。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创业公司的优势&#34;&gt;创业公司的优势&lt;/h2&gt;&#xA;&lt;p&gt;创业公司可以利用大公司无法使用的强大语言。大公司有太多惯性。它们使用特定的语言，因为它们总是使用这些语言。它们不能轻易改变。&lt;/p&gt;&#xA;&lt;p&gt;创业公司可以灵活得多。它们可以选择最适合工作的工具。&lt;/p&gt;&#xA;&lt;p&gt;这不仅仅是技术问题。这关乎竞争。如果你使用比竞争对手更强大的语言，你可以更快地移动。你可以做他们做不到的事情。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实际例子&#34;&gt;实际例子&lt;/h2&gt;&#xA;&lt;p&gt;在Viaweb，我们能够快速添加新功能。我们的竞争对手需要几周才能完成的事情，我们可以在几天内完成。&lt;/p&gt;&#xA;&lt;p&gt;我们能够添加我们的竞争对手无法添加的功能。Lisp让我们能够做到这一点。&lt;/p&gt;&#xA;&lt;p&gt;例如，我们能够添加一个让用户编辑HTML的功能。我们的竞争对手无法做到这一点，因为他们的语言不够强大。&lt;/p&gt;&#xA;&lt;h2 id=&#34;学习曲线&#34;&gt;学习曲线&lt;/h2&gt;&#xA;&lt;p&gt;Lisp有一个陡峭的学习曲线。大多数程序员需要一段时间才能习惯它。&lt;/p&gt;&#xA;&lt;p&gt;但这是值得的。一旦你学会了Lisp，你就会比其他程序员更有生产力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;&#xA;&lt;p&gt;编程语言之间存在巨大差异。这些差异对创业公司来说很重要。&lt;/p&gt;&#xA;&lt;p&gt;如果你正在创办一家创业公司，你应该考虑使用像Lisp这样的强大语言。它可以给你带来竞争优势。&lt;/p&gt;&#xA;&lt;p&gt;不要担心别人会怎么说。做你认为正确的事情。&lt;/p&gt;&#xA;&lt;p&gt;记住，创业公司的目标是成功。如果使用强大的语言帮助你成功，那就去做吧。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;这篇文章基于Paul Graham在2001年4月发表的原创作品，讨论了编程语言之间的差异以及它们对创业公司的重要性。&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>黑客与画家</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/hp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/hp/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/hp/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/hp.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/hp.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/hp.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;黑客与画家&#34;&gt;黑客与画家&lt;/h1&gt;&#xA;&lt;p&gt;2003年5月&lt;/p&gt;&#xA;&lt;p&gt;（本文源于在哈佛大学的一次客座讲座，该讲座整合了之前在东北大学的一次演讲。）&lt;/p&gt;&#xA;&lt;p&gt;当我完成计算机科学研究生学业后，我去艺术学院学习绘画。很多人似乎对感兴趣于计算机的人也会对绘画感兴趣感到惊讶。他们似乎认为黑客和绘画是截然不同的工作类型——黑客工作是冷酷、精确、有条理的，而绘画则是某种原始冲动的狂热表达。&lt;/p&gt;&#xA;&lt;p&gt;这两种形象都是错误的。黑客和绘画有很多共同之处。事实上，在我认识的所有不同类型的人中，黑客和画家是最相似的。&lt;/p&gt;&#xA;&lt;p&gt;黑客和画家的共同点是他们都是创造者。与作曲家、建筑师和作家一样，黑客和画家试图做的是创造好东西。他们本身并不是在做研究，尽管在试图创造好东西的过程中他们发现了一些新技术，那就更好了。&lt;/p&gt;&#xA;&lt;p&gt;我从来不喜欢&amp;quot;计算机科学&amp;quot;这个词。我不喜欢它的主要原因是没有这样的东西。计算机科学是一堆关系不大的领域的拼凑，因历史的偶然而被组合在一起，就像南斯拉夫一样。一端是实际上是数学家的人，但他们称自己做的事情为计算机科学，以便获得DARPA资助。中间是从事类似计算机自然史工作的人——例如研究通过网络路由数据的算法行为。然后在另一端是黑客，他们试图编写有趣的软件，对他们来说，计算机只是表达媒介，就像对建筑师来说是混凝土，对画家来说是颜料一样。这就像是数学家、物理学家和建筑师都必须在同一个系里一样。&lt;/p&gt;&#xA;&lt;p&gt;有时黑客所做的事情被称为&amp;quot;软件工程&amp;quot;，但这个术语同样具有误导性。优秀的软件设计师并不比建筑师更像工程师。建筑和工程之间的界限并没有明确界定，但它是存在的。它在于做什么和如何做之间：建筑师决定做什么，工程师弄清楚如何做。&lt;/p&gt;&#xA;&lt;p&gt;做什么和如何做不应过于分离。如果你试图在不知道如何做的情况下决定做什么，那是在自找麻烦。但黑客工作绝不仅仅是决定如何实现某个规范。在最好的情况下，它是创建规范——但事实证明做到这一点的最好方法是实现它。&lt;/p&gt;&#xA;&lt;p&gt;也许有一天&amp;quot;计算机科学&amp;quot;会像南斯拉夫一样被分解成其组成部分。这可能是件好事。特别是如果这意味着我自己的领域——黑客的独立。&lt;/p&gt;&#xA;&lt;p&gt;将所有这些不同类型的工作捆绑在一个部门可能在行政上很方便，但在智力上是混乱的。这是我不喜欢&amp;quot;计算机科学&amp;quot;这个名字的另一个原因。可以说，中间的人在做类似实验科学的事情。但两端的人，黑客和数学家，实际上并不是在做科学。&lt;/p&gt;&#xA;&lt;p&gt;数学家似乎并不为此困扰。他们很高兴地开始证明定理，就像数学系的数学家一样，并且很快就会停止注意到他们工作的建筑外面写着&amp;quot;计算机科学&amp;quot;。但对黑客来说，这个标签是个问题。如果他们所做的事情被称为科学，这让他们觉得他们应该表现得科学。因此，大学和研究实验室里的黑客不做他们真正想做的事情，即设计美丽的软件，而是觉得他们应该写研究论文。&lt;/p&gt;&#xA;&lt;p&gt;在最好的情况下，论文只是一种形式。黑客编写很酷的软件，然后写一篇关于它的论文，论文就成为了软件所代表成就的代理。但这种不匹配经常导致问题。很容易从创造美丽的东西转向创造丑陋的东西，而这些东西更适合作为研究论文的题材。&lt;/p&gt;&#xA;&lt;p&gt;不幸的是，美丽的东西并不总是最好的论文主题。首先，研究必须是原创的——正如任何写过博士论文的人所知，确保你在探索未知领域的方法是占据一块没有人想要的地盘。其次，研究必须是实质性的——笨拙的系统会产生更丰富的论文，因为你可以写为了完成工作而必须克服的障碍。没有什么比从错误假设开始更能产生丰富的问题了。大多数人工智能都是这个规则的例子；如果你假设知识可以表示为谓词逻辑表达式的列表，其参数代表抽象概念，你将有很多论文要写关于如何使其工作。正如里奇·里卡多常说的：&amp;ldquo;露西，你有很多解释要做。&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;创造美丽东西的方法往往是对现有事物进行微妙的调整，或者以稍新的方式组合现有的想法。这种工作很难在研究论文中传达。&lt;/p&gt;&#xA;&lt;p&gt;那么为什么大学和研究实验室继续用出版物来判断黑客呢？原因与&amp;quot;学术能力&amp;quot;用简单的标准化测试衡量，或者程序员的生产力用代码行数衡量是一样的。这些测试很容易应用，没有什么比一个勉强有效的简单测试更诱人的了。&lt;/p&gt;&#xA;&lt;p&gt;衡量黑客真正试图做的事情，设计美丽的软件，会困难得多。你需要良好的设计感来判断好的设计。人们识别好设计的能力与他们对自己能做到的信心之间没有任何相关性，除了可能是负相关。&lt;/p&gt;&#xA;&lt;p&gt;唯一的外部测试是时间。随着时间的推移，美丽的东西往往会繁荣，丑陋的东西往往会被抛弃。不幸的是，所涉及的时间可能比人类寿命还长。塞缪尔·约翰逊说，作家的声誉需要一百年才能收敛。你必须等待作家有影响力的朋友死去，然后他们所有的追随者都死去。&lt;/p&gt;&#xA;&lt;p&gt;我认为黑客只能接受自己声誉中有很大的随机成分。在这方面，他们与其他创造者没有什么不同。事实上，相比之下，他们是幸运的。时尚在黑客中的影响力远不如在绘画中那么大。&lt;/p&gt;&#xA;&lt;p&gt;有比被人误解你的作品更糟糕的事情。更危险的是你会自己误解你的作品。相关领域是你寻找想法的地方。如果你发现自己身处计算机科学系，自然会有一种诱惑，例如认为黑客是理论计算机科学理论的应用版本。我在研究生院的整个时间里，脑海中总有一种不安的感觉，觉得我应该知道更多理论，而且在期末考试后三周内忘记所有东西是非常疏忽的。&lt;/p&gt;&#xA;&lt;p&gt;现在我意识到我错了。黑客需要了解计算理论的程度，与画家需要了解颜料化学的程度差不多。你需要知道如何计算时间和空间复杂性以及图灵完备性。你可能还想记住至少状态机的概念，以防你不得不编写解析器或正则表达式库。事实上，画家必须记住的颜料化学知识比这多得多。&lt;/p&gt;&#xA;&lt;p&gt;我发现，最好的想法来源不是名字中有&amp;quot;计算机&amp;quot;一词的其他领域，而是创造者居住的其他领域。绘画比计算理论是更丰富的想法来源。&lt;/p&gt;&#xA;&lt;p&gt;例如，我在大学里学到的是，一个人应该在完全接触计算机之前在纸上完整地构思一个程序。我发现我不是这样编程的。我发现我喜欢坐在计算机前编程，而不是在纸上。更糟糕的是，我不是耐心地写出完整的程序并确保它是正确的，而是倾向于只是喷出完全没有希望的代码，然后逐渐把它塑造成形。我学到的是，调试是一种最后阶段，你捕捉打字错误和疏忽。按照我的工作方式，编程似乎就是由调试组成的。&lt;/p&gt;&#xA;&lt;p&gt;很长时间以来，我对此感觉很糟糕，就像我曾经因为小学时握铅笔的方式和他们教我的不一样而感到难过一样。如果我看过其他创造者，画家或建筑师，我会意识到我所做的事情有一个名字：素描。据我所知，他们在大学教我的编程方法完全是错的。你应该在编写程序时构思程序，就像作家、画家和建筑师所做的那样。&lt;/p&gt;&#xA;&lt;p&gt;意识到这一点对软件设计有实际意义。这意味着编程语言最重要的特性应该是可塑的。编程语言是用来思考程序的，而不是表达你已经想好的程序。它应该是一支铅笔，而不是一支钢笔。如果人们真的像他们在大学教我的那样写程序，静态类型会是个好主意。但这不是我认识的任何黑客写程序的方式。我们需要一种让我们能够涂鸦、涂抹和弄脏的语言，而不是一种你必须用一杯类型平衡在膝盖上与严格的老婶婶编译器礼貌交谈的语言。&lt;/p&gt;&#xA;&lt;p&gt;既然我们在讨论静态类型，认同创造者将使我们免于困扰科学的另一个问题：数学嫉妒。科学界的每个人都秘密认为数学家比他们聪明。我认为数学家也相信这一点。无论如何，结果是科学家倾向于使他们的工作看起来尽可能数学化。在像物理学这样的领域，这可能不会造成太大伤害，但离自然科学越远，这个问题就越大。&lt;/p&gt;&#xA;&lt;p&gt;一页公式看起来非常令人印象深刻。（提示：为了更加令人印象深刻，使用希腊变量。）因此，有很大的诱惑去做你可以正式处理的问题，而不是那些重要的，比如说，重要的问题。&lt;/p&gt;&#xA;&lt;p&gt;如果黑客认同其他创造者，比如作家和画家，他们就不会感到诱惑去做这种事情。作家和画家不遭受数学嫉妒。他们觉得他们在做完全不相关的事情。我认为黑客也是如此。&lt;/p&gt;&#xA;&lt;p&gt;如果大学和研究实验室阻止黑客做他们想做的工作，也许他们的位置是在公司。不幸的是，大多数公司也不会让黑客做他们想做的事情。大学和研究实验室强迫黑客成为科学家，公司强迫他们成为工程师。&lt;/p&gt;&#xA;&lt;p&gt;我自己直到最近才发现这一点。当雅虎收购Viaweb时，他们问我想做什么。我从来不太喜欢商业方面，说我只想黑客。当我到雅虎时，我发现黑客对他们来说意味着实现软件，而不是设计它。程序员被视为技术人员，将产品经理的愿景（如果那算是的话）翻译成代码。&lt;/p&gt;&#xA;&lt;p&gt;这似乎是大公司的默认计划。他们这样做是因为它减少了结果的标准差。只有一小部分黑客能够真正设计软件，公司经营者很难挑选出这些人。因此，大多数公司不将软件的未来委托给一个才华横溢的黑客，而是设置成由委员会设计，黑客只实现设计。&lt;/p&gt;&#xA;&lt;p&gt;如果你想赚钱，记住这一点，因为这是创业公司获胜的原因之一。大公司希望减少设计结果的标准差，因为他们想避免灾难。但当你抑制波动时，你既失去了高点，也失去了低点。这对大公司来说不是问题，因为他们不是靠做出伟大的产品获胜的。大公司靠比其他大公司少些糟糕获胜。&lt;/p&gt;&#xA;&lt;p&gt;所以如果你能找到一种方法与一家大公司进行设计战争，大到其软件是由产品经理设计的，他们将永远无法跟上你。不过，这些机会并不容易找到。很难让大公司参与设计战争，就像很难让城堡内的对手进行肉搏战一样。例如，编写一个比微软Word更好的文字处理器会很容易，但微软在其操作系统垄断的城堡内，即使你做到了，可能甚至不会注意到。&lt;/p&gt;&#xA;&lt;p&gt;进行设计战争的地方是新市场，在那里还没有人设法建立任何防御工事。在那里，你可以通过大胆的设计方法，以及让同样的人既设计又实现产品而大获全胜。微软自己一开始就是这样做的。苹果也是如此。惠普也是如此。我怀疑几乎所有成功的创业公司都是如此。&lt;/p&gt;&#xA;&lt;p&gt;所以构建伟大软件的一种方法是创办自己的创业公司。然而，这有两个问题。一是在创业公司，你必须做很多编程以外的事情。在Viaweb，如果我能有四分之一的时间黑客，我就觉得自己很幸运。我在其他四分之三的时间里不得不做的事情从乏味到可怕不等。我对此有一个基准，因为我曾经不得不离开董事会会议去补牙。我记得坐在牙医的椅子上，等待钻头，感觉就像在度假。&lt;/p&gt;&#xA;&lt;p&gt;创业公司的另一个问题是，赚钱的软件和有趣的软件之间没有太多重叠。编程语言写起来很有趣，微软的第一个产品确实是，但现在没有人会为编程语言付钱。如果你想赚钱，你往往被迫从事对任何人来说都太麻烦而无法免费解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;所有创造者都面临这个问题。价格由供求关系决定，对有趣工作的需求不如解决个人客户日常问题的需求多。在外百老汇戏剧中表演不如在贸易展上穿着大猩猩服装在别人的展位工作赚钱。写小说不如为垃圾处理器写广告文案赚钱。黑客编程语言不如想办法将某公司的遗留数据库连接到他们的Web服务器赚钱。&lt;/p&gt;&#xA;&lt;p&gt;我认为这个问题的答案，在软件的情况下，是一个几乎所有创造者都知道的概念：日常工作。这个词始于音乐家，他们晚上表演。更一般地说，这意味着你做一种工作是为了钱，做另一种是为了爱。&lt;/p&gt;&#xA;&lt;p&gt;几乎所有创造者在职业生涯早期都有日常工作。画家和作家尤其如此。如果你幸运，你可以找到与你真正工作密切相关的日常工作。音乐家似乎经常在唱片店工作。从事某种编程语言或操作系统工作的黑客同样可能能够使用它获得日常工作。[1]&lt;/p&gt;&#xA;&lt;p&gt;当我说答案是为黑客提供日常工作，并在业余时间从事美丽软件工作时，我并不是在提出一个新想法。这就是开源黑客的全部内容。我要说的是，开源可能是正确的模式，因为它已经被所有其他创造者独立证实。&lt;/p&gt;&#xA;&lt;p&gt;任何雇主都不愿让黑客从事开源项目，这让我感到惊讶。在Viaweb，我们不愿意雇佣任何不这样做的人。当我们面试程序员时，我们主要关心的是他们在业余时间编写什么样的软件。除非你热爱它，否则你不能真正做好任何事情，如果你热爱黑客，你将不可避免地从事自己的项目。[2]&lt;/p&gt;&#xA;&lt;p&gt;因为黑客是创造者而不是科学家，寻找隐喻的正确地方不是科学，而是其他类型的创造者。绘画还能教给我们什么关于黑客的知识？&lt;/p&gt;&#xA;&lt;p&gt;我们可以从绘画的例子中学到的一件事，或者至少确认的是，如何学习黑客。你主要通过做来学习绘画。黑客也是如此。大多数黑客不是通过上大学编程课程来学习黑客的。他们在十三岁时通过编写自己的程序来学习黑客。即使在大学课程中，你也主要通过黑客来学习黑客。[3]&lt;/p&gt;&#xA;&lt;p&gt;因为画家在他们身后留下了作品的痕迹，你可以看着他们通过做来学习。如果你按时间顺序看一位画家的作品，你会发现每幅画都建立在以前画中学到的东西的基础上。当一幅画中有某个东西效果很好时，你通常可以在一些早期绘画中以较小的形式找到它的版本1。&lt;/p&gt;&#xA;&lt;p&gt;我认为大多数创造者都是这样工作的。作家和建筑师似乎也是如此。也许黑客应该更像画家，定期从头开始，而不是继续在一个项目上工作多年，并试图将他们以后的想法作为修订纳入其中。&lt;/p&gt;&#xA;&lt;p&gt;黑客通过做来学习黑客这一事实是黑客与科学不同的另一个标志。科学家不是通过做科学来学习科学，而是通过做实验和解决问题集。科学家开始做的工作是完美的，在这个意义上说，他们只是试图重现别人已经为他们做过的工作。最终，他们达到可以做原创工作的地步。而黑客从一开始就在做原创工作；只是非常糟糕。所以黑客从原创开始，然后变好，科学家从好开始，然后变原创。&lt;/p&gt;&#xA;&lt;p&gt;创造者学习的另一种方式是通过例子。对画家来说，博物馆是技术参考图书馆。数百年来，复制大师作品一直是画家传统教育的一部分，因为复制迫使你仔细审视绘画的制作方式。&lt;/p&gt;&#xA;&lt;p&gt;作家也这样做。本杰明·富兰克林通过总结艾迪生和斯蒂尔散文中的观点，然后尝试重现它们来学习写作。雷蒙德·钱德勒对侦探故事做了同样的事情。&lt;/p&gt;&#xA;&lt;p&gt;同样，黑客可以通过看好的程序来学习编程——不仅看它们做什么，还看源代码。开源运动不太公开的好处之一是它使学习编程变得更容易。当我学习编程时，我们主要依靠书中的例子。当时可用的一大块代码是Unix，但即使这不是开源的。大多数阅读源代码的人是通过约翰·莱昂斯书的非法影印本来阅读的，这本书虽然写于1977年，但直到1996年才被允许出版。&lt;/p&gt;&#xA;&lt;p&gt;我们可以从绘画中借鉴的另一个例子是绘画是通过渐进改进而创造的。绘画通常从素描开始。逐渐地，细节被填入。但这不仅仅是填入的过程。有时原来的计划被证明是错误的。无数的绘画，当你用X光看时，发现肢体被移动了或面部特征被重新调整了。&lt;/p&gt;&#xA;&lt;p&gt;这里有一个我们可以从绘画中学习的例子。我认为黑客也应该这样工作。期望程序的规格说明是完美的是不现实的。如果你提前承认这一点，并以允许规格说明在运行中更改的方式编写程序，你会更好。&lt;/p&gt;&#xA;&lt;p&gt;（大公司的结构使他们很难做到这一点，所以这是创业公司有优势的另一个地方。）&lt;/p&gt;&#xA;&lt;p&gt;现在大概每个人都知道过早优化的危险。我认为我们应该同样担心过早设计——过早决定程序应该做什么。&lt;/p&gt;&#xA;&lt;p&gt;正确的工具可以帮助我们避免这种危险。一个好的编程语言应该像油画一样，使你容易改变主意。动态类型在这里是个优势，因为你不必预先承诺特定的数据表示。但我认为灵活性的关键是使语言非常抽象。最容易更改的程序是非常短的程序。这听起来像是一个悖论，但一幅伟大的绘画必须比它必须的要更好。例如，当莱昂纳多在华盛顿国家美术馆画吉内薇拉·德·班奇的肖像时，她在她头后放了一棵杜松树。他在其中仔细地画了每一片叶子。许多画家可能认为，这只是放在背景中框住她头部的东西。没有人会那么仔细地看它。&lt;/p&gt;&#xA;&lt;p&gt;不是莱昂纳多。他在画的一部分上工作的努力程度完全不取决于他期望任何人看它的程度。他像迈克尔·乔丹。无情。&lt;/p&gt;&#xA;&lt;p&gt;无情获胜是因为，总的来说，看不见的细节变得可见。当人们走过吉内薇拉·德·班奇的肖像时，他们的注意力常常立即被它吸引，甚至在他们看标签并注意到它说莱昂纳多·达·芬奇之前。所有那些看不见的细节结合在一起产生了一些令人惊叹的东西，就像一千个几乎听不见的声音都在和谐地歌唱。&lt;/p&gt;&#xA;&lt;p&gt;伟大的软件同样需要对美的狂热奉献。如果你看好的软件内部，你会发现那些永远不应该被看见的部分也是美丽的。我不声称我写伟大的软件，但我知道当涉及到代码时，我的行为方式如果用在日常生活中会让我有资格获得处方药。看到缩进糟糕的代码或使用丑陋变量名的代码会让我发疯。&lt;/p&gt;&#xA;&lt;p&gt;如果黑客只是一个实现者，将规范变成代码，那么他就可以像挖沟的人一样从一端到另一端完成工作。但如果黑客是创造者，我们必须考虑灵感。&lt;/p&gt;&#xA;&lt;p&gt;黑客像绘画一样，工作是周期性的。有时你对某个新项目感到兴奋，一天想工作十六个小时。有时似乎没有什么有趣的。&lt;/p&gt;&#xA;&lt;p&gt;要做好工作，你必须考虑这些周期，因为它们受到你对他们反应的影响。当你在山坡上驾驶手动变速器汽车时，你必须有时松开离合器以避免熄火。松开同样可以防止雄心熄火。在绘画和黑客中，有些任务是令人恐惧的雄心勃勃的，有些则是令人安慰的常规。留一些容易的任务给那些否则会停滞的时刻是个好主意。&lt;/p&gt;&#xA;&lt;p&gt;在黑客中，这实际上可能意味着保存错误。我喜欢调试：这是黑客像人们认为的那样直截了当的唯一一次。你有一个完全受限的问题，你只需要解决它。你的程序应该做x。相反它做y。它哪里出错了？你知道你最终会赢。这就像刷墙一样放松。&lt;/p&gt;&#xA;&lt;p&gt;绘画的例子不仅可以教我们如何管理自己的工作，还可以教我们如何一起工作。许多过去的伟大艺术是多人之手的作品，尽管博物馆墙上可能只有一个名字。莱昂纳多是维罗基奥工作室的学徒，画了他的《基督受洗》中的一个天使。这种事情是规则，而不是例外。米开朗基罗因为坚持亲自绘制西斯廷教堂天花板上的所有人物而被认为特别专注。&lt;/p&gt;&#xA;&lt;p&gt;据我所知，当画家一起在一幅画上工作时，他们从不工作的相同部分。大师画主要人物，助手画其他人物和背景是常见的。但你从来没有一个人在另一个人的作品上绘画。&lt;/p&gt;&#xA;&lt;p&gt;我认为这是软件协作的正确模式。不要推得太远。当一段代码被三四个不同的人黑客攻击，没有人真正拥有它时，它最终会像一个公共休息室。它往往会感觉荒凉和被遗弃，并积累无用之物。我认为协作的正确方法是将项目分成明确定义的模块，每个模块都有明确的拥有者，它们之间的接口尽可能精心设计，如果可能的话，像编程语言一样明确。&lt;/p&gt;&#xA;&lt;p&gt;像绘画一样，大多数软件是为人类受众准备的。因此，像画家一样，黑客必须有同理心才能做真正伟大的工作。你必须能够从用户的角度看问题。&lt;/p&gt;&#xA;&lt;p&gt;当我还是个孩子的时候，我总是被告知要从别人的角度看问题。这在实践中总是意味着做别人想要的事情，而不是我想要的事情。这当然给同理心一个坏名声，我故意不培养它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>黑客这个词</title>
      <link>https://linguage.github.io/paul_graham/essays_zh/gba/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://linguage.github.io/paul_graham/essays_zh/gba/</guid>
      <description>&lt;p&gt;→ &lt;a href=&#34;https://linguage.github.io/paul_graham/essays_en/gba/&#34;&gt;English Version&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;link-card&#34; data-url=&#34;https://www.paulgraham.com/gba.html&#34;&gt;&#xA;  &lt;a class=&#34;link-card__fallback&#34; href=&#34;https://www.paulgraham.com/gba.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&#xA;    https://www.paulgraham.com/gba.html&#xA;  &lt;/a&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;h1 id=&#34;黑客这个词&#34;&gt;黑客这个词&lt;/h1&gt;&#xA;&lt;p&gt;2004年4月&lt;/p&gt;&#xA;&lt;p&gt;对大众媒体来说，&amp;ldquo;黑客&amp;quot;意味着闯入计算机的人。在程序员中，它意味着一个好的程序员。但这两种含义是相连的。对程序员来说，&amp;ldquo;黑客&amp;quot;在最字面的意义上意味着精通：能够让计算机做他想要的事情的人——不管计算机是否愿意。&lt;/p&gt;&#xA;&lt;p&gt;更令人困惑的是，名词&amp;quot;hack&amp;quot;也有两种含义。它可以是赞美，也可以是侮辱。当你用丑陋的方式做某事时，这被称为hack。但当你做某事如此聪明以至于你以某种方式击败了系统时，那也被称为hack。这个词在前一种含义中比后一种更常用，可能是因为丑陋的解决方案比 brilliant 的更常见。&lt;/p&gt;&#xA;&lt;p&gt;信不信由你，&amp;ldquo;hack&amp;quot;的两种含义也是相连的。丑陋和富有想象力的解决方案有共同之处：它们都打破了规则。在仅仅丑陋的违规（用胶带把东西 attach 到你的自行车上）和 brilliantly 富有想象力的违规（丢弃欧几里得空间）之间存在一个逐渐的连续谱。&lt;/p&gt;&#xA;&lt;p&gt;黑客文化比计算机更早。当理查德·费曼在曼哈顿计划工作时，他常常通过闯入包含秘密文件的保险箱来娱乐自己。这个传统今天仍在继续。当我们读研究生时，我的一位在MIT周围花了太多时间的黑客朋友有自己的开锁工具包。（他现在经营对冲基金，这不是一个无关的企业。）&lt;/p&gt;&#xA;&lt;p&gt;有时候很难向当局解释为什么有人会想做这种事情。我的另一个朋友曾经因为闯入计算机而与政府惹上麻烦。这最近才被宣布为犯罪，FBI发现他们通常的调查技术不起作用。警察调查显然是从动机开始的。通常的动机很少：毒品、金钱、性、复仇。智力好奇心不在FBI的动机清单上。确实，整个概念对他们来说似乎很陌生。&lt;/p&gt;&#xA;&lt;p&gt;当权者往往对黑客普遍的不服从态度感到恼火。但这种不服从是使他们成为优秀程序员的品质的副产品。当CEO用通用的企业新闻发言时，他们可能会嘲笑他，但他们也会嘲笑告诉他们某个问题无法解决的人。压制一个，你就压制了另一个。&lt;/p&gt;&#xA;&lt;p&gt;这种态度有时是装出来的。有时年轻的程序员注意到著名黑客的怪癖，并决定采用一些自己的怪癖，以便看起来更聪明。虚假版本不仅令人讨厌；这些伪装者的 prickly 态度实际上会减慢创新过程。&lt;/p&gt;&#xA;&lt;p&gt;但即使考虑到他们令人讨厌的怪癖，黑客的不服从态度也是一个净胜利。我希望它的优势能被更好地理解。&lt;/p&gt;&#xA;&lt;p&gt;例如，我怀疑好莱坞的人们对黑客对版权的态度感到困惑。它们是Slashdot上激烈讨论的 perennial 话题。但是，为什么编程的人们应该如此关心版权，在所有事情中？&lt;/p&gt;&#xA;&lt;p&gt;部分原因是有些公司使用机制来防止复制。向任何黑客展示一把锁，他的第一个念头是如何打开它。但黑客对版权和专利等措施感到警惕有更深层次的原因。他们将 increasingly 激进的措施保护&amp;quot;知识产权&amp;quot;视为对他们工作所需的 intellectual freedom 的威胁。他们是对的。&lt;/p&gt;&#xA;&lt;p&gt;正是通过在当前技术内部探查，黑客才获得了下一代的想法。不，谢谢，知识产权所有者可能会说，我们不需要任何外部帮助。但他们错了。下一代计算机技术经常——或许比不是更经常——是由外人开发的。&lt;/p&gt;&#xA;&lt;p&gt;1977年，毫无疑问IBM内部有一些团体正在开发他们期望成为下一代商业计算机的东西。他们错了。下一代商业计算机正在由两个名叫史蒂夫的长发男人在洛斯阿尔托斯的车库里以完全不同的线路开发。大约在同一时间，当权者正在合作开发官方的下一代操作系统Multics。但两个认为Multics过于复杂的家伙离开去写自己的系统。他们给它起了一个对Multics开玩笑的名字：Unix。&lt;/p&gt;&#xA;&lt;p&gt;最新的知识产权法律对导致新想法的那种探查施加了前所未有的限制。在过去，竞争对手可能使用专利来阻止你销售他们制造的东西的副本，但他们不能阻止你拆开一个来看它是如何工作的。最新的法律使这成为犯罪。如果我们不能研究当前技术来弄清楚如何改进它，我们如何开发新技术？&lt;/p&gt;&#xA;&lt;p&gt;具有讽刺意味的是，黑客自己招致了这一点。计算机是造成问题的原因。机器内的控制系统过去是物理的：齿轮、杠杆和凸轮。 increasingly，产品的大脑（从而价值）在软件中。我指的是一般意义上的软件：即数据。LP上的歌曲是物理压印在塑料中的。iPod磁盘上的歌曲只是存储在上面。&lt;/p&gt;&#xA;&lt;p&gt;数据根据定义很容易复制。互联网使副本容易分发。所以公司害怕不足为奇。但是，像经常发生的那样，恐惧模糊了他们的判断。政府用严酷的法律来保护知识产权。他们可能是好意的。但他们可能没有意识到这样的法律弊大于利。&lt;/p&gt;&#xA;&lt;p&gt;为什么程序员如此强烈地反对这些法律？如果我是一个立法者，我会对这个谜团感兴趣——出于同样的原因，如果我是一个农民，突然一天晚上听到很多咯咯声来自我的鸡舍，我会想要出去调查。黑客不笨，而这个世界上 unanimity 很罕见。所以如果他们都在咯咯叫，也许有什么不对劲。&lt;/p&gt;&#xA;&lt;p&gt;难道这样的法律，虽然意图保护美国，但实际上会伤害它吗？想想看。费曼在曼哈顿计划期间闯入保险箱有一些非常美国化的东西。很难想象当时的德国当局对这类事情有幽默感。也许这不是巧合。&lt;/p&gt;&#xA;&lt;p&gt;黑客是不守规矩的。这就是黑客的本质。这也是美国精神的本质。硅谷在美国，而不是法国、德国、英国或日本，这绝非偶然。在那些国家，人们在 lines 内着色。&lt;/p&gt;&#xA;&lt;p&gt;我在佛罗伦萨住了一段时间。但在那里呆了几个月后，我意识到我无意识希望在那里找到的东西 back 在我刚刚离开的地方。佛罗伦萨著名的原因是，在1450年，它是纽约。在1450年，它充满了你现在在美国发现的那种动荡和雄心勃勃的人。（所以我回到了美国。）&lt;/p&gt;&#xA;&lt;p&gt;美国的一个巨大优势是它为正确的那种不守规矩提供了宜人的氛围——它不仅是聪明人的家园，也是 smart-alecks 的家园。黑客 invariably 是 smart-alecks。如果我们有一个国定假日，那将是4月1日。我们对 brilliant 或可怕 cheesy 的解决方案使用同一个词，这充分说明了我们的工作。当我们炮制出一个时，我们不总是100%确定它是哪种。但只要它有正确的错误类型，那就是一个有希望的迹象。人们认为编程是精确和有条理的，这很奇怪。计算机是精确和有条理的。黑客是你在开怀大笑时做的事情。&lt;/p&gt;&#xA;&lt;p&gt;在我们的世界中，一些最具特征的解决方案与恶作剧相去不远。IBM无疑对DOS许可证协议的后果感到相当惊讶，就像假设的&amp;quot;对手&amp;quot;在迈克尔·拉宾通过将问题重新定义为更容易解决的问题来解决问题时必须感到的那样。&lt;/p&gt;&#xA;&lt;p&gt;Smart-alecks 必须 develop 对他们能逃脱多少的敏锐感觉。最近黑客已经感觉到气氛的变化。最近黑客精神似乎相当不被人看好。&lt;/p&gt;&#xA;&lt;p&gt;对黑客来说，最近公民自由的收缩似乎特别不祥。这也一定让外人感到困惑。为什么我们应该特别关心公民自由？为什么程序员比牙医、推销员或园林设计师更关心？&lt;/p&gt;&#xA;&lt;p&gt;让我用政府官员会欣赏的术语来说明这个 case。公民自由不仅仅是一种装饰，或一种古怪的 American 传统。公民自由使国家富裕。如果你绘制人均GNP与公民自由的图表，你会注意到一个明确的趋势。公民自由真的可能是一个原因，而不仅仅是一个结果？我认为是的。我认为一个人们可以做和说他们想做的事情的社会也倾向于一个最有效的解决方案获胜的社会，而不是那些最有影响力的人赞助的解决方案。威权国家变得腐败；腐败国家变得贫穷；贫穷国家是弱小的。在我看来，政府权力有一条拉弗曲线，就像税收收入一样。至少，这似乎足够可能，以至于尝试实验并发现会是愚蠢的。与高税率不同，如果证明是一个错误，你不能废除极权主义。&lt;/p&gt;&#xA;&lt;p&gt;这就是黑客担心的原因。政府监视人们并不会让程序员写更差的代码。它只是最终导致一个坏想法获胜的世界。因为这对黑客如此重要，他们对此特别敏感。他们能从远处感知极权主义的 approaching，就像动物能感知 approaching 雷暴一样。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
