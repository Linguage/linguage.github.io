<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最佳实践 on Linguista</title><link>https://linguista.cn/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><description>Recent content in 最佳实践 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 28 Jan 2026 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>创建自定义技能</title><link>https://linguista.cn/courses/agent-skills-with-anthropic/06.-creating-custom-skills/</link><pubDate>Wed, 28 Jan 2026 00:00:00 +0800</pubDate><guid>https://linguista.cn/courses/agent-skills-with-anthropic/06.-creating-custom-skills/</guid><description>&lt;h1 id="创建自定义技能"&gt;创建自定义技能&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本课程深入讲解Claude技能(Skills)的结构规范与创建最佳实践，包括YAML前置元数据要求、技能主体编写准则、可选目录组织方式。通过两个实战案例（生成练习题技能和时间序列分析技能）演示如何构建生产级技能，并介绍使用skill-creator工具评估技能质量的方法，最后探讨技能测试与验证策略。&lt;/p&gt;
&lt;h2 id="要点"&gt;要点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技能结构与规范&lt;/strong&gt;：每个技能必需包含SKILL.md文件，带有名称和描述的YAML前置元数据，名称需使用小写字母、数字和连字符，描述应明确说明技能功能及触发条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写最佳实践&lt;/strong&gt;：提供逐步指令、指定边缘情况、保持500行以内、使用正斜杠路径、明确工作流顺序；根据任务性质选择自由度（最佳实践宜低自由度，创意输出可高自由度）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选目录组织&lt;/strong&gt;：scripts存放可执行代码，references存放文档参考，assets存放模板和资源文件，采用渐进式披露策略按需加载以优化token使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实战案例分析&lt;/strong&gt;：生成练习题技能演示如何引用外部模板处理不同输出格式（Markdown/LaTeX/PDF）；时间序列分析技能展示确定性工作流设计，通过Python脚本实现可视化和诊断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;评估与测试&lt;/strong&gt;：使用skill-creator技能和并行子智能体评估技能质量，建立类似单元测试的验证框架，确保输入输出、工作流顺序和跨模型兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;视频信息：&lt;a href="https://learn.deeplearning.ai/courses/agent-skills-with-anthropic/lesson/txwyf5/creating-custom-skills"&gt;Creating Custom Skills&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="中文翻译"&gt;中文翻译&lt;/h2&gt;
&lt;p&gt;我们现在将仔细研究技能（Skills）是如何构建的，以及创建技能的最佳实践。然后，我们将把你学到的知识应用到两个例子中。一个是根据讲义创建练习题，另一个是分析时间序列数据的特征。我们开始吧。&lt;/p&gt;
&lt;p&gt;在这节课中，我们将重点关注一下技能的结构，以及与之相关的一些最佳实践。然后我们将看看我们制作的两个技能，看看它们通过技能创建器（Skill Creator）运行时表现如何，看看它们在某些最佳实践方面的表现。复习一下，我们制作的每一项技能都有一个必需的 SKILL.md 文件，其中包含一些 YAML Frontmatter（前置元数据），该元数据要求包含名称和描述。在底层的 SKILL.md 中，我们拥有技能的内容，然后是对脚本或任何额外文本文件、必要资源的引用，这些资源仅在必要时才会被加载。&lt;/p&gt;
&lt;p&gt;当我们看看关于名称和描述的一些最佳实践时，你可以想象这是任务关键型的。你的名称和描述不仅是 Claude 分析你的技能做什么的方式，也是 Claude 检测何时使用该特定技能的方式。所以对于名称，字符数有限制，描述也是如此。我们简要提到过，名称必须包含小写字母、数字和连字符，一般来说，技能的名称要坚持使用动词加 ing 的形式。对于描述，你不仅要描述它做什么，还要描述何时使用它。如果有特定的关键字会导致智能体触发此技能，请确保利用好这些关键字。&lt;/p&gt;
&lt;p&gt;除了你拥有的必需字段外，智能体技能规范还允许使用可选字段。这可能是许可证、兼容性以及元数据中的任意键值对。这里需要注意的重要一点是，虽然智能体技能有一个标准，但你可能会遇到一些技能，有些是由 Anthropic 构建的，有些是其他人构建的，它们并不完全遵循这个规范。技能正处于积极开发中，技能规范也是如此，因为我们跨许多不同的模型提供商和许多不同的智能体工具生态系统开展工作。&lt;/p&gt;
&lt;p&gt;当我们开始越过 YAML Frontmatter 进入技能的底层主体时，我们对技能的格式没有底层限制。但是，当你考虑构建可预测的工作流时，你要确保有分步说明。正如我们在其他技能中看到的那样，特别是技能创建器技能，重要的是要指定边缘情况、分步说明，如果有理由跳过某个步骤，要非常清楚原因。一般来说，将其保持在 500 行以内是最佳实践，因为我们总是可以在必要时引用外部文件、资源和脚本。一般来说，清晰简洁是有价值的，使用正斜杠是任务关键型的，即使在 Windows 上也是如此。确保技能在许多不同的环境中工作很重要。&lt;/p&gt;
&lt;p&gt;当你考虑创建技能时，你要稍微考虑一下你想给该技能多少自由度。我们应该允许通用的方法和通用的方向，还是应该专注于特定的顺序？你可以想象，为了遵循最佳实践，我们可能希望自由度较低，但对于更具创造性的输出，如多种颜色、多种风格、多种字体，我们可以允许那种高自由度。当我们开始考虑具有多个技能的更复杂的工作流时，将事情分解为连续的步骤总是比拥有一个试图做所有事情的非常非常大的技能更有价值。这些系统可以处理 100 多个技能。重要的是要确保它们的命名恰当，不令人困惑，并且可以遵循可预测的模式。&lt;/p&gt;
&lt;p&gt;在规范中，有空间容纳可选目录。正如我们在许多不同的技能中看到的那样，有用于脚本、参考资料和资源的子文件夹。你的脚本包括任何需要读取和执行的代码。你还要确保你有错误处理和清晰的文档。我们的参考资料包含额外的文档或参考文件。一般来说，如果参考文件很长，指示技能读取整个参考文件通常很有价值。最后，我们有底层资源。这些可以包括输出模板、图像、徽标、数据文件、架构等等。&lt;/p&gt;
&lt;p&gt;值得注意的是，这些目录、脚本、参考资料和资源都遵循智能体技能的标准。但你可能会遇到相当多尚未遵循该特定标准的不同技能。该标准正在迅速发展，技能也在迅速发展。因此展望未来，我们期望创建的技能遵循此标准。但你可能会遇到一些具有不同文件夹名称和不同约定的技能。现在我们对最佳实践、可选目录以及如何编写生产级技能有了很好的了解，让我们来看看我们创建的两个技能示例，逐步了解它们，然后通过 skill-creator 运行它们以分析最佳实践，并讨论评估这些技能以确保我们为生产做好准备。&lt;/p&gt;
&lt;p&gt;我现在在 VS Code 中。在这里我们要深入研究两个自定义技能。第一个是生成练习题的技能。如果我们看看这个技能，我们可以看到描述是根据讲义生成教育练习题以测试理解能力。你可以想象你是一名老师或讲师，你想为输入和输出提供特定的格式，并且你想生成全面的问题来测试理解能力。让我们逐步了解这个技能。首先，我们支持的输入格式。我们指定使用哪些特定的库，并指定要提取什么文本。然后我们接着是我们的问题结构。同样，我们要非常具体，所以我们要指定生成这些问题的确切顺序。从判断题开始，一直到现实应用题。&lt;/p&gt;
&lt;p&gt;对于每一个问题，我们在下面都有子指南。我们可以看到，这个技能的代码不超过 500 行。但如果它需要变得越来越大，我们总是可以在必要时包含底层文件以供引用。当我们看看其中一些例子时，对于判断题，甚至是编码问题等等。我们可以看到这里，我们非常明确地规定了这些特定问题的范围、结构和所需的输出。当我们更深入地研究该输出格式时，我们指定它取决于用户的请求。而且我们实际上是在引用 assets 文件夹内的模板，而不是直接给出每种输出的直接示例。如果我们要处理 LaTeX 或 Markdown，我们要确切指定我们要它看起来像什么样。&lt;/p&gt;
&lt;p&gt;例如，对于 Markdown，这就是判断题可能的样子。对于 LaTeX，这就是我们的判断题和示例在我们进行过程中的样子。如果你发现自己需要某种特定的输出格式，与其把所有内容都放在 SKILL.md 中，不如在一个外部资源或文件中引用它。请记住，这些文件、这些模板仅在必要时才会被加载。所以我们可以通过仅加载我们需要的数据格式的特定文件，在 token 和上下文窗口方面做到极其高效。如果我们需要外部资源、特定领域的示例，我们也可以链接到它，就像我们在这里的 references 文件夹中所做的那样。我们倾向于逐步披露（Progressive Disclosure）的概念，只加载绝对必要的内容，并且仅在需要时引用外部文件。&lt;/p&gt;
&lt;p&gt;我们要看的第二个技能是一个分析时间序列数据的技能。我们将提供一个 CSV 文件，我们希望在预测很多不同的事情之前了解其特征。这里需要注意的重要一点是，当我们通过这个特定技能时，我们要有一个非常特定的确定性工作流。我们利用几个不同的 Python 脚本来执行该特定操作。首先，我们有一个 Python 脚本用于可视化我们要处理的数据。绘制时间序列图、直方图、滚动统计数据、箱线图等等。为了处理自相关，我们也有可以绘制的图。分解也是如此。&lt;/p&gt;</description></item><item><title>Claude Code 智能编程最佳实践指南</title><link>https://linguista.cn/rosetta/technology/claude-code-best-practices-for-agentic-coding/</link><pubDate>Fri, 18 Apr 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/claude-code-best-practices-for-agentic-coding/</guid><description>&lt;h1 id="claude-code-智能编程最佳实践指南"&gt;Claude Code 智能编程最佳实践指南&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍了 Anthropic 推出的命令行智能编程工具 Claude Code 的使用技巧与最佳实践。内容涵盖如何通过 CLAUDE.md 文件自定义开发环境、优化上下文配置、提升编码效率等方面，适用于不同代码库、编程语言和开发环境，帮助开发者更好地将 AI 融入日常编程工作流。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Agentic Coding&lt;/strong&gt;：指由 AI 代理自主完成编码任务的开发模式，AI 能够自动拉取上下文、理解代码结构并执行多步骤操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLAUDE.md&lt;/strong&gt;：Claude Code 的专用配置文件，用于定义项目规范、常用命令和代码风格等信息，启动对话时自动加载到上下文中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Context Gathering&lt;/strong&gt;：上下文收集机制，Claude Code 自动获取项目相关信息以辅助生成代码，但会消耗时间和 token，需要通过环境调优来优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prompt Tuning&lt;/strong&gt;：提示词调优，通过迭代和优化 CLAUDE.md 中的指令内容来提升模型的指令遵循能力，包括添加强调标记等技巧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Low-level Tool Design&lt;/strong&gt;：低层级工具设计理念，Claude Code 有意保持底层和无预设立场的设计，提供接近原始模型访问的灵活性而非强制特定工作流&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www-cdn.anthropic.com/images/4zrzovbb/website/6295100fcf8952bed666ba69536c581af87eef15-2554x2554.svg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Published Apr 18, 2025&lt;/p&gt;
&lt;p&gt;Claude Code is a command line tool for agentic coding. This post covers tips and tricks that have proven effective for using Claude Code across various codebases, languages, and environments.&lt;/p&gt;</description></item><item><title>如何在软件开发中实现无缺陷代码</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/writing-bug-free-software-best-practices/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/writing-bug-free-software-best-practices/</guid><description>&lt;h1 id="如何在软件开发中实现无缺陷代码"&gt;如何在软件开发中实现&amp;quot;无缺陷&amp;quot;代码&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者在 Telegram 的工作经验，探讨了如何在软件开发中实现&amp;quot;无缺陷&amp;quot;代码。文章分析了当前软件行业对代码质量的两种极端观点——追求极致测试覆盖率与忽视质量快速交付功能，指出这两种策略都存在明显弊端。作者通过自身实践，提出了一条中间道路：通过提前规划、优化开发流程、减少复杂性等方式，在不牺牲开发速度的前提下写出高质量的代码。这种&amp;quot;无缺陷&amp;quot;编程方式最终会形成肌肉记忆，成为开发者无意识的技能。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先回顾了作者在 Telegram 的工作经历，在那里团队以接近&amp;quot;无缺陷&amp;quot;代码而闻名。虽然完全无缺陷是不可能的，但这种思维方式值得学习和推广。作者指出，软件行业对代码质量存在两种极端的误解：一端认为缺陷无关紧要，应该专注于快速交付功能；另一端则追求极致的测试覆盖率，确保代码在任何情况下都能正常工作。&lt;/p&gt;
&lt;p&gt;作者深入分析了这两种极端观点的弊端。追求极致测试会导致开发速度极慢、成本高昂、质量低下，还容易造成开发人员疲劳。而忽视质量快速交付功能，虽然短期内能看到成果，但长期来看会导致代码库难以维护，功能之间相互依赖，难以隔离问题区域。一些看似&amp;quot;成功&amp;quot;的实验最终因缺乏鲁棒性和可扩展性而需要重写，浪费了大量时间和金钱。&lt;/p&gt;
&lt;p&gt;作者进一步指出，试图平衡这两种极端策略的中间派往往也难以奏效。在企业环境中，管理层通常只关注新功能的交付，而忽视维护和修复缺陷的工作。这种不平衡导致维护团队感到被边缘化，最终影响项目成功。&lt;/p&gt;
&lt;p&gt;基于自身实践，作者分享了实现&amp;quot;无缺陷&amp;quot;代码的具体方法。首先是在技术设计阶段提前规划，但不过度规划。作者会花时间思考架构和技术选型，选择合适的工具和技术栈，避免引入不必要的复杂性。其次是持续优化开发流程，在项目启动时就建立良好的开发规范和工具链。最重要的是减少复杂性，作者认为减少开发复杂性的优化总是值得的，这能确保代码的可靠性和灵活性。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;无缺陷&amp;quot;代码思维&lt;/strong&gt;：这不是指追求绝对的零缺陷，而是建立一种追求正确性的编程习惯和思维方式。通过持续改进和对正确性的专注，开发者可以在不增加太多复杂性的情况下写出鲁棒的代码。这种思维最终会形成肌肉记忆，成为开发者无意识的技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提前规划与适度规划&lt;/strong&gt;：在技术设计阶段需要提前思考架构、技术选型和潜在风险，但要避免过度规划导致的分析瘫痪。关键是在项目启动时就选择合适的工具和技术栈，为后续开发奠定良好基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少开发复杂性&lt;/strong&gt;：这是作者强调的核心原则。减少复杂性的优化总是值得的，它能确保代码的可靠性和灵活性，避免后期陷入难以维护的代码库中。复杂性是代码质量的敌人，开发者应该时刻警惕不必要的复杂性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化开发流程&lt;/strong&gt;：在项目启动时投入时间建立良好的开发规范、工具链和测试流程，这看似会减慢初期开发速度，但长期来看能大幅提高开发效率和代码质量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理层对质量的忽视&lt;/strong&gt;：这是导致平衡策略难以奏效的组织层面原因。管理层往往只关注新功能交付，而忽视维护和缺陷修复工作，导致维护团队被边缘化，最终影响项目成功。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://korshakov.com/posts/no-bugs"&gt;You should write &amp;ldquo;without bugs&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Konstantin Korshakov&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件工程师应避免的十个行为</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</guid><description>&lt;h1 id="软件工程师应避免的十个行为"&gt;软件工程师应避免的十个行为&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;作者 Hoon Wee 基于五年以上的软件工程经验，分享了十个开发者应当避免的行为模式。这些经验涵盖了对代码质量的理解、开发流程的把控、职业心态的调整等多个维度，旨在帮助软件工程师摆脱常见误区，成长为更成熟的问题解决者。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以资深工程师的视角展开论述，首先指出了完美主义的陷阱——完美的代码并不存在，软件开发本质上是迭代的过程，专业能力体现在&amp;quot;足够好&amp;quot;而非&amp;quot;完美&amp;quot;。作者进一步强调重构应当融入日常开发流程，而非作为事后的额外请求，这体现了对工程质量的持续关注。&lt;/p&gt;
&lt;p&gt;在技术实践层面，作者重新定义了&amp;quot;遗留代码&amp;quot;的概念——它并非指旧代码，而是指缺乏测试的代码。这一观点揭示了可测试性与可维护性之间的本质联系。同时，作者警示不要盲目推崇函数式编程或遵循所谓的&amp;quot;最佳实践&amp;quot;，编程范式的选择应当基于具体场景和上下文判断，而非教条式套用。&lt;/p&gt;
&lt;p&gt;文章后半部分转向开发者工作方式和职业心态的探讨。作者反对独自挣扎解决问题，倡导利用团队智慧和现有方案；提醒在追求&amp;quot;心流&amp;quot;状态时保持自我觉察，建议采用番茄工作法避免倦怠。最后，作者强调了身体健康的重要性，并鼓励开发者保持对编程本身的热爱，从&amp;quot;码农&amp;quot;升级为用代码解决问题的&amp;quot;软件工程师&amp;quot;，以应对未来 AI 对简单编码工作的潜在替代。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;遗留代码的本质&lt;/strong&gt;：传统观点认为遗留代码等同于陈旧代码，但作者指出真正的定义是&amp;quot;没有测试的代码&amp;quot;。缺乏测试的代码无法安全重构，也无法维护；相反，即使技术栈较老（如 Next.js v10），只要测试覆盖良好，代码仍然具备可维护性。这一观点重新定义了代码质量的评判标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文驱动的技术选择&lt;/strong&gt;：函数式编程、清洁架构、SOLID 原则、TDD 等都是有力的工具，但没有放之四海而皆准的&amp;quot;最佳实践&amp;quot;。在 Clojure 或 Python 等语言中，TDD 可能并非必要；在 Flutter UI 层中，过度函数式化可能损害性能。成熟工程师的标志在于根据具体情境做出合理判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从编码者到问题解决者&lt;/strong&gt;：AI 时代正在重新定义软件开发者的价值。单纯写代码的能力（&amp;ldquo;码农&amp;rdquo;）面临被替代的风险，而运用代码解决实际问题的能力（&amp;ldquo;软件工程师&amp;rdquo;）将更加稀缺。这一转变要求开发者超越技术本身，关注业务价值和问题本质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://favtutor.com/articles/donts-for-software-engineer/"&gt;Things You Should Never Do As A Software Engineer&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Hoon Wee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件设计原则的四个教训</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</guid><description>&lt;h1 id="软件设计原则的四个教训"&gt;软件设计原则的四个教训&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者设计和实现大型服务项目的实践经验，总结了四个重要的软件设计原则。这些原则从反面教训出发，帮助工程师避免常见的软件设计陷阱，包括数据同步问题、过度抽象、测试可靠性以及状态管理等核心议题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先介绍了作者的实践背景，通过一个大型服务项目的开发经历，提炼出四个反复出现的设计原则。这些原则往往与传统观点存在差异，体现了实践中获得的真实经验。&lt;/p&gt;
&lt;p&gt;第一原则强调维护单一数据源的重要性。作者指出，当同一数据在多个地方维护时，很容易出现同步错误。派生数据应该动态计算而非单独存储，这样可以避免数据不一致的问题。虽然计算成本可能增加，但可靠性是更重要的考虑因素。&lt;/p&gt;
&lt;p&gt;第二原则提出了一个反直觉的观点——请重复自己（PRY）。作者反思了DRY（Don&amp;rsquo;t Repeat Yourself）原则的局限性，认为过度抽象会导致代码复杂化，反而违背了简化的初衷。适度的代码重复有时是保持代码可维护性的更好选择。&lt;/p&gt;
&lt;p&gt;第三原则关注测试策略，建议避免过度使用Mock。Mock虽然能简化单元测试，但可能导致测试与实际环境脱节。作者推荐使用真实依赖或本地服务器进行测试，以提高测试的可靠性和实际意义。&lt;/p&gt;
&lt;p&gt;第四原则强调最小化可变状态的重要性。在优化过程中，过度依赖缓存和数据库会增加状态管理的复杂性。现代计算机性能足够强大，可以承受一定的冗余计算，因此简洁的状态管理应该优先于性能优化。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单一数据源&lt;/strong&gt;：指同一数据应该只在一个地方维护和存储，避免在多个位置重复保存相同数据。当需要数据时，应该从唯一的数据源获取，而不是使用本地缓存或副本。对于派生数据，应该通过计算获得而不是单独存储，这样可以避免数据同步错误和一致性问题的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PRY原则&lt;/strong&gt;：即&amp;quot;Please Repeat Yourself&amp;quot;，是对传统DRY原则的反思和补充。DRY原则强调不要重复代码，但过度应用会导致不必要的抽象，使代码变得复杂难懂。PRY原则认为，适度的代码重复是可接受的，有时候甚至是更好的选择，因为它可以保持代码的简单性和可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock依赖&lt;/strong&gt;：指在测试中使用模拟对象替代真实的依赖组件。Mock可以隔离被测试的代码，简化测试环境，但过度使用会导致测试与实际生产环境脱节，测试可能通过但实际运行时出现问题。作者建议尽量使用真实依赖或集成测试来验证软件的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变状态&lt;/strong&gt;：指程序运行过程中可以改变的数据状态。可变状态越多，状态同步和一致性管理的难度就越大。最小化可变状态意味着减少程序中需要维护的动态数据，优先使用不可变数据和计算结果，这样可以降低软件复杂度，减少同步错误的发生概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生数据&lt;/strong&gt;：指从原始数据通过计算或处理得到的数据。例如，可支配余额是从账户余额减去固定支出计算得到的。派生数据应该动态计算而不是单独存储，这样可以避免维护多个数据源导致的同步问题，确保数据的一致性和准确性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://read.engineerscodex.com/p/4-software-design-principles-i-learned?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;4 Software Design Principles I Learned the Hard Way&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Engineers Codex&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>那些听起来不错但几乎行不通的系统设计想法</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</guid><description>&lt;h1 id="那些听起来不错但几乎行不通的系统设计想法"&gt;那些听起来不错但几乎行不通的系统设计想法&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程中常见的八种&amp;quot;听起来不错但几乎行不通&amp;quot;的系统设计想法，包括可插拔架构、API设计、过度抽象、异步编程、访问控制、数据同步、跨平台设计和原生逃逸机制。作者基于丰富的工程经验指出，这些想法在实际操作中往往引入不必要的复杂性和风险，建议开发者基于第一性原理解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇点明了写作背景：在软件工程实践中，许多看似简单可行的系统设计想法，在实际操作中却往往以失败告终。作者强调，工程不仅是技术问题，更涉及社会学因素，许多失败的教训源于经验不足。&lt;/p&gt;
&lt;p&gt;文章主体部分详细列举并分析了八种常见的设计陷阱。每种想法都看似合理——比如&amp;quot;让它可插拔&amp;quot;以便后续替换实现、&amp;ldquo;添加一个API&amp;quot;将产品扩展为平台、&amp;ldquo;再抽象一次&amp;quot;来解决复杂性问题。然而，作者通过具体案例指出，可插拔性需要同时开发两种实现才能保证API行为的完整性，API的维护成本往往被低估，过早的抽象会导致代码冗余。&lt;/p&gt;
&lt;p&gt;进一步的分析揭示了异步编程在框架之外可能引发难以复现的错误，访问控制如果稍后添加往往需要重写整个系统，数据同步在语义化和事务性场景中极其复杂，跨平台设计最终需要构建类似操作系统的抽象层，而原生逃逸机制会破坏框架内部状态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可插拔架构的陷阱&lt;/strong&gt;：真正的可插拔性要求在设计初期就同时开发多种实现，因为API的行为不仅包括文档定义，还包括实际运行中的各种边界情况和副作用。如果只设计一种实现，后续替换几乎无法无缝进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API的平台化误区&lt;/strong&gt;：许多产品成功后试图通过API扩展为平台，但API需要在兼容性和功能之间不断权衡，维护成本巨大。同时，开发者往往高估了第三方对API的需求，实际使用率通常远低于预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过度抽象的代价&lt;/strong&gt;：虽然&amp;quot;所有问题都可以通过增加一层间接性来解决&amp;rdquo;，但过早引入的抽象往往永远不会被真正使用，反而增加了代码冗余和维护负担。Windows NT中就有大量这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程的双刃剑&lt;/strong&gt;：异步编程在理论上的效率优势在实践中可能被难以复现的错误和数据损坏问题所抵消，特别是在框架之外的场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性的不可后置性&lt;/strong&gt;：访问控制和安全性必须在设计初期就考虑，后续添加往往面临重写整个系统的挑战。安全不是可以&amp;quot;稍后添加&amp;quot;的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据同步的复杂性&lt;/strong&gt;：即使在理想化的语义化和事务性数据存储中，同步也充满挑战，更不用说涉及非结构化数据或数据转换的场景。这是分布式系统中最难的问题之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨平台的抽象陷阱&lt;/strong&gt;：跨平台设计看似简单，但随着功能复杂化，往往需要构建类似操作系统的抽象层，这个抽象层本身会成为巨大的维护负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生逃逸的隐患&lt;/strong&gt;：框架提供的&amp;quot;逃逸到原生&amp;quot;机制虽然看似提供了灵活性，但往往会破坏框架的内部状态，导致难以维护和调试的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://hardcoresoftware.learningbyshipping.com/p/225-systems-ideas-that-sound-good?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;225. Systems Ideas that Sound Good But Almost Never Work—&amp;ldquo;Let&amp;rsquo;s just…&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Steven Sinofsky&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>长期软件开发的思考与建议</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/long-term-software-development-guidance/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/long-term-software-development-guidance/</guid><description>&lt;h1 id="长期软件开发的思考与建议"&gt;长期软件开发的思考与建议&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者为荷兰选举委员会开发开源投票统计软件 Abacus 的实践经验，系统性地总结了长期软件开发的核心理念与方法。作者指出，与现今通过 CI/CD 持续迭代的软件服务不同，核电站、选举系统、心脏起搏器等领域的软件需要在未来数十年内保持稳定运行。文章从 Mastodon 社区收集了大量反馈，提炼出关于依赖管理、复杂性控制、测试策略、文档规范、团队建设等15个方面的实用建议，为需要长期维护的软件项目提供了全面的指导框架。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者受荷兰选举委员会邀请反思其开源投票统计软件为切入点，指出了长期软件开发与现代敏捷开发模式的本质差异。现今大多数软件作为服务提供，可以通过持续部署和持续集成来修复问题，但某些关键领域如核电站控制系统、选举软件、医疗设备等，要求软件在几十年内保持稳定运行，任何变更都需要提前规划和公告。&lt;/p&gt;
&lt;p&gt;作者在 Mastodon 社区征求意见后，收集了大量来自实践者的反馈，将这些经验整理成系统性的建议。文章的核心论点是：长期软件开发需要与传统开发模式完全不同的思维方式和技术选择。作者特别强调了依赖管理的重要性，将软件依赖分为四个层次——基础编程语言、紧密耦合的框架、数据库和可替换的辅助库，并指出越底层的依赖选择越关键。&lt;/p&gt;
&lt;p&gt;在复杂性管理方面，作者提出&amp;quot;复杂性是软件开发的最终敌人&amp;quot;这一核心观点，通过图表展示了代码复杂性与代码量之间的关系，强调必须在早期主动进行重构和简化。文章还详细讨论了测试的价值、文档的重要性、团队管理的策略以及开源的优势，并推荐了《编程实践》《人月神话》《软件设计哲学》等经典著作，最后引用了莱曼的软件进化法则来支持其观点。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;依赖层次结构&lt;/strong&gt;：软件依赖可分为四个层级——基础编程语言（最底层，最难更换）、紧密耦合的框架（深度集成，更换成本高）、数据库（数据存储核心，迁移复杂）和可替换的辅助库（最上层，相对容易替换）。长期软件开发必须格外关注底层依赖的选择，因为技术质量、使用者基数、维护状况、资金来源等因素都会影响依赖的长期稳定性。依赖可能随时间出现版本漂移、被废弃、甚至遭到劫持，因此建立定期健康检查机制至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;：复杂性会随着代码量的增加而自然增长，如果缺乏主动管理，系统最终会变得无法维护。作者强调必须在开发早期就持续进行重构和简化，而不是推迟到&amp;quot;以后&amp;quot;。简单的代码虽然可能不够&amp;quot;聪明&amp;quot;或不够高效，但更容易理解、调试和维护。在长期项目中，为了避免过早优化是万恶之源，应该优先选择编写无趣但简单的代码，而不是追求高性能但复杂的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lindy 效应与技术选择&lt;/strong&gt;：Lindy 效应指出，技术的预期寿命与其当前年龄成正比——一项技术已经存在的时间越长，它可能继续存在的时间也越长。这意味着在长期软件开发中，应该优先选择经过时间考验的技术，而不是被 LinkedIn 或社交媒体炒作的新技术。新技术的风险在于其长期价值尚未得到验证，可能在关键时刻失去支持或出现无法预见的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试的战略价值&lt;/strong&gt;：测试不仅是质量保证手段，更是长期维护的安全网。当依赖频繁变化时，完善的测试套件可以确保系统仍能正常工作；当项目暂停后重新启动时，测试可以帮助新开发者快速理解系统行为；当需要重构或移除依赖时，测试提供了变更的信心。测试的价值在长期项目中会呈指数级增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档与知识传承&lt;/strong&gt;：长期软件开发必须重视特定文档的需求，包括架构设计文档、API 文档、运维手册等。代码注释应该解释&amp;quot;为什么&amp;quot;而不是&amp;quot;做什么&amp;quot;，提交信息应该记录变更的原因。团队还需要建立内部 wiki 或知识库，记录决策过程、架构演进和故障经验。这些文档在原始开发者离开后，成为知识传承的关键载体。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://berthub.eu/articles/posts/on-long-term-software-development/"&gt;On Long Term Software Development&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Bert Hubert&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>