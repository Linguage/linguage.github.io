<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最佳实践 on Linguista</title><link>https://linguista.cn/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><description>Recent content in 最佳实践 on Linguista</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 18 Apr 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://linguista.cn/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/index.xml" rel="self" type="application/rss+xml"/><item><title>Claude Code 智能编程最佳实践指南</title><link>https://linguista.cn/rosetta/technology/claude-code-best-practices-for-agentic-coding/</link><pubDate>Fri, 18 Apr 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/rosetta/technology/claude-code-best-practices-for-agentic-coding/</guid><description>&lt;h1 id="claude-code-智能编程最佳实践指南"&gt;Claude Code 智能编程最佳实践指南&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍了 Anthropic 推出的命令行智能编程工具 Claude Code 的使用技巧与最佳实践。内容涵盖如何通过 CLAUDE.md 文件自定义开发环境、优化上下文配置、提升编码效率等方面，适用于不同代码库、编程语言和开发环境，帮助开发者更好地将 AI 融入日常编程工作流。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Agentic Coding&lt;/strong&gt;：指由 AI 代理自主完成编码任务的开发模式，AI 能够自动拉取上下文、理解代码结构并执行多步骤操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLAUDE.md&lt;/strong&gt;：Claude Code 的专用配置文件，用于定义项目规范、常用命令和代码风格等信息，启动对话时自动加载到上下文中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Context Gathering&lt;/strong&gt;：上下文收集机制，Claude Code 自动获取项目相关信息以辅助生成代码，但会消耗时间和 token，需要通过环境调优来优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prompt Tuning&lt;/strong&gt;：提示词调优，通过迭代和优化 CLAUDE.md 中的指令内容来提升模型的指令遵循能力，包括添加强调标记等技巧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Low-level Tool Design&lt;/strong&gt;：低层级工具设计理念，Claude Code 有意保持底层和无预设立场的设计，提供接近原始模型访问的灵活性而非强制特定工作流&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www-cdn.anthropic.com/images/4zrzovbb/website/6295100fcf8952bed666ba69536c581af87eef15-2554x2554.svg" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Published Apr 18, 2025&lt;/p&gt;
&lt;p&gt;Claude Code is a command line tool for agentic coding. This post covers tips and tricks that have proven effective for using Claude Code across various codebases, languages, and environments.&lt;/p&gt;</description></item><item><title>如何在软件开发中实现无缺陷代码</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/writing-bug-free-software-best-practices/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p3/writing-bug-free-software-best-practices/</guid><description>&lt;h1 id="如何在软件开发中实现无缺陷代码"&gt;如何在软件开发中实现&amp;quot;无缺陷&amp;quot;代码&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者在 Telegram 的工作经验，探讨了如何在软件开发中实现&amp;quot;无缺陷&amp;quot;代码。文章分析了当前软件行业对代码质量的两种极端观点——追求极致测试覆盖率与忽视质量快速交付功能，指出这两种策略都存在明显弊端。作者通过自身实践，提出了一条中间道路：通过提前规划、优化开发流程、减少复杂性等方式，在不牺牲开发速度的前提下写出高质量的代码。这种&amp;quot;无缺陷&amp;quot;编程方式最终会形成肌肉记忆，成为开发者无意识的技能。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先回顾了作者在 Telegram 的工作经历，在那里团队以接近&amp;quot;无缺陷&amp;quot;代码而闻名。虽然完全无缺陷是不可能的，但这种思维方式值得学习和推广。作者指出，软件行业对代码质量存在两种极端的误解：一端认为缺陷无关紧要，应该专注于快速交付功能；另一端则追求极致的测试覆盖率，确保代码在任何情况下都能正常工作。&lt;/p&gt;
&lt;p&gt;作者深入分析了这两种极端观点的弊端。追求极致测试会导致开发速度极慢、成本高昂、质量低下，还容易造成开发人员疲劳。而忽视质量快速交付功能，虽然短期内能看到成果，但长期来看会导致代码库难以维护，功能之间相互依赖，难以隔离问题区域。一些看似&amp;quot;成功&amp;quot;的实验最终因缺乏鲁棒性和可扩展性而需要重写，浪费了大量时间和金钱。&lt;/p&gt;
&lt;p&gt;作者进一步指出，试图平衡这两种极端策略的中间派往往也难以奏效。在企业环境中，管理层通常只关注新功能的交付，而忽视维护和修复缺陷的工作。这种不平衡导致维护团队感到被边缘化，最终影响项目成功。&lt;/p&gt;
&lt;p&gt;基于自身实践，作者分享了实现&amp;quot;无缺陷&amp;quot;代码的具体方法。首先是在技术设计阶段提前规划，但不过度规划。作者会花时间思考架构和技术选型，选择合适的工具和技术栈，避免引入不必要的复杂性。其次是持续优化开发流程，在项目启动时就建立良好的开发规范和工具链。最重要的是减少复杂性，作者认为减少开发复杂性的优化总是值得的，这能确保代码的可靠性和灵活性。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;无缺陷&amp;quot;代码思维&lt;/strong&gt;：这不是指追求绝对的零缺陷，而是建立一种追求正确性的编程习惯和思维方式。通过持续改进和对正确性的专注，开发者可以在不增加太多复杂性的情况下写出鲁棒的代码。这种思维最终会形成肌肉记忆，成为开发者无意识的技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提前规划与适度规划&lt;/strong&gt;：在技术设计阶段需要提前思考架构、技术选型和潜在风险，但要避免过度规划导致的分析瘫痪。关键是在项目启动时就选择合适的工具和技术栈，为后续开发奠定良好基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少开发复杂性&lt;/strong&gt;：这是作者强调的核心原则。减少复杂性的优化总是值得的，它能确保代码的可靠性和灵活性，避免后期陷入难以维护的代码库中。复杂性是代码质量的敌人，开发者应该时刻警惕不必要的复杂性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化开发流程&lt;/strong&gt;：在项目启动时投入时间建立良好的开发规范、工具链和测试流程，这看似会减慢初期开发速度，但长期来看能大幅提高开发效率和代码质量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理层对质量的忽视&lt;/strong&gt;：这是导致平衡策略难以奏效的组织层面原因。管理层往往只关注新功能交付，而忽视维护和缺陷修复工作，导致维护团队被边缘化，最终影响项目成功。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://korshakov.com/posts/no-bugs"&gt;You should write &amp;ldquo;without bugs&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Konstantin Korshakov&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2024&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件工程师应避免的十个行为</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-engineering-mistakes-to-avoid/</guid><description>&lt;h1 id="软件工程师应避免的十个行为"&gt;软件工程师应避免的十个行为&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;作者 Hoon Wee 基于五年以上的软件工程经验，分享了十个开发者应当避免的行为模式。这些经验涵盖了对代码质量的理解、开发流程的把控、职业心态的调整等多个维度，旨在帮助软件工程师摆脱常见误区，成长为更成熟的问题解决者。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以资深工程师的视角展开论述，首先指出了完美主义的陷阱——完美的代码并不存在，软件开发本质上是迭代的过程，专业能力体现在&amp;quot;足够好&amp;quot;而非&amp;quot;完美&amp;quot;。作者进一步强调重构应当融入日常开发流程，而非作为事后的额外请求，这体现了对工程质量的持续关注。&lt;/p&gt;
&lt;p&gt;在技术实践层面，作者重新定义了&amp;quot;遗留代码&amp;quot;的概念——它并非指旧代码，而是指缺乏测试的代码。这一观点揭示了可测试性与可维护性之间的本质联系。同时，作者警示不要盲目推崇函数式编程或遵循所谓的&amp;quot;最佳实践&amp;quot;，编程范式的选择应当基于具体场景和上下文判断，而非教条式套用。&lt;/p&gt;
&lt;p&gt;文章后半部分转向开发者工作方式和职业心态的探讨。作者反对独自挣扎解决问题，倡导利用团队智慧和现有方案；提醒在追求&amp;quot;心流&amp;quot;状态时保持自我觉察，建议采用番茄工作法避免倦怠。最后，作者强调了身体健康的重要性，并鼓励开发者保持对编程本身的热爱，从&amp;quot;码农&amp;quot;升级为用代码解决问题的&amp;quot;软件工程师&amp;quot;，以应对未来 AI 对简单编码工作的潜在替代。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;遗留代码的本质&lt;/strong&gt;：传统观点认为遗留代码等同于陈旧代码，但作者指出真正的定义是&amp;quot;没有测试的代码&amp;quot;。缺乏测试的代码无法安全重构，也无法维护；相反，即使技术栈较老（如 Next.js v10），只要测试覆盖良好，代码仍然具备可维护性。这一观点重新定义了代码质量的评判标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文驱动的技术选择&lt;/strong&gt;：函数式编程、清洁架构、SOLID 原则、TDD 等都是有力的工具，但没有放之四海而皆准的&amp;quot;最佳实践&amp;quot;。在 Clojure 或 Python 等语言中，TDD 可能并非必要；在 Flutter UI 层中，过度函数式化可能损害性能。成熟工程师的标志在于根据具体情境做出合理判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从编码者到问题解决者&lt;/strong&gt;：AI 时代正在重新定义软件开发者的价值。单纯写代码的能力（&amp;ldquo;码农&amp;rdquo;）面临被替代的风险，而运用代码解决实际问题的能力（&amp;ldquo;软件工程师&amp;rdquo;）将更加稀缺。这一转变要求开发者超越技术本身，关注业务价值和问题本质。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://favtutor.com/articles/donts-for-software-engineer/"&gt;Things You Should Never Do As A Software Engineer&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Hoon Wee&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>软件设计原则的四个教训</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/software-design-principles-lessons-learned/</guid><description>&lt;h1 id="软件设计原则的四个教训"&gt;软件设计原则的四个教训&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者设计和实现大型服务项目的实践经验，总结了四个重要的软件设计原则。这些原则从反面教训出发，帮助工程师避免常见的软件设计陷阱，包括数据同步问题、过度抽象、测试可靠性以及状态管理等核心议题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章首先介绍了作者的实践背景，通过一个大型服务项目的开发经历，提炼出四个反复出现的设计原则。这些原则往往与传统观点存在差异，体现了实践中获得的真实经验。&lt;/p&gt;
&lt;p&gt;第一原则强调维护单一数据源的重要性。作者指出，当同一数据在多个地方维护时，很容易出现同步错误。派生数据应该动态计算而非单独存储，这样可以避免数据不一致的问题。虽然计算成本可能增加，但可靠性是更重要的考虑因素。&lt;/p&gt;
&lt;p&gt;第二原则提出了一个反直觉的观点——请重复自己（PRY）。作者反思了DRY（Don&amp;rsquo;t Repeat Yourself）原则的局限性，认为过度抽象会导致代码复杂化，反而违背了简化的初衷。适度的代码重复有时是保持代码可维护性的更好选择。&lt;/p&gt;
&lt;p&gt;第三原则关注测试策略，建议避免过度使用Mock。Mock虽然能简化单元测试，但可能导致测试与实际环境脱节。作者推荐使用真实依赖或本地服务器进行测试，以提高测试的可靠性和实际意义。&lt;/p&gt;
&lt;p&gt;第四原则强调最小化可变状态的重要性。在优化过程中，过度依赖缓存和数据库会增加状态管理的复杂性。现代计算机性能足够强大，可以承受一定的冗余计算，因此简洁的状态管理应该优先于性能优化。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单一数据源&lt;/strong&gt;：指同一数据应该只在一个地方维护和存储，避免在多个位置重复保存相同数据。当需要数据时，应该从唯一的数据源获取，而不是使用本地缓存或副本。对于派生数据，应该通过计算获得而不是单独存储，这样可以避免数据同步错误和一致性问题的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PRY原则&lt;/strong&gt;：即&amp;quot;Please Repeat Yourself&amp;quot;，是对传统DRY原则的反思和补充。DRY原则强调不要重复代码，但过度应用会导致不必要的抽象，使代码变得复杂难懂。PRY原则认为，适度的代码重复是可接受的，有时候甚至是更好的选择，因为它可以保持代码的简单性和可读性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock依赖&lt;/strong&gt;：指在测试中使用模拟对象替代真实的依赖组件。Mock可以隔离被测试的代码，简化测试环境，但过度使用会导致测试与实际生产环境脱节，测试可能通过但实际运行时出现问题。作者建议尽量使用真实依赖或集成测试来验证软件的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可变状态&lt;/strong&gt;：指程序运行过程中可以改变的数据状态。可变状态越多，状态同步和一致性管理的难度就越大。最小化可变状态意味着减少程序中需要维护的动态数据，优先使用不可变数据和计算结果，这样可以降低软件复杂度，减少同步错误的发生概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;派生数据&lt;/strong&gt;：指从原始数据通过计算或处理得到的数据。例如，可支配余额是从账户余额减去固定支出计算得到的。派生数据应该动态计算而不是单独存储，这样可以避免维护多个数据源导致的同步问题，确保数据的一致性和准确性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://read.engineerscodex.com/p/4-software-design-principles-i-learned?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;4 Software Design Principles I Learned the Hard Way&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Engineers Codex&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>那些听起来不错但几乎行不通的系统设计想法</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/system-design-ideas-that-seldom-work/</guid><description>&lt;h1 id="那些听起来不错但几乎行不通的系统设计想法"&gt;那些听起来不错但几乎行不通的系统设计想法&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文探讨了软件工程中常见的八种&amp;quot;听起来不错但几乎行不通&amp;quot;的系统设计想法，包括可插拔架构、API设计、过度抽象、异步编程、访问控制、数据同步、跨平台设计和原生逃逸机制。作者基于丰富的工程经验指出，这些想法在实际操作中往往引入不必要的复杂性和风险，建议开发者基于第一性原理解决问题。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章开篇点明了写作背景：在软件工程实践中，许多看似简单可行的系统设计想法，在实际操作中却往往以失败告终。作者强调，工程不仅是技术问题，更涉及社会学因素，许多失败的教训源于经验不足。&lt;/p&gt;
&lt;p&gt;文章主体部分详细列举并分析了八种常见的设计陷阱。每种想法都看似合理——比如&amp;quot;让它可插拔&amp;quot;以便后续替换实现、&amp;ldquo;添加一个API&amp;quot;将产品扩展为平台、&amp;ldquo;再抽象一次&amp;quot;来解决复杂性问题。然而，作者通过具体案例指出，可插拔性需要同时开发两种实现才能保证API行为的完整性，API的维护成本往往被低估，过早的抽象会导致代码冗余。&lt;/p&gt;
&lt;p&gt;进一步的分析揭示了异步编程在框架之外可能引发难以复现的错误，访问控制如果稍后添加往往需要重写整个系统，数据同步在语义化和事务性场景中极其复杂，跨平台设计最终需要构建类似操作系统的抽象层，而原生逃逸机制会破坏框架内部状态。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可插拔架构的陷阱&lt;/strong&gt;：真正的可插拔性要求在设计初期就同时开发多种实现，因为API的行为不仅包括文档定义，还包括实际运行中的各种边界情况和副作用。如果只设计一种实现，后续替换几乎无法无缝进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API的平台化误区&lt;/strong&gt;：许多产品成功后试图通过API扩展为平台，但API需要在兼容性和功能之间不断权衡，维护成本巨大。同时，开发者往往高估了第三方对API的需求，实际使用率通常远低于预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过度抽象的代价&lt;/strong&gt;：虽然&amp;quot;所有问题都可以通过增加一层间接性来解决&amp;rdquo;，但过早引入的抽象往往永远不会被真正使用，反而增加了代码冗余和维护负担。Windows NT中就有大量这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步编程的双刃剑&lt;/strong&gt;：异步编程在理论上的效率优势在实践中可能被难以复现的错误和数据损坏问题所抵消，特别是在框架之外的场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性的不可后置性&lt;/strong&gt;：访问控制和安全性必须在设计初期就考虑，后续添加往往面临重写整个系统的挑战。安全不是可以&amp;quot;稍后添加&amp;quot;的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据同步的复杂性&lt;/strong&gt;：即使在理想化的语义化和事务性数据存储中，同步也充满挑战，更不用说涉及非结构化数据或数据转换的场景。这是分布式系统中最难的问题之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨平台的抽象陷阱&lt;/strong&gt;：跨平台设计看似简单，但随着功能复杂化，往往需要构建类似操作系统的抽象层，这个抽象层本身会成为巨大的维护负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生逃逸的隐患&lt;/strong&gt;：框架提供的&amp;quot;逃逸到原生&amp;quot;机制虽然看似提供了灵活性，但往往会破坏框架的内部状态，导致难以维护和调试的问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://hardcoresoftware.learningbyshipping.com/p/225-systems-ideas-that-sound-good?utm_source=bonobopress&amp;amp;utm_medium=newsletter&amp;amp;utm_campaign=1800"&gt;225. Systems Ideas that Sound Good But Almost Never Work—&amp;ldquo;Let&amp;rsquo;s just…&amp;rdquo;&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Steven Sinofsky&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;2025-01-22&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item><item><title>长期软件开发的思考与建议</title><link>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/long-term-software-development-guidance/</link><pubDate>Wed, 22 Jan 2025 00:00:00 +0800</pubDate><guid>https://linguista.cn/info/tldrcards/henrinotes_2025_p4/long-term-software-development-guidance/</guid><description>&lt;h1 id="长期软件开发的思考与建议"&gt;长期软件开发的思考与建议&lt;/h1&gt;
&lt;h2 id="摘要"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文基于作者为荷兰选举委员会开发开源投票统计软件 Abacus 的实践经验，系统性地总结了长期软件开发的核心理念与方法。作者指出，与现今通过 CI/CD 持续迭代的软件服务不同，核电站、选举系统、心脏起搏器等领域的软件需要在未来数十年内保持稳定运行。文章从 Mastodon 社区收集了大量反馈，提炼出关于依赖管理、复杂性控制、测试策略、文档规范、团队建设等15个方面的实用建议，为需要长期维护的软件项目提供了全面的指导框架。&lt;/p&gt;
&lt;h2 id="内容框架与概述"&gt;内容框架与概述&lt;/h2&gt;
&lt;p&gt;文章以作者受荷兰选举委员会邀请反思其开源投票统计软件为切入点，指出了长期软件开发与现代敏捷开发模式的本质差异。现今大多数软件作为服务提供，可以通过持续部署和持续集成来修复问题，但某些关键领域如核电站控制系统、选举软件、医疗设备等，要求软件在几十年内保持稳定运行，任何变更都需要提前规划和公告。&lt;/p&gt;
&lt;p&gt;作者在 Mastodon 社区征求意见后，收集了大量来自实践者的反馈，将这些经验整理成系统性的建议。文章的核心论点是：长期软件开发需要与传统开发模式完全不同的思维方式和技术选择。作者特别强调了依赖管理的重要性，将软件依赖分为四个层次——基础编程语言、紧密耦合的框架、数据库和可替换的辅助库，并指出越底层的依赖选择越关键。&lt;/p&gt;
&lt;p&gt;在复杂性管理方面，作者提出&amp;quot;复杂性是软件开发的最终敌人&amp;quot;这一核心观点，通过图表展示了代码复杂性与代码量之间的关系，强调必须在早期主动进行重构和简化。文章还详细讨论了测试的价值、文档的重要性、团队管理的策略以及开源的优势，并推荐了《编程实践》《人月神话》《软件设计哲学》等经典著作，最后引用了莱曼的软件进化法则来支持其观点。&lt;/p&gt;
&lt;h2 id="核心概念及解读"&gt;核心概念及解读&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;依赖层次结构&lt;/strong&gt;：软件依赖可分为四个层级——基础编程语言（最底层，最难更换）、紧密耦合的框架（深度集成，更换成本高）、数据库（数据存储核心，迁移复杂）和可替换的辅助库（最上层，相对容易替换）。长期软件开发必须格外关注底层依赖的选择，因为技术质量、使用者基数、维护状况、资金来源等因素都会影响依赖的长期稳定性。依赖可能随时间出现版本漂移、被废弃、甚至遭到劫持，因此建立定期健康检查机制至关重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂性管理&lt;/strong&gt;：复杂性会随着代码量的增加而自然增长，如果缺乏主动管理，系统最终会变得无法维护。作者强调必须在开发早期就持续进行重构和简化，而不是推迟到&amp;quot;以后&amp;quot;。简单的代码虽然可能不够&amp;quot;聪明&amp;quot;或不够高效，但更容易理解、调试和维护。在长期项目中，为了避免过早优化是万恶之源，应该优先选择编写无趣但简单的代码，而不是追求高性能但复杂的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lindy 效应与技术选择&lt;/strong&gt;：Lindy 效应指出，技术的预期寿命与其当前年龄成正比——一项技术已经存在的时间越长，它可能继续存在的时间也越长。这意味着在长期软件开发中，应该优先选择经过时间考验的技术，而不是被 LinkedIn 或社交媒体炒作的新技术。新技术的风险在于其长期价值尚未得到验证，可能在关键时刻失去支持或出现无法预见的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试的战略价值&lt;/strong&gt;：测试不仅是质量保证手段，更是长期维护的安全网。当依赖频繁变化时，完善的测试套件可以确保系统仍能正常工作；当项目暂停后重新启动时，测试可以帮助新开发者快速理解系统行为；当需要重构或移除依赖时，测试提供了变更的信心。测试的价值在长期项目中会呈指数级增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档与知识传承&lt;/strong&gt;：长期软件开发必须重视特定文档的需求，包括架构设计文档、API 文档、运维手册等。代码注释应该解释&amp;quot;为什么&amp;quot;而不是&amp;quot;做什么&amp;quot;，提交信息应该记录变更的原因。团队还需要建立内部 wiki 或知识库，记录决策过程、架构演进和故障经验。这些文档在原始开发者离开后，成为知识传承的关键载体。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文信息"&gt;原文信息&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;字段&lt;/th&gt;
 &lt;th&gt;内容&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;原文&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://berthub.eu/articles/posts/on-long-term-software-development/"&gt;On Long Term Software Development&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;作者&lt;/td&gt;
 &lt;td&gt;Bert Hubert&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;发表日期&lt;/td&gt;
 &lt;td&gt;未注明&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;此文档由 AI 自动整理&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>